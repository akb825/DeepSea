/*
 * Copyright 2022 Aaron Barany
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#define DS_REVERSE_Z

#include <DeepSea/Render/Shaders/Shadows/ShadowPCF4x4.mslh>
#include <DeepSea/Render/Shaders/Shadows/ShadowMap.mslh>
#include <DeepSea/Render/Shaders/CoordinateHelpers.mslh>

#include <DeepSea/Scene/Shaders/ViewTransform.mslh>
#include <DeepSea/SceneLighting/Shaders/DeferredSpotLight.mslh>

uniform sampler2DShadow shadowMap;
sampler_state shadowMap
{
	address_mode_u = clamp_to_edge;
	address_mode_v = clamp_to_edge;
	min_filter = linear;
	mag_filter = linear;
	compare_op = greater_or_equal;
}

uniform sampler2D materialColor;
sampler_state materialColor
{
	address_mode_u = clamp_to_edge;
	address_mode_v = clamp_to_edge;
	min_filter = nearest;
	mag_filter = nearest;
}

uniform sampler2D normalSpecular;
sampler_state normalSpecular
{
	address_mode_u = clamp_to_edge;
	address_mode_v = clamp_to_edge;
	min_filter = nearest;
	mag_filter = nearest;
}

uniform sampler2D surfaceDepth;
sampler_state surfaceDepth
{
	address_mode_u = clamp_to_edge;
	address_mode_v = clamp_to_edge;
	min_filter = nearest;
	mag_filter = nearest;
}

uniform ShadowTransform
{
	mat4 matrix;
	vec2 fadeDistances;
} dsShadowTransform;

[[fragment]] out vec4 outputColor;

[[fragment]]
void fragmentShader()
{
	vec2 clipCoords = vfClipCoords.xy/vfClipCoords.w;
	vec2 texCoords = dsClipToTexCoords(dsRotateScreenPosition(
		DS_ADJUST_CLIP(vec4(clipCoords, 0.0, 1.0)).xy));
	vec4 color = texture(materialColor, texCoords);
	// Alpha of 0 means clear color.
	if (color.a == 0)
	{
		outputColor = vec4(0.0, 0.0, 0.0, 1.0);
		return;
	}

	vec4 normalSpecularVal = texture(normalSpecular, texCoords);
	float depthVal = texture(surfaceDepth, texCoords).x;

	vec3 normal;
	normal.xy = normalSpecularVal.xy*2.0 - vec2(1.0);
	normal.z = sqrt(1.0 - min(dot(normal.xy, normal.xy), 1.0));

	float specular = normalSpecularVal.z;
	float shininess = normalSpecularVal.w*256.0;

	vec3 viewPosition = dsGetViewPositionFromClip(vec3(clipCoords, depthVal));
	vec3 viewDirection = -normalize(viewPosition);

	vec4 shadowPosition =
		DS_ADJUST_CLIP(INSTANCE(dsShadowTransform).matrix*vec4(viewPosition, 1.0));
	float shadowValue = dsShadowMap(shadowMap, viewPosition, shadowPosition.xyz/shadowPosition.w,
		INSTANCE(dsShadowTransform).fadeDistances,
		INSTANCE(dsViewTransform).clipSpaceTexCoordTransform);

	vec3 diffuseLight, specularLight;
	dsDeferredSpotLight_lightColor(diffuseLight, specularLight, viewPosition, normal,
		viewDirection, shininess);
	outputColor.xyz = (color.rgb*diffuseLight + specular*specularLight)*shadowValue;
	outputColor.w = 1.0;
}

pipeline SpotLight
{
	vertex = dsDeferredSpotLight_defaultVertex;
	fragment = fragmentShader;
	DS_DEFERRED_SPOT_LIGHT_RENDER_STATES
}
