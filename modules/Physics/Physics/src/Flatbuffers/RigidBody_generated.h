// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RIGIDBODY_DEEPSEAPHYSICS_H_
#define FLATBUFFERS_GENERATED_RIGIDBODY_DEEPSEAPHYSICS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "PhysicsCommon_generated.h"
#include "PhysicsShape_generated.h"

namespace DeepSeaPhysics {

struct RigidBody;
struct RigidBodyBuilder;

struct RigidBody FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RigidBodyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FLAGS = 4,
    VT_MOTIONTYPE = 6,
    VT_DOFMASK = 8,
    VT_LAYER = 10,
    VT_COLLISIONGROUP = 12,
    VT_POSITION = 14,
    VT_ORIENTATION = 16,
    VT_SCALE = 18,
    VT_LINEARVELOCITY = 20,
    VT_ANGULARVELOCITY = 22,
    VT_FRICTION = 24,
    VT_RESTITUTION = 26,
    VT_HARDNESS = 28,
    VT_LINEARDAMPING = 30,
    VT_ANGULARDAMPING = 32,
    VT_MAXLINEARVELOCITY = 34,
    VT_MAXANGULARVELOCITY = 36,
    VT_SHAPES = 38
  };
  DeepSeaPhysics::RigidBodyFlags flags() const {
    return static_cast<DeepSeaPhysics::RigidBodyFlags>(GetField<uint32_t>(VT_FLAGS, 0));
  }
  DeepSeaPhysics::MotionType motionType() const {
    return static_cast<DeepSeaPhysics::MotionType>(GetField<uint8_t>(VT_MOTIONTYPE, 0));
  }
  DeepSeaPhysics::DOFMask dofMask() const {
    return static_cast<DeepSeaPhysics::DOFMask>(GetField<uint8_t>(VT_DOFMASK, 0));
  }
  DeepSeaPhysics::PhysicsLayer layer() const {
    return static_cast<DeepSeaPhysics::PhysicsLayer>(GetField<uint8_t>(VT_LAYER, 0));
  }
  uint64_t collisionGroup() const {
    return GetField<uint64_t>(VT_COLLISIONGROUP, 0);
  }
  const DeepSeaPhysics::Vector3f *position() const {
    return GetStruct<const DeepSeaPhysics::Vector3f *>(VT_POSITION);
  }
  const DeepSeaPhysics::Quaternion4f *orientation() const {
    return GetStruct<const DeepSeaPhysics::Quaternion4f *>(VT_ORIENTATION);
  }
  const DeepSeaPhysics::Vector3f *scale() const {
    return GetStruct<const DeepSeaPhysics::Vector3f *>(VT_SCALE);
  }
  const DeepSeaPhysics::Vector3f *linearVelocity() const {
    return GetStruct<const DeepSeaPhysics::Vector3f *>(VT_LINEARVELOCITY);
  }
  const DeepSeaPhysics::Vector3f *angularVelocity() const {
    return GetStruct<const DeepSeaPhysics::Vector3f *>(VT_ANGULARVELOCITY);
  }
  float friction() const {
    return GetField<float>(VT_FRICTION, 0.0f);
  }
  float restitution() const {
    return GetField<float>(VT_RESTITUTION, 0.0f);
  }
  float hardness() const {
    return GetField<float>(VT_HARDNESS, 0.0f);
  }
  float linearDamping() const {
    return GetField<float>(VT_LINEARDAMPING, -1.0f);
  }
  float angularDamping() const {
    return GetField<float>(VT_ANGULARDAMPING, -1.0f);
  }
  float maxLinearVelocity() const {
    return GetField<float>(VT_MAXLINEARVELOCITY, 0.0f);
  }
  float maxAngularVelocity() const {
    return GetField<float>(VT_MAXANGULARVELOCITY, 0.0f);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaPhysics::ShapeInstance>> *shapes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaPhysics::ShapeInstance>> *>(VT_SHAPES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_FLAGS, 4) &&
           VerifyField<uint8_t>(verifier, VT_MOTIONTYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_DOFMASK, 1) &&
           VerifyField<uint8_t>(verifier, VT_LAYER, 1) &&
           VerifyField<uint64_t>(verifier, VT_COLLISIONGROUP, 8) &&
           VerifyField<DeepSeaPhysics::Vector3f>(verifier, VT_POSITION, 4) &&
           VerifyField<DeepSeaPhysics::Quaternion4f>(verifier, VT_ORIENTATION, 4) &&
           VerifyField<DeepSeaPhysics::Vector3f>(verifier, VT_SCALE, 4) &&
           VerifyField<DeepSeaPhysics::Vector3f>(verifier, VT_LINEARVELOCITY, 4) &&
           VerifyField<DeepSeaPhysics::Vector3f>(verifier, VT_ANGULARVELOCITY, 4) &&
           VerifyField<float>(verifier, VT_FRICTION, 4) &&
           VerifyField<float>(verifier, VT_RESTITUTION, 4) &&
           VerifyField<float>(verifier, VT_HARDNESS, 4) &&
           VerifyField<float>(verifier, VT_LINEARDAMPING, 4) &&
           VerifyField<float>(verifier, VT_ANGULARDAMPING, 4) &&
           VerifyField<float>(verifier, VT_MAXLINEARVELOCITY, 4) &&
           VerifyField<float>(verifier, VT_MAXANGULARVELOCITY, 4) &&
           VerifyOffset(verifier, VT_SHAPES) &&
           verifier.VerifyVector(shapes()) &&
           verifier.VerifyVectorOfTables(shapes()) &&
           verifier.EndTable();
  }
};

struct RigidBodyBuilder {
  typedef RigidBody Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_flags(DeepSeaPhysics::RigidBodyFlags flags) {
    fbb_.AddElement<uint32_t>(RigidBody::VT_FLAGS, static_cast<uint32_t>(flags), 0);
  }
  void add_motionType(DeepSeaPhysics::MotionType motionType) {
    fbb_.AddElement<uint8_t>(RigidBody::VT_MOTIONTYPE, static_cast<uint8_t>(motionType), 0);
  }
  void add_dofMask(DeepSeaPhysics::DOFMask dofMask) {
    fbb_.AddElement<uint8_t>(RigidBody::VT_DOFMASK, static_cast<uint8_t>(dofMask), 0);
  }
  void add_layer(DeepSeaPhysics::PhysicsLayer layer) {
    fbb_.AddElement<uint8_t>(RigidBody::VT_LAYER, static_cast<uint8_t>(layer), 0);
  }
  void add_collisionGroup(uint64_t collisionGroup) {
    fbb_.AddElement<uint64_t>(RigidBody::VT_COLLISIONGROUP, collisionGroup, 0);
  }
  void add_position(const DeepSeaPhysics::Vector3f *position) {
    fbb_.AddStruct(RigidBody::VT_POSITION, position);
  }
  void add_orientation(const DeepSeaPhysics::Quaternion4f *orientation) {
    fbb_.AddStruct(RigidBody::VT_ORIENTATION, orientation);
  }
  void add_scale(const DeepSeaPhysics::Vector3f *scale) {
    fbb_.AddStruct(RigidBody::VT_SCALE, scale);
  }
  void add_linearVelocity(const DeepSeaPhysics::Vector3f *linearVelocity) {
    fbb_.AddStruct(RigidBody::VT_LINEARVELOCITY, linearVelocity);
  }
  void add_angularVelocity(const DeepSeaPhysics::Vector3f *angularVelocity) {
    fbb_.AddStruct(RigidBody::VT_ANGULARVELOCITY, angularVelocity);
  }
  void add_friction(float friction) {
    fbb_.AddElement<float>(RigidBody::VT_FRICTION, friction, 0.0f);
  }
  void add_restitution(float restitution) {
    fbb_.AddElement<float>(RigidBody::VT_RESTITUTION, restitution, 0.0f);
  }
  void add_hardness(float hardness) {
    fbb_.AddElement<float>(RigidBody::VT_HARDNESS, hardness, 0.0f);
  }
  void add_linearDamping(float linearDamping) {
    fbb_.AddElement<float>(RigidBody::VT_LINEARDAMPING, linearDamping, -1.0f);
  }
  void add_angularDamping(float angularDamping) {
    fbb_.AddElement<float>(RigidBody::VT_ANGULARDAMPING, angularDamping, -1.0f);
  }
  void add_maxLinearVelocity(float maxLinearVelocity) {
    fbb_.AddElement<float>(RigidBody::VT_MAXLINEARVELOCITY, maxLinearVelocity, 0.0f);
  }
  void add_maxAngularVelocity(float maxAngularVelocity) {
    fbb_.AddElement<float>(RigidBody::VT_MAXANGULARVELOCITY, maxAngularVelocity, 0.0f);
  }
  void add_shapes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaPhysics::ShapeInstance>>> shapes) {
    fbb_.AddOffset(RigidBody::VT_SHAPES, shapes);
  }
  explicit RigidBodyBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RigidBody> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RigidBody>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RigidBody> CreateRigidBody(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    DeepSeaPhysics::RigidBodyFlags flags = static_cast<DeepSeaPhysics::RigidBodyFlags>(0),
    DeepSeaPhysics::MotionType motionType = DeepSeaPhysics::MotionType::Static,
    DeepSeaPhysics::DOFMask dofMask = DeepSeaPhysics::DOFMask::TransX,
    DeepSeaPhysics::PhysicsLayer layer = DeepSeaPhysics::PhysicsLayer::StaticWorld,
    uint64_t collisionGroup = 0,
    const DeepSeaPhysics::Vector3f *position = nullptr,
    const DeepSeaPhysics::Quaternion4f *orientation = nullptr,
    const DeepSeaPhysics::Vector3f *scale = nullptr,
    const DeepSeaPhysics::Vector3f *linearVelocity = nullptr,
    const DeepSeaPhysics::Vector3f *angularVelocity = nullptr,
    float friction = 0.0f,
    float restitution = 0.0f,
    float hardness = 0.0f,
    float linearDamping = -1.0f,
    float angularDamping = -1.0f,
    float maxLinearVelocity = 0.0f,
    float maxAngularVelocity = 0.0f,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaPhysics::ShapeInstance>>> shapes = 0) {
  RigidBodyBuilder builder_(_fbb);
  builder_.add_collisionGroup(collisionGroup);
  builder_.add_shapes(shapes);
  builder_.add_maxAngularVelocity(maxAngularVelocity);
  builder_.add_maxLinearVelocity(maxLinearVelocity);
  builder_.add_angularDamping(angularDamping);
  builder_.add_linearDamping(linearDamping);
  builder_.add_hardness(hardness);
  builder_.add_restitution(restitution);
  builder_.add_friction(friction);
  builder_.add_angularVelocity(angularVelocity);
  builder_.add_linearVelocity(linearVelocity);
  builder_.add_scale(scale);
  builder_.add_orientation(orientation);
  builder_.add_position(position);
  builder_.add_flags(flags);
  builder_.add_layer(layer);
  builder_.add_dofMask(dofMask);
  builder_.add_motionType(motionType);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RigidBody> CreateRigidBodyDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    DeepSeaPhysics::RigidBodyFlags flags = static_cast<DeepSeaPhysics::RigidBodyFlags>(0),
    DeepSeaPhysics::MotionType motionType = DeepSeaPhysics::MotionType::Static,
    DeepSeaPhysics::DOFMask dofMask = DeepSeaPhysics::DOFMask::TransX,
    DeepSeaPhysics::PhysicsLayer layer = DeepSeaPhysics::PhysicsLayer::StaticWorld,
    uint64_t collisionGroup = 0,
    const DeepSeaPhysics::Vector3f *position = nullptr,
    const DeepSeaPhysics::Quaternion4f *orientation = nullptr,
    const DeepSeaPhysics::Vector3f *scale = nullptr,
    const DeepSeaPhysics::Vector3f *linearVelocity = nullptr,
    const DeepSeaPhysics::Vector3f *angularVelocity = nullptr,
    float friction = 0.0f,
    float restitution = 0.0f,
    float hardness = 0.0f,
    float linearDamping = -1.0f,
    float angularDamping = -1.0f,
    float maxLinearVelocity = 0.0f,
    float maxAngularVelocity = 0.0f,
    const std::vector<::flatbuffers::Offset<DeepSeaPhysics::ShapeInstance>> *shapes = nullptr) {
  auto shapes__ = shapes ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaPhysics::ShapeInstance>>(*shapes) : 0;
  return DeepSeaPhysics::CreateRigidBody(
      _fbb,
      flags,
      motionType,
      dofMask,
      layer,
      collisionGroup,
      position,
      orientation,
      scale,
      linearVelocity,
      angularVelocity,
      friction,
      restitution,
      hardness,
      linearDamping,
      angularDamping,
      maxLinearVelocity,
      maxAngularVelocity,
      shapes__);
}

inline const DeepSeaPhysics::RigidBody *GetRigidBody(const void *buf) {
  return ::flatbuffers::GetRoot<DeepSeaPhysics::RigidBody>(buf);
}

inline const DeepSeaPhysics::RigidBody *GetSizePrefixedRigidBody(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<DeepSeaPhysics::RigidBody>(buf);
}

inline bool VerifyRigidBodyBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DeepSeaPhysics::RigidBody>(nullptr);
}

inline bool VerifySizePrefixedRigidBodyBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DeepSeaPhysics::RigidBody>(nullptr);
}

inline void FinishRigidBodyBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DeepSeaPhysics::RigidBody> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRigidBodyBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DeepSeaPhysics::RigidBody> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace DeepSeaPhysics

#endif  // FLATBUFFERS_GENERATED_RIGIDBODY_DEEPSEAPHYSICS_H_
