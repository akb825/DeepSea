// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PHYSICSCONSTRAINT_DEEPSEAPHYSICS_H_
#define FLATBUFFERS_GENERATED_PHYSICSCONSTRAINT_DEEPSEAPHYSICS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

#include "ConePhysicsConstraint_generated.h"
#include "DistancePhysicsConstraint_generated.h"
#include "FixedPhysicsConstraint_generated.h"
#include "GearPhysicsConstraint_generated.h"
#include "GenericPhysicsConstraint_generated.h"
#include "PointPhysicsConstraint_generated.h"
#include "RackAndPinionPhysicsConstraint_generated.h"
#include "RevolutePhysicsConstraint_generated.h"
#include "SliderPhysicsConstraint_generated.h"
#include "SwingTwistPhysicsConstraint_generated.h"

namespace DeepSeaPhysics {

struct Constraint;
struct ConstraintBuilder;

enum class ConstraintUnion : uint8_t {
  NONE = 0,
  FixedConstraint = 1,
  PointConstraint = 2,
  ConeConstraint = 3,
  SwingTwistConstraint = 4,
  RevoluteConstraint = 5,
  DistanceConstraint = 6,
  SliderConstraint = 7,
  GenericConstraint = 8,
  GearConstraint = 9,
  RackAndPinionConstraint = 10,
  MIN = NONE,
  MAX = RackAndPinionConstraint
};

inline const ConstraintUnion (&EnumValuesConstraintUnion())[11] {
  static const ConstraintUnion values[] = {
    ConstraintUnion::NONE,
    ConstraintUnion::FixedConstraint,
    ConstraintUnion::PointConstraint,
    ConstraintUnion::ConeConstraint,
    ConstraintUnion::SwingTwistConstraint,
    ConstraintUnion::RevoluteConstraint,
    ConstraintUnion::DistanceConstraint,
    ConstraintUnion::SliderConstraint,
    ConstraintUnion::GenericConstraint,
    ConstraintUnion::GearConstraint,
    ConstraintUnion::RackAndPinionConstraint
  };
  return values;
}

inline const char * const *EnumNamesConstraintUnion() {
  static const char * const names[12] = {
    "NONE",
    "FixedConstraint",
    "PointConstraint",
    "ConeConstraint",
    "SwingTwistConstraint",
    "RevoluteConstraint",
    "DistanceConstraint",
    "SliderConstraint",
    "GenericConstraint",
    "GearConstraint",
    "RackAndPinionConstraint",
    nullptr
  };
  return names;
}

inline const char *EnumNameConstraintUnion(ConstraintUnion e) {
  if (::flatbuffers::IsOutRange(e, ConstraintUnion::NONE, ConstraintUnion::RackAndPinionConstraint)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesConstraintUnion()[index];
}

template<typename T> struct ConstraintUnionTraits {
  static const ConstraintUnion enum_value = ConstraintUnion::NONE;
};

template<> struct ConstraintUnionTraits<DeepSeaPhysics::FixedConstraint> {
  static const ConstraintUnion enum_value = ConstraintUnion::FixedConstraint;
};

template<> struct ConstraintUnionTraits<DeepSeaPhysics::PointConstraint> {
  static const ConstraintUnion enum_value = ConstraintUnion::PointConstraint;
};

template<> struct ConstraintUnionTraits<DeepSeaPhysics::ConeConstraint> {
  static const ConstraintUnion enum_value = ConstraintUnion::ConeConstraint;
};

template<> struct ConstraintUnionTraits<DeepSeaPhysics::SwingTwistConstraint> {
  static const ConstraintUnion enum_value = ConstraintUnion::SwingTwistConstraint;
};

template<> struct ConstraintUnionTraits<DeepSeaPhysics::RevoluteConstraint> {
  static const ConstraintUnion enum_value = ConstraintUnion::RevoluteConstraint;
};

template<> struct ConstraintUnionTraits<DeepSeaPhysics::DistanceConstraint> {
  static const ConstraintUnion enum_value = ConstraintUnion::DistanceConstraint;
};

template<> struct ConstraintUnionTraits<DeepSeaPhysics::SliderConstraint> {
  static const ConstraintUnion enum_value = ConstraintUnion::SliderConstraint;
};

template<> struct ConstraintUnionTraits<DeepSeaPhysics::GenericConstraint> {
  static const ConstraintUnion enum_value = ConstraintUnion::GenericConstraint;
};

template<> struct ConstraintUnionTraits<DeepSeaPhysics::GearConstraint> {
  static const ConstraintUnion enum_value = ConstraintUnion::GearConstraint;
};

template<> struct ConstraintUnionTraits<DeepSeaPhysics::RackAndPinionConstraint> {
  static const ConstraintUnion enum_value = ConstraintUnion::RackAndPinionConstraint;
};

bool VerifyConstraintUnion(::flatbuffers::Verifier &verifier, const void *obj, ConstraintUnion type);
bool VerifyConstraintUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ConstraintUnion> *types);

struct Constraint FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConstraintBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSTRAINT_TYPE = 4,
    VT_CONSTRAINT = 6
  };
  DeepSeaPhysics::ConstraintUnion constraint_type() const {
    return static_cast<DeepSeaPhysics::ConstraintUnion>(GetField<uint8_t>(VT_CONSTRAINT_TYPE, 0));
  }
  const void *constraint() const {
    return GetPointer<const void *>(VT_CONSTRAINT);
  }
  template<typename T> const T *constraint_as() const;
  const DeepSeaPhysics::FixedConstraint *constraint_as_FixedConstraint() const {
    return constraint_type() == DeepSeaPhysics::ConstraintUnion::FixedConstraint ? static_cast<const DeepSeaPhysics::FixedConstraint *>(constraint()) : nullptr;
  }
  const DeepSeaPhysics::PointConstraint *constraint_as_PointConstraint() const {
    return constraint_type() == DeepSeaPhysics::ConstraintUnion::PointConstraint ? static_cast<const DeepSeaPhysics::PointConstraint *>(constraint()) : nullptr;
  }
  const DeepSeaPhysics::ConeConstraint *constraint_as_ConeConstraint() const {
    return constraint_type() == DeepSeaPhysics::ConstraintUnion::ConeConstraint ? static_cast<const DeepSeaPhysics::ConeConstraint *>(constraint()) : nullptr;
  }
  const DeepSeaPhysics::SwingTwistConstraint *constraint_as_SwingTwistConstraint() const {
    return constraint_type() == DeepSeaPhysics::ConstraintUnion::SwingTwistConstraint ? static_cast<const DeepSeaPhysics::SwingTwistConstraint *>(constraint()) : nullptr;
  }
  const DeepSeaPhysics::RevoluteConstraint *constraint_as_RevoluteConstraint() const {
    return constraint_type() == DeepSeaPhysics::ConstraintUnion::RevoluteConstraint ? static_cast<const DeepSeaPhysics::RevoluteConstraint *>(constraint()) : nullptr;
  }
  const DeepSeaPhysics::DistanceConstraint *constraint_as_DistanceConstraint() const {
    return constraint_type() == DeepSeaPhysics::ConstraintUnion::DistanceConstraint ? static_cast<const DeepSeaPhysics::DistanceConstraint *>(constraint()) : nullptr;
  }
  const DeepSeaPhysics::SliderConstraint *constraint_as_SliderConstraint() const {
    return constraint_type() == DeepSeaPhysics::ConstraintUnion::SliderConstraint ? static_cast<const DeepSeaPhysics::SliderConstraint *>(constraint()) : nullptr;
  }
  const DeepSeaPhysics::GenericConstraint *constraint_as_GenericConstraint() const {
    return constraint_type() == DeepSeaPhysics::ConstraintUnion::GenericConstraint ? static_cast<const DeepSeaPhysics::GenericConstraint *>(constraint()) : nullptr;
  }
  const DeepSeaPhysics::GearConstraint *constraint_as_GearConstraint() const {
    return constraint_type() == DeepSeaPhysics::ConstraintUnion::GearConstraint ? static_cast<const DeepSeaPhysics::GearConstraint *>(constraint()) : nullptr;
  }
  const DeepSeaPhysics::RackAndPinionConstraint *constraint_as_RackAndPinionConstraint() const {
    return constraint_type() == DeepSeaPhysics::ConstraintUnion::RackAndPinionConstraint ? static_cast<const DeepSeaPhysics::RackAndPinionConstraint *>(constraint()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CONSTRAINT_TYPE, 1) &&
           VerifyOffset(verifier, VT_CONSTRAINT) &&
           VerifyConstraintUnion(verifier, constraint(), constraint_type()) &&
           verifier.EndTable();
  }
};

template<> inline const DeepSeaPhysics::FixedConstraint *Constraint::constraint_as<DeepSeaPhysics::FixedConstraint>() const {
  return constraint_as_FixedConstraint();
}

template<> inline const DeepSeaPhysics::PointConstraint *Constraint::constraint_as<DeepSeaPhysics::PointConstraint>() const {
  return constraint_as_PointConstraint();
}

template<> inline const DeepSeaPhysics::ConeConstraint *Constraint::constraint_as<DeepSeaPhysics::ConeConstraint>() const {
  return constraint_as_ConeConstraint();
}

template<> inline const DeepSeaPhysics::SwingTwistConstraint *Constraint::constraint_as<DeepSeaPhysics::SwingTwistConstraint>() const {
  return constraint_as_SwingTwistConstraint();
}

template<> inline const DeepSeaPhysics::RevoluteConstraint *Constraint::constraint_as<DeepSeaPhysics::RevoluteConstraint>() const {
  return constraint_as_RevoluteConstraint();
}

template<> inline const DeepSeaPhysics::DistanceConstraint *Constraint::constraint_as<DeepSeaPhysics::DistanceConstraint>() const {
  return constraint_as_DistanceConstraint();
}

template<> inline const DeepSeaPhysics::SliderConstraint *Constraint::constraint_as<DeepSeaPhysics::SliderConstraint>() const {
  return constraint_as_SliderConstraint();
}

template<> inline const DeepSeaPhysics::GenericConstraint *Constraint::constraint_as<DeepSeaPhysics::GenericConstraint>() const {
  return constraint_as_GenericConstraint();
}

template<> inline const DeepSeaPhysics::GearConstraint *Constraint::constraint_as<DeepSeaPhysics::GearConstraint>() const {
  return constraint_as_GearConstraint();
}

template<> inline const DeepSeaPhysics::RackAndPinionConstraint *Constraint::constraint_as<DeepSeaPhysics::RackAndPinionConstraint>() const {
  return constraint_as_RackAndPinionConstraint();
}

struct ConstraintBuilder {
  typedef Constraint Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_constraint_type(DeepSeaPhysics::ConstraintUnion constraint_type) {
    fbb_.AddElement<uint8_t>(Constraint::VT_CONSTRAINT_TYPE, static_cast<uint8_t>(constraint_type), 0);
  }
  void add_constraint(::flatbuffers::Offset<void> constraint) {
    fbb_.AddOffset(Constraint::VT_CONSTRAINT, constraint);
  }
  explicit ConstraintBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Constraint> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Constraint>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Constraint> CreateConstraint(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    DeepSeaPhysics::ConstraintUnion constraint_type = DeepSeaPhysics::ConstraintUnion::NONE,
    ::flatbuffers::Offset<void> constraint = 0) {
  ConstraintBuilder builder_(_fbb);
  builder_.add_constraint(constraint);
  builder_.add_constraint_type(constraint_type);
  return builder_.Finish();
}

inline bool VerifyConstraintUnion(::flatbuffers::Verifier &verifier, const void *obj, ConstraintUnion type) {
  switch (type) {
    case ConstraintUnion::NONE: {
      return true;
    }
    case ConstraintUnion::FixedConstraint: {
      auto ptr = reinterpret_cast<const DeepSeaPhysics::FixedConstraint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ConstraintUnion::PointConstraint: {
      auto ptr = reinterpret_cast<const DeepSeaPhysics::PointConstraint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ConstraintUnion::ConeConstraint: {
      auto ptr = reinterpret_cast<const DeepSeaPhysics::ConeConstraint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ConstraintUnion::SwingTwistConstraint: {
      auto ptr = reinterpret_cast<const DeepSeaPhysics::SwingTwistConstraint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ConstraintUnion::RevoluteConstraint: {
      auto ptr = reinterpret_cast<const DeepSeaPhysics::RevoluteConstraint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ConstraintUnion::DistanceConstraint: {
      auto ptr = reinterpret_cast<const DeepSeaPhysics::DistanceConstraint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ConstraintUnion::SliderConstraint: {
      auto ptr = reinterpret_cast<const DeepSeaPhysics::SliderConstraint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ConstraintUnion::GenericConstraint: {
      auto ptr = reinterpret_cast<const DeepSeaPhysics::GenericConstraint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ConstraintUnion::GearConstraint: {
      auto ptr = reinterpret_cast<const DeepSeaPhysics::GearConstraint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ConstraintUnion::RackAndPinionConstraint: {
      auto ptr = reinterpret_cast<const DeepSeaPhysics::RackAndPinionConstraint *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyConstraintUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ConstraintUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyConstraintUnion(
        verifier,  values->Get(i), types->GetEnum<ConstraintUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline const DeepSeaPhysics::Constraint *GetConstraint(const void *buf) {
  return ::flatbuffers::GetRoot<DeepSeaPhysics::Constraint>(buf);
}

inline const DeepSeaPhysics::Constraint *GetSizePrefixedConstraint(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<DeepSeaPhysics::Constraint>(buf);
}

inline bool VerifyConstraintBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DeepSeaPhysics::Constraint>(nullptr);
}

inline bool VerifySizePrefixedConstraintBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DeepSeaPhysics::Constraint>(nullptr);
}

inline void FinishConstraintBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DeepSeaPhysics::Constraint> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedConstraintBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DeepSeaPhysics::Constraint> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace DeepSeaPhysics

#endif  // FLATBUFFERS_GENERATED_PHYSICSCONSTRAINT_DEEPSEAPHYSICS_H_
