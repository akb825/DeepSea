// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PHYSICSCOMMON_DEEPSEAPHYSICS_H_
#define FLATBUFFERS_GENERATED_PHYSICSCOMMON_DEEPSEAPHYSICS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace DeepSeaPhysics {

struct Vector3f;

struct Quaternion4f;

struct ShapePartMaterial;

enum class Axis : uint8_t {
  X = 0,
  Y = 1,
  Z = 2,
  MIN = X,
  MAX = Z
};

inline const Axis (&EnumValuesAxis())[3] {
  static const Axis values[] = {
    Axis::X,
    Axis::Y,
    Axis::Z
  };
  return values;
}

inline const char * const *EnumNamesAxis() {
  static const char * const names[4] = {
    "X",
    "Y",
    "Z",
    nullptr
  };
  return names;
}

inline const char *EnumNameAxis(Axis e) {
  if (::flatbuffers::IsOutRange(e, Axis::X, Axis::Z)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAxis()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector3f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector3f()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vector3f(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vector3f, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Quaternion4f FLATBUFFERS_FINAL_CLASS {
 private:
  float i_;
  float j_;
  float k_;
  float r_;

 public:
  Quaternion4f()
      : i_(0),
        j_(0),
        k_(0),
        r_(0) {
  }
  Quaternion4f(float _i, float _j, float _k, float _r)
      : i_(::flatbuffers::EndianScalar(_i)),
        j_(::flatbuffers::EndianScalar(_j)),
        k_(::flatbuffers::EndianScalar(_k)),
        r_(::flatbuffers::EndianScalar(_r)) {
  }
  float i() const {
    return ::flatbuffers::EndianScalar(i_);
  }
  float j() const {
    return ::flatbuffers::EndianScalar(j_);
  }
  float k() const {
    return ::flatbuffers::EndianScalar(k_);
  }
  float r() const {
    return ::flatbuffers::EndianScalar(r_);
  }
};
FLATBUFFERS_STRUCT_END(Quaternion4f, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ShapePartMaterial FLATBUFFERS_FINAL_CLASS {
 private:
  float friction_;
  float restitution_;
  float hardness_;

 public:
  ShapePartMaterial()
      : friction_(0),
        restitution_(0),
        hardness_(0) {
  }
  ShapePartMaterial(float _friction, float _restitution, float _hardness)
      : friction_(::flatbuffers::EndianScalar(_friction)),
        restitution_(::flatbuffers::EndianScalar(_restitution)),
        hardness_(::flatbuffers::EndianScalar(_hardness)) {
  }
  float friction() const {
    return ::flatbuffers::EndianScalar(friction_);
  }
  float restitution() const {
    return ::flatbuffers::EndianScalar(restitution_);
  }
  float hardness() const {
    return ::flatbuffers::EndianScalar(hardness_);
  }
};
FLATBUFFERS_STRUCT_END(ShapePartMaterial, 12);

}  // namespace DeepSeaPhysics

#endif  // FLATBUFFERS_GENERATED_PHYSICSCOMMON_DEEPSEAPHYSICS_H_
