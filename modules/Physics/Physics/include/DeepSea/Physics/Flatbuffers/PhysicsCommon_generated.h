// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PHYSICSCOMMON_DEEPSEAPHYSICS_H_
#define FLATBUFFERS_GENERATED_PHYSICSCOMMON_DEEPSEAPHYSICS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 9 &&
              FLATBUFFERS_VERSION_REVISION == 23,
             "Non-compatible flatbuffers version included");

namespace DeepSeaPhysics {

struct Vector3f;

struct Matrix33f;

struct Quaternion4f;

struct ShapePartMaterial;

struct ShiftedMass;
struct ShiftedMassBuilder;

struct MassProperties;
struct MassPropertiesBuilder;

enum class Axis : uint8_t {
  X = 0,
  Y = 1,
  Z = 2,
  MIN = X,
  MAX = Z
};

inline const Axis (&EnumValuesAxis())[3] {
  static const Axis values[] = {
    Axis::X,
    Axis::Y,
    Axis::Z
  };
  return values;
}

inline const char * const *EnumNamesAxis() {
  static const char * const names[4] = {
    "X",
    "Y",
    "Z",
    nullptr
  };
  return names;
}

inline const char *EnumNameAxis(Axis e) {
  if (::flatbuffers::IsOutRange(e, Axis::X, Axis::Z)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAxis()[index];
}

enum class MotionType : uint8_t {
  Static = 0,
  Kinematic = 1,
  Dynamic = 2,
  Unknown = 3,
  MIN = Static,
  MAX = Unknown
};

inline const MotionType (&EnumValuesMotionType())[4] {
  static const MotionType values[] = {
    MotionType::Static,
    MotionType::Kinematic,
    MotionType::Dynamic,
    MotionType::Unknown
  };
  return values;
}

inline const char * const *EnumNamesMotionType() {
  static const char * const names[5] = {
    "Static",
    "Kinematic",
    "Dynamic",
    "Unknown",
    nullptr
  };
  return names;
}

inline const char *EnumNameMotionType(MotionType e) {
  if (::flatbuffers::IsOutRange(e, MotionType::Static, MotionType::Unknown)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMotionType()[index];
}

enum class DOFMask : uint8_t {
  None = 0,
  TranslateX = 1,
  TranslateY = 2,
  TranslateZ = 4,
  TranslateAll = 7,
  RotlateX = 8,
  RotlateY = 16,
  RotlateZ = 32,
  RotateAll = 56,
  All = 63,
  MIN = None,
  MAX = All
};

inline const DOFMask (&EnumValuesDOFMask())[10] {
  static const DOFMask values[] = {
    DOFMask::None,
    DOFMask::TranslateX,
    DOFMask::TranslateY,
    DOFMask::TranslateZ,
    DOFMask::TranslateAll,
    DOFMask::RotlateX,
    DOFMask::RotlateY,
    DOFMask::RotlateZ,
    DOFMask::RotateAll,
    DOFMask::All
  };
  return values;
}

inline const char *EnumNameDOFMask(DOFMask e) {
  switch (e) {
    case DOFMask::None: return "None";
    case DOFMask::TranslateX: return "TranslateX";
    case DOFMask::TranslateY: return "TranslateY";
    case DOFMask::TranslateZ: return "TranslateZ";
    case DOFMask::TranslateAll: return "TranslateAll";
    case DOFMask::RotlateX: return "RotlateX";
    case DOFMask::RotlateY: return "RotlateY";
    case DOFMask::RotlateZ: return "RotlateZ";
    case DOFMask::RotateAll: return "RotateAll";
    case DOFMask::All: return "All";
    default: return "";
  }
}

enum class DOF : uint8_t {
  TranslateX = 0,
  TranslateY = 1,
  TranslateZ = 2,
  RotlateX = 3,
  RotlateY = 4,
  RotlateZ = 5,
  MIN = TranslateX,
  MAX = RotlateZ
};

inline const DOF (&EnumValuesDOF())[6] {
  static const DOF values[] = {
    DOF::TranslateX,
    DOF::TranslateY,
    DOF::TranslateZ,
    DOF::RotlateX,
    DOF::RotlateY,
    DOF::RotlateZ
  };
  return values;
}

inline const char * const *EnumNamesDOF() {
  static const char * const names[7] = {
    "TranslateX",
    "TranslateY",
    "TranslateZ",
    "RotlateX",
    "RotlateY",
    "RotlateZ",
    nullptr
  };
  return names;
}

inline const char *EnumNameDOF(DOF e) {
  if (::flatbuffers::IsOutRange(e, DOF::TranslateX, DOF::RotlateZ)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDOF()[index];
}

enum class PhysicsLayer : uint8_t {
  StaticWorld = 0,
  Objects = 1,
  Projectiles = 2,
  MIN = StaticWorld,
  MAX = Projectiles
};

inline const PhysicsLayer (&EnumValuesPhysicsLayer())[3] {
  static const PhysicsLayer values[] = {
    PhysicsLayer::StaticWorld,
    PhysicsLayer::Objects,
    PhysicsLayer::Projectiles
  };
  return values;
}

inline const char * const *EnumNamesPhysicsLayer() {
  static const char * const names[4] = {
    "StaticWorld",
    "Objects",
    "Projectiles",
    nullptr
  };
  return names;
}

inline const char *EnumNamePhysicsLayer(PhysicsLayer e) {
  if (::flatbuffers::IsOutRange(e, PhysicsLayer::StaticWorld, PhysicsLayer::Projectiles)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPhysicsLayer()[index];
}

enum class RigidBodyFlags : uint32_t {
  MutableMotionType = 1,
  MutableShape = 2,
  Scalable = 4,
  LinearCollision = 8,
  Sensor = 16,
  SensorDetectStatic = 32,
  AlwaysActive = 64,
  DisableGravity = 128,
  GyroscopicForces = 256,
  AllContacts = 512,
  CustomContactProperties = 1024,
  ContactCallbacks = 2048,
  NONE = 0,
  ANY = 4095
};
FLATBUFFERS_DEFINE_BITMASK_OPERATORS(RigidBodyFlags, uint32_t)

inline const RigidBodyFlags (&EnumValuesRigidBodyFlags())[12] {
  static const RigidBodyFlags values[] = {
    RigidBodyFlags::MutableMotionType,
    RigidBodyFlags::MutableShape,
    RigidBodyFlags::Scalable,
    RigidBodyFlags::LinearCollision,
    RigidBodyFlags::Sensor,
    RigidBodyFlags::SensorDetectStatic,
    RigidBodyFlags::AlwaysActive,
    RigidBodyFlags::DisableGravity,
    RigidBodyFlags::GyroscopicForces,
    RigidBodyFlags::AllContacts,
    RigidBodyFlags::CustomContactProperties,
    RigidBodyFlags::ContactCallbacks
  };
  return values;
}

inline const char *EnumNameRigidBodyFlags(RigidBodyFlags e) {
  switch (e) {
    case RigidBodyFlags::MutableMotionType: return "MutableMotionType";
    case RigidBodyFlags::MutableShape: return "MutableShape";
    case RigidBodyFlags::Scalable: return "Scalable";
    case RigidBodyFlags::LinearCollision: return "LinearCollision";
    case RigidBodyFlags::Sensor: return "Sensor";
    case RigidBodyFlags::SensorDetectStatic: return "SensorDetectStatic";
    case RigidBodyFlags::AlwaysActive: return "AlwaysActive";
    case RigidBodyFlags::DisableGravity: return "DisableGravity";
    case RigidBodyFlags::GyroscopicForces: return "GyroscopicForces";
    case RigidBodyFlags::AllContacts: return "AllContacts";
    case RigidBodyFlags::CustomContactProperties: return "CustomContactProperties";
    case RigidBodyFlags::ContactCallbacks: return "ContactCallbacks";
    default: return "";
  }
}

enum class ConstraintMotorType : uint8_t {
  Disabled = 0,
  Position = 1,
  Velocity = 2,
  MIN = Disabled,
  MAX = Velocity
};

inline const ConstraintMotorType (&EnumValuesConstraintMotorType())[3] {
  static const ConstraintMotorType values[] = {
    ConstraintMotorType::Disabled,
    ConstraintMotorType::Position,
    ConstraintMotorType::Velocity
  };
  return values;
}

inline const char * const *EnumNamesConstraintMotorType() {
  static const char * const names[4] = {
    "Disabled",
    "Position",
    "Velocity",
    nullptr
  };
  return names;
}

inline const char *EnumNameConstraintMotorType(ConstraintMotorType e) {
  if (::flatbuffers::IsOutRange(e, ConstraintMotorType::Disabled, ConstraintMotorType::Velocity)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesConstraintMotorType()[index];
}

enum class CustomMassProperties : uint8_t {
  NONE = 0,
  ShiftedMass = 1,
  MassProperties = 2,
  MIN = NONE,
  MAX = MassProperties
};

inline const CustomMassProperties (&EnumValuesCustomMassProperties())[3] {
  static const CustomMassProperties values[] = {
    CustomMassProperties::NONE,
    CustomMassProperties::ShiftedMass,
    CustomMassProperties::MassProperties
  };
  return values;
}

inline const char * const *EnumNamesCustomMassProperties() {
  static const char * const names[4] = {
    "NONE",
    "ShiftedMass",
    "MassProperties",
    nullptr
  };
  return names;
}

inline const char *EnumNameCustomMassProperties(CustomMassProperties e) {
  if (::flatbuffers::IsOutRange(e, CustomMassProperties::NONE, CustomMassProperties::MassProperties)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCustomMassProperties()[index];
}

template<typename T> struct CustomMassPropertiesTraits {
  static const CustomMassProperties enum_value = CustomMassProperties::NONE;
};

template<> struct CustomMassPropertiesTraits<DeepSeaPhysics::ShiftedMass> {
  static const CustomMassProperties enum_value = CustomMassProperties::ShiftedMass;
};

template<> struct CustomMassPropertiesTraits<DeepSeaPhysics::MassProperties> {
  static const CustomMassProperties enum_value = CustomMassProperties::MassProperties;
};

bool VerifyCustomMassProperties(::flatbuffers::Verifier &verifier, const void *obj, CustomMassProperties type);
bool VerifyCustomMassPropertiesVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<CustomMassProperties> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector3f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector3f()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vector3f(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vector3f, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Matrix33f FLATBUFFERS_FINAL_CLASS {
 private:
  DeepSeaPhysics::Vector3f column0_;
  DeepSeaPhysics::Vector3f column1_;
  DeepSeaPhysics::Vector3f column2_;

 public:
  Matrix33f()
      : column0_(),
        column1_(),
        column2_() {
  }
  Matrix33f(const DeepSeaPhysics::Vector3f &_column0, const DeepSeaPhysics::Vector3f &_column1, const DeepSeaPhysics::Vector3f &_column2)
      : column0_(_column0),
        column1_(_column1),
        column2_(_column2) {
  }
  const DeepSeaPhysics::Vector3f &column0() const {
    return column0_;
  }
  const DeepSeaPhysics::Vector3f &column1() const {
    return column1_;
  }
  const DeepSeaPhysics::Vector3f &column2() const {
    return column2_;
  }
};
FLATBUFFERS_STRUCT_END(Matrix33f, 36);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Quaternion4f FLATBUFFERS_FINAL_CLASS {
 private:
  float i_;
  float j_;
  float k_;
  float r_;

 public:
  Quaternion4f()
      : i_(0),
        j_(0),
        k_(0),
        r_(0) {
  }
  Quaternion4f(float _i, float _j, float _k, float _r)
      : i_(::flatbuffers::EndianScalar(_i)),
        j_(::flatbuffers::EndianScalar(_j)),
        k_(::flatbuffers::EndianScalar(_k)),
        r_(::flatbuffers::EndianScalar(_r)) {
  }
  float i() const {
    return ::flatbuffers::EndianScalar(i_);
  }
  float j() const {
    return ::flatbuffers::EndianScalar(j_);
  }
  float k() const {
    return ::flatbuffers::EndianScalar(k_);
  }
  float r() const {
    return ::flatbuffers::EndianScalar(r_);
  }
};
FLATBUFFERS_STRUCT_END(Quaternion4f, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ShapePartMaterial FLATBUFFERS_FINAL_CLASS {
 private:
  float friction_;
  float restitution_;
  float hardness_;

 public:
  ShapePartMaterial()
      : friction_(0),
        restitution_(0),
        hardness_(0) {
  }
  ShapePartMaterial(float _friction, float _restitution, float _hardness)
      : friction_(::flatbuffers::EndianScalar(_friction)),
        restitution_(::flatbuffers::EndianScalar(_restitution)),
        hardness_(::flatbuffers::EndianScalar(_hardness)) {
  }
  float friction() const {
    return ::flatbuffers::EndianScalar(friction_);
  }
  float restitution() const {
    return ::flatbuffers::EndianScalar(restitution_);
  }
  float hardness() const {
    return ::flatbuffers::EndianScalar(hardness_);
  }
};
FLATBUFFERS_STRUCT_END(ShapePartMaterial, 12);

struct ShiftedMass FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShiftedMassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MASS = 4,
    VT_ROTATIONPOINTSHIFT = 6
  };
  float mass() const {
    return GetField<float>(VT_MASS, -1.0f);
  }
  const DeepSeaPhysics::Vector3f *rotationPointShift() const {
    return GetStruct<const DeepSeaPhysics::Vector3f *>(VT_ROTATIONPOINTSHIFT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MASS, 4) &&
           VerifyField<DeepSeaPhysics::Vector3f>(verifier, VT_ROTATIONPOINTSHIFT, 4) &&
           verifier.EndTable();
  }
};

struct ShiftedMassBuilder {
  typedef ShiftedMass Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_mass(float mass) {
    fbb_.AddElement<float>(ShiftedMass::VT_MASS, mass, -1.0f);
  }
  void add_rotationPointShift(const DeepSeaPhysics::Vector3f *rotationPointShift) {
    fbb_.AddStruct(ShiftedMass::VT_ROTATIONPOINTSHIFT, rotationPointShift);
  }
  explicit ShiftedMassBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShiftedMass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShiftedMass>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ShiftedMass> CreateShiftedMass(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float mass = -1.0f,
    const DeepSeaPhysics::Vector3f *rotationPointShift = nullptr) {
  ShiftedMassBuilder builder_(_fbb);
  builder_.add_rotationPointShift(rotationPointShift);
  builder_.add_mass(mass);
  return builder_.Finish();
}

struct MassProperties FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MassPropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTEREDINERTIA = 4,
    VT_CENTEROFMASS = 6,
    VT_MASS = 8,
    VT_INERTIATRANSLATE = 10,
    VT_INERTIAROTATE = 12
  };
  const DeepSeaPhysics::Matrix33f *centeredInertia() const {
    return GetStruct<const DeepSeaPhysics::Matrix33f *>(VT_CENTEREDINERTIA);
  }
  const DeepSeaPhysics::Vector3f *centerOfMass() const {
    return GetStruct<const DeepSeaPhysics::Vector3f *>(VT_CENTEROFMASS);
  }
  float mass() const {
    return GetField<float>(VT_MASS, 0.0f);
  }
  const DeepSeaPhysics::Vector3f *inertiaTranslate() const {
    return GetStruct<const DeepSeaPhysics::Vector3f *>(VT_INERTIATRANSLATE);
  }
  const DeepSeaPhysics::Quaternion4f *inertiaRotate() const {
    return GetStruct<const DeepSeaPhysics::Quaternion4f *>(VT_INERTIAROTATE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<DeepSeaPhysics::Matrix33f>(verifier, VT_CENTEREDINERTIA, 4) &&
           VerifyField<DeepSeaPhysics::Vector3f>(verifier, VT_CENTEROFMASS, 4) &&
           VerifyField<float>(verifier, VT_MASS, 4) &&
           VerifyField<DeepSeaPhysics::Vector3f>(verifier, VT_INERTIATRANSLATE, 4) &&
           VerifyField<DeepSeaPhysics::Quaternion4f>(verifier, VT_INERTIAROTATE, 4) &&
           verifier.EndTable();
  }
};

struct MassPropertiesBuilder {
  typedef MassProperties Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_centeredInertia(const DeepSeaPhysics::Matrix33f *centeredInertia) {
    fbb_.AddStruct(MassProperties::VT_CENTEREDINERTIA, centeredInertia);
  }
  void add_centerOfMass(const DeepSeaPhysics::Vector3f *centerOfMass) {
    fbb_.AddStruct(MassProperties::VT_CENTEROFMASS, centerOfMass);
  }
  void add_mass(float mass) {
    fbb_.AddElement<float>(MassProperties::VT_MASS, mass, 0.0f);
  }
  void add_inertiaTranslate(const DeepSeaPhysics::Vector3f *inertiaTranslate) {
    fbb_.AddStruct(MassProperties::VT_INERTIATRANSLATE, inertiaTranslate);
  }
  void add_inertiaRotate(const DeepSeaPhysics::Quaternion4f *inertiaRotate) {
    fbb_.AddStruct(MassProperties::VT_INERTIAROTATE, inertiaRotate);
  }
  explicit MassPropertiesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MassProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MassProperties>(end);
    fbb_.Required(o, MassProperties::VT_CENTEREDINERTIA);
    return o;
  }
};

inline ::flatbuffers::Offset<MassProperties> CreateMassProperties(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const DeepSeaPhysics::Matrix33f *centeredInertia = nullptr,
    const DeepSeaPhysics::Vector3f *centerOfMass = nullptr,
    float mass = 0.0f,
    const DeepSeaPhysics::Vector3f *inertiaTranslate = nullptr,
    const DeepSeaPhysics::Quaternion4f *inertiaRotate = nullptr) {
  MassPropertiesBuilder builder_(_fbb);
  builder_.add_inertiaRotate(inertiaRotate);
  builder_.add_inertiaTranslate(inertiaTranslate);
  builder_.add_mass(mass);
  builder_.add_centerOfMass(centerOfMass);
  builder_.add_centeredInertia(centeredInertia);
  return builder_.Finish();
}

inline bool VerifyCustomMassProperties(::flatbuffers::Verifier &verifier, const void *obj, CustomMassProperties type) {
  switch (type) {
    case CustomMassProperties::NONE: {
      return true;
    }
    case CustomMassProperties::ShiftedMass: {
      auto ptr = reinterpret_cast<const DeepSeaPhysics::ShiftedMass *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case CustomMassProperties::MassProperties: {
      auto ptr = reinterpret_cast<const DeepSeaPhysics::MassProperties *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyCustomMassPropertiesVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<CustomMassProperties> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyCustomMassProperties(
        verifier,  values->Get(i), types->GetEnum<CustomMassProperties>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace DeepSeaPhysics

#endif  // FLATBUFFERS_GENERATED_PHYSICSCOMMON_DEEPSEAPHYSICS_H_
