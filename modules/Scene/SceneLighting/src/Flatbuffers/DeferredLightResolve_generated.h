// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DEFERREDLIGHTRESOLVE_DEEPSEASCENELIGHTING_H_
#define FLATBUFFERS_GENERATED_DEFERREDLIGHTRESOLVE_DEEPSEASCENELIGHTING_H_

#include "flatbuffers/flatbuffers.h"

namespace DeepSeaSceneLighting {

struct DeferredLightResolve;
struct DeferredLightResolveBuilder;

struct DeferredLightResolve FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeferredLightResolveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LIGHTSET = 4,
    VT_AMBIENTSHADER = 6,
    VT_AMBIENTMATERIAL = 8,
    VT_DIRECTIONALSHADER = 10,
    VT_DIRECTIONALMATERIAL = 12,
    VT_POINTSHADER = 14,
    VT_POINTMATERIAL = 16,
    VT_SPOTSHADER = 18,
    VT_SPOTMATERIAL = 20,
    VT_INTENSITYTHRESHOLD = 22
  };
  const flatbuffers::String *lightSet() const {
    return GetPointer<const flatbuffers::String *>(VT_LIGHTSET);
  }
  const flatbuffers::String *ambientShader() const {
    return GetPointer<const flatbuffers::String *>(VT_AMBIENTSHADER);
  }
  const flatbuffers::String *ambientMaterial() const {
    return GetPointer<const flatbuffers::String *>(VT_AMBIENTMATERIAL);
  }
  const flatbuffers::String *directionalShader() const {
    return GetPointer<const flatbuffers::String *>(VT_DIRECTIONALSHADER);
  }
  const flatbuffers::String *directionalMaterial() const {
    return GetPointer<const flatbuffers::String *>(VT_DIRECTIONALMATERIAL);
  }
  const flatbuffers::String *pointShader() const {
    return GetPointer<const flatbuffers::String *>(VT_POINTSHADER);
  }
  const flatbuffers::String *pointMaterial() const {
    return GetPointer<const flatbuffers::String *>(VT_POINTMATERIAL);
  }
  const flatbuffers::String *spotShader() const {
    return GetPointer<const flatbuffers::String *>(VT_SPOTSHADER);
  }
  const flatbuffers::String *spotMaterial() const {
    return GetPointer<const flatbuffers::String *>(VT_SPOTMATERIAL);
  }
  float intensityThreshold() const {
    return GetField<float>(VT_INTENSITYTHRESHOLD, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_LIGHTSET) &&
           verifier.VerifyString(lightSet()) &&
           VerifyOffset(verifier, VT_AMBIENTSHADER) &&
           verifier.VerifyString(ambientShader()) &&
           VerifyOffset(verifier, VT_AMBIENTMATERIAL) &&
           verifier.VerifyString(ambientMaterial()) &&
           VerifyOffset(verifier, VT_DIRECTIONALSHADER) &&
           verifier.VerifyString(directionalShader()) &&
           VerifyOffset(verifier, VT_DIRECTIONALMATERIAL) &&
           verifier.VerifyString(directionalMaterial()) &&
           VerifyOffset(verifier, VT_POINTSHADER) &&
           verifier.VerifyString(pointShader()) &&
           VerifyOffset(verifier, VT_POINTMATERIAL) &&
           verifier.VerifyString(pointMaterial()) &&
           VerifyOffset(verifier, VT_SPOTSHADER) &&
           verifier.VerifyString(spotShader()) &&
           VerifyOffset(verifier, VT_SPOTMATERIAL) &&
           verifier.VerifyString(spotMaterial()) &&
           VerifyField<float>(verifier, VT_INTENSITYTHRESHOLD) &&
           verifier.EndTable();
  }
};

struct DeferredLightResolveBuilder {
  typedef DeferredLightResolve Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_lightSet(flatbuffers::Offset<flatbuffers::String> lightSet) {
    fbb_.AddOffset(DeferredLightResolve::VT_LIGHTSET, lightSet);
  }
  void add_ambientShader(flatbuffers::Offset<flatbuffers::String> ambientShader) {
    fbb_.AddOffset(DeferredLightResolve::VT_AMBIENTSHADER, ambientShader);
  }
  void add_ambientMaterial(flatbuffers::Offset<flatbuffers::String> ambientMaterial) {
    fbb_.AddOffset(DeferredLightResolve::VT_AMBIENTMATERIAL, ambientMaterial);
  }
  void add_directionalShader(flatbuffers::Offset<flatbuffers::String> directionalShader) {
    fbb_.AddOffset(DeferredLightResolve::VT_DIRECTIONALSHADER, directionalShader);
  }
  void add_directionalMaterial(flatbuffers::Offset<flatbuffers::String> directionalMaterial) {
    fbb_.AddOffset(DeferredLightResolve::VT_DIRECTIONALMATERIAL, directionalMaterial);
  }
  void add_pointShader(flatbuffers::Offset<flatbuffers::String> pointShader) {
    fbb_.AddOffset(DeferredLightResolve::VT_POINTSHADER, pointShader);
  }
  void add_pointMaterial(flatbuffers::Offset<flatbuffers::String> pointMaterial) {
    fbb_.AddOffset(DeferredLightResolve::VT_POINTMATERIAL, pointMaterial);
  }
  void add_spotShader(flatbuffers::Offset<flatbuffers::String> spotShader) {
    fbb_.AddOffset(DeferredLightResolve::VT_SPOTSHADER, spotShader);
  }
  void add_spotMaterial(flatbuffers::Offset<flatbuffers::String> spotMaterial) {
    fbb_.AddOffset(DeferredLightResolve::VT_SPOTMATERIAL, spotMaterial);
  }
  void add_intensityThreshold(float intensityThreshold) {
    fbb_.AddElement<float>(DeferredLightResolve::VT_INTENSITYTHRESHOLD, intensityThreshold, 0.0f);
  }
  explicit DeferredLightResolveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeferredLightResolveBuilder &operator=(const DeferredLightResolveBuilder &);
  flatbuffers::Offset<DeferredLightResolve> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeferredLightResolve>(end);
    fbb_.Required(o, DeferredLightResolve::VT_LIGHTSET);
    return o;
  }
};

inline flatbuffers::Offset<DeferredLightResolve> CreateDeferredLightResolve(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> lightSet = 0,
    flatbuffers::Offset<flatbuffers::String> ambientShader = 0,
    flatbuffers::Offset<flatbuffers::String> ambientMaterial = 0,
    flatbuffers::Offset<flatbuffers::String> directionalShader = 0,
    flatbuffers::Offset<flatbuffers::String> directionalMaterial = 0,
    flatbuffers::Offset<flatbuffers::String> pointShader = 0,
    flatbuffers::Offset<flatbuffers::String> pointMaterial = 0,
    flatbuffers::Offset<flatbuffers::String> spotShader = 0,
    flatbuffers::Offset<flatbuffers::String> spotMaterial = 0,
    float intensityThreshold = 0.0f) {
  DeferredLightResolveBuilder builder_(_fbb);
  builder_.add_intensityThreshold(intensityThreshold);
  builder_.add_spotMaterial(spotMaterial);
  builder_.add_spotShader(spotShader);
  builder_.add_pointMaterial(pointMaterial);
  builder_.add_pointShader(pointShader);
  builder_.add_directionalMaterial(directionalMaterial);
  builder_.add_directionalShader(directionalShader);
  builder_.add_ambientMaterial(ambientMaterial);
  builder_.add_ambientShader(ambientShader);
  builder_.add_lightSet(lightSet);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeferredLightResolve> CreateDeferredLightResolveDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *lightSet = nullptr,
    const char *ambientShader = nullptr,
    const char *ambientMaterial = nullptr,
    const char *directionalShader = nullptr,
    const char *directionalMaterial = nullptr,
    const char *pointShader = nullptr,
    const char *pointMaterial = nullptr,
    const char *spotShader = nullptr,
    const char *spotMaterial = nullptr,
    float intensityThreshold = 0.0f) {
  auto lightSet__ = lightSet ? _fbb.CreateString(lightSet) : 0;
  auto ambientShader__ = ambientShader ? _fbb.CreateString(ambientShader) : 0;
  auto ambientMaterial__ = ambientMaterial ? _fbb.CreateString(ambientMaterial) : 0;
  auto directionalShader__ = directionalShader ? _fbb.CreateString(directionalShader) : 0;
  auto directionalMaterial__ = directionalMaterial ? _fbb.CreateString(directionalMaterial) : 0;
  auto pointShader__ = pointShader ? _fbb.CreateString(pointShader) : 0;
  auto pointMaterial__ = pointMaterial ? _fbb.CreateString(pointMaterial) : 0;
  auto spotShader__ = spotShader ? _fbb.CreateString(spotShader) : 0;
  auto spotMaterial__ = spotMaterial ? _fbb.CreateString(spotMaterial) : 0;
  return DeepSeaSceneLighting::CreateDeferredLightResolve(
      _fbb,
      lightSet__,
      ambientShader__,
      ambientMaterial__,
      directionalShader__,
      directionalMaterial__,
      pointShader__,
      pointMaterial__,
      spotShader__,
      spotMaterial__,
      intensityThreshold);
}

inline const DeepSeaSceneLighting::DeferredLightResolve *GetDeferredLightResolve(const void *buf) {
  return flatbuffers::GetRoot<DeepSeaSceneLighting::DeferredLightResolve>(buf);
}

inline const DeepSeaSceneLighting::DeferredLightResolve *GetSizePrefixedDeferredLightResolve(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<DeepSeaSceneLighting::DeferredLightResolve>(buf);
}

inline bool VerifyDeferredLightResolveBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DeepSeaSceneLighting::DeferredLightResolve>(nullptr);
}

inline bool VerifySizePrefixedDeferredLightResolveBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DeepSeaSceneLighting::DeferredLightResolve>(nullptr);
}

inline void FinishDeferredLightResolveBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DeepSeaSceneLighting::DeferredLightResolve> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDeferredLightResolveBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DeepSeaSceneLighting::DeferredLightResolve> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace DeepSeaSceneLighting

#endif  // FLATBUFFERS_GENERATED_DEFERREDLIGHTRESOLVE_DEEPSEASCENELIGHTING_H_
