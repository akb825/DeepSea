// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCENERESOURCES_DEEPSEASCENE_H_
#define FLATBUFFERS_GENERATED_SCENERESOURCES_DEEPSEASCENE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 7,
             "Non-compatible flatbuffers version included");

#include "DeepSea/Scene/Flatbuffers/SceneCommon_generated.h"

namespace DeepSeaScene {

struct Buffer;
struct BufferBuilder;

struct TextureInfo;
struct TextureInfoBuilder;

struct Texture;
struct TextureBuilder;

struct VariableElement;
struct VariableElementBuilder;

struct ShaderVariableGroupDesc;
struct ShaderVariableGroupDescBuilder;

struct VariableData;
struct VariableDataBuilder;

struct ShaderVariableGroup;
struct ShaderVariableGroupBuilder;

struct MaterialElement;
struct MaterialElementBuilder;

struct MaterialDesc;
struct MaterialDescBuilder;

struct Material;
struct MaterialBuilder;

struct ShaderModule;
struct ShaderModuleBuilder;

struct Shader;
struct ShaderBuilder;

struct VertexAttribute;

struct VertexFormat;
struct VertexFormatBuilder;

struct VertexBuffer;
struct VertexBufferBuilder;

struct IndexBuffer;
struct IndexBufferBuilder;

struct DrawGeometry;
struct DrawGeometryBuilder;

struct SceneNode;
struct SceneNodeBuilder;

struct CustomResource;
struct CustomResourceBuilder;

struct SceneResource;
struct SceneResourceBuilder;

struct SceneResources;
struct SceneResourcesBuilder;

enum class SceneResourceUnion : uint8_t {
  NONE = 0,
  Buffer = 1,
  Texture = 2,
  ShaderVariableGroupDesc = 3,
  ShaderVariableGroup = 4,
  MaterialDesc = 5,
  Material = 6,
  ShaderModule = 7,
  Shader = 8,
  DrawGeometry = 9,
  SceneNode = 10,
  CustomResource = 11,
  ResourceAction = 12,
  MIN = NONE,
  MAX = ResourceAction
};

inline const SceneResourceUnion (&EnumValuesSceneResourceUnion())[13] {
  static const SceneResourceUnion values[] = {
    SceneResourceUnion::NONE,
    SceneResourceUnion::Buffer,
    SceneResourceUnion::Texture,
    SceneResourceUnion::ShaderVariableGroupDesc,
    SceneResourceUnion::ShaderVariableGroup,
    SceneResourceUnion::MaterialDesc,
    SceneResourceUnion::Material,
    SceneResourceUnion::ShaderModule,
    SceneResourceUnion::Shader,
    SceneResourceUnion::DrawGeometry,
    SceneResourceUnion::SceneNode,
    SceneResourceUnion::CustomResource,
    SceneResourceUnion::ResourceAction
  };
  return values;
}

inline const char * const *EnumNamesSceneResourceUnion() {
  static const char * const names[14] = {
    "NONE",
    "Buffer",
    "Texture",
    "ShaderVariableGroupDesc",
    "ShaderVariableGroup",
    "MaterialDesc",
    "Material",
    "ShaderModule",
    "Shader",
    "DrawGeometry",
    "SceneNode",
    "CustomResource",
    "ResourceAction",
    nullptr
  };
  return names;
}

inline const char *EnumNameSceneResourceUnion(SceneResourceUnion e) {
  if (::flatbuffers::IsOutRange(e, SceneResourceUnion::NONE, SceneResourceUnion::ResourceAction)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSceneResourceUnion()[index];
}

template<typename T> struct SceneResourceUnionTraits {
  static const SceneResourceUnion enum_value = SceneResourceUnion::NONE;
};

template<> struct SceneResourceUnionTraits<DeepSeaScene::Buffer> {
  static const SceneResourceUnion enum_value = SceneResourceUnion::Buffer;
};

template<> struct SceneResourceUnionTraits<DeepSeaScene::Texture> {
  static const SceneResourceUnion enum_value = SceneResourceUnion::Texture;
};

template<> struct SceneResourceUnionTraits<DeepSeaScene::ShaderVariableGroupDesc> {
  static const SceneResourceUnion enum_value = SceneResourceUnion::ShaderVariableGroupDesc;
};

template<> struct SceneResourceUnionTraits<DeepSeaScene::ShaderVariableGroup> {
  static const SceneResourceUnion enum_value = SceneResourceUnion::ShaderVariableGroup;
};

template<> struct SceneResourceUnionTraits<DeepSeaScene::MaterialDesc> {
  static const SceneResourceUnion enum_value = SceneResourceUnion::MaterialDesc;
};

template<> struct SceneResourceUnionTraits<DeepSeaScene::Material> {
  static const SceneResourceUnion enum_value = SceneResourceUnion::Material;
};

template<> struct SceneResourceUnionTraits<DeepSeaScene::ShaderModule> {
  static const SceneResourceUnion enum_value = SceneResourceUnion::ShaderModule;
};

template<> struct SceneResourceUnionTraits<DeepSeaScene::Shader> {
  static const SceneResourceUnion enum_value = SceneResourceUnion::Shader;
};

template<> struct SceneResourceUnionTraits<DeepSeaScene::DrawGeometry> {
  static const SceneResourceUnion enum_value = SceneResourceUnion::DrawGeometry;
};

template<> struct SceneResourceUnionTraits<DeepSeaScene::SceneNode> {
  static const SceneResourceUnion enum_value = SceneResourceUnion::SceneNode;
};

template<> struct SceneResourceUnionTraits<DeepSeaScene::CustomResource> {
  static const SceneResourceUnion enum_value = SceneResourceUnion::CustomResource;
};

template<> struct SceneResourceUnionTraits<DeepSeaScene::ObjectData> {
  static const SceneResourceUnion enum_value = SceneResourceUnion::ResourceAction;
};

bool VerifySceneResourceUnion(::flatbuffers::Verifier &verifier, const void *obj, SceneResourceUnion type);
bool VerifySceneResourceUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<SceneResourceUnion> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) VertexAttribute FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t attrib_;
  uint8_t format_;
  uint8_t decoration_;
  int16_t padding0__;

 public:
  VertexAttribute()
      : attrib_(0),
        format_(0),
        decoration_(0),
        padding0__(0) {
    (void)padding0__;
  }
  VertexAttribute(uint32_t _attrib, DeepSeaScene::VertexElementFormat _format, DeepSeaScene::FormatDecoration _decoration)
      : attrib_(::flatbuffers::EndianScalar(_attrib)),
        format_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_format))),
        decoration_(::flatbuffers::EndianScalar(static_cast<uint8_t>(_decoration))),
        padding0__(0) {
    (void)padding0__;
  }
  uint32_t attrib() const {
    return ::flatbuffers::EndianScalar(attrib_);
  }
  DeepSeaScene::VertexElementFormat format() const {
    return static_cast<DeepSeaScene::VertexElementFormat>(::flatbuffers::EndianScalar(format_));
  }
  DeepSeaScene::FormatDecoration decoration() const {
    return static_cast<DeepSeaScene::FormatDecoration>(::flatbuffers::EndianScalar(decoration_));
  }
};
FLATBUFFERS_STRUCT_END(VertexAttribute, 8);

struct Buffer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_USAGE = 6,
    VT_MEMORYHINTS = 8,
    VT_SIZE = 10,
    VT_DATA_TYPE = 12,
    VT_DATA = 14
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t usage() const {
    return GetField<uint32_t>(VT_USAGE, 0);
  }
  uint32_t memoryHints() const {
    return GetField<uint32_t>(VT_MEMORYHINTS, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  DeepSeaScene::FileOrData data_type() const {
    return static_cast<DeepSeaScene::FileOrData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const DeepSeaScene::FileReference *data_as_FileReference() const {
    return data_type() == DeepSeaScene::FileOrData::FileReference ? static_cast<const DeepSeaScene::FileReference *>(data()) : nullptr;
  }
  const DeepSeaScene::RawData *data_as_RawData() const {
    return data_type() == DeepSeaScene::FileOrData::RawData ? static_cast<const DeepSeaScene::RawData *>(data()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_USAGE, 4) &&
           VerifyField<uint32_t>(verifier, VT_MEMORYHINTS, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyFileOrData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const DeepSeaScene::FileReference *Buffer::data_as<DeepSeaScene::FileReference>() const {
  return data_as_FileReference();
}

template<> inline const DeepSeaScene::RawData *Buffer::data_as<DeepSeaScene::RawData>() const {
  return data_as_RawData();
}

struct BufferBuilder {
  typedef Buffer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Buffer::VT_NAME, name);
  }
  void add_usage(uint32_t usage) {
    fbb_.AddElement<uint32_t>(Buffer::VT_USAGE, usage, 0);
  }
  void add_memoryHints(uint32_t memoryHints) {
    fbb_.AddElement<uint32_t>(Buffer::VT_MEMORYHINTS, memoryHints, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(Buffer::VT_SIZE, size, 0);
  }
  void add_data_type(DeepSeaScene::FileOrData data_type) {
    fbb_.AddElement<uint8_t>(Buffer::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Buffer::VT_DATA, data);
  }
  explicit BufferBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Buffer>(end);
    fbb_.Required(o, Buffer::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<Buffer> CreateBuffer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint32_t usage = 0,
    uint32_t memoryHints = 0,
    uint32_t size = 0,
    DeepSeaScene::FileOrData data_type = DeepSeaScene::FileOrData::NONE,
    ::flatbuffers::Offset<void> data = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_size(size);
  builder_.add_memoryHints(memoryHints);
  builder_.add_usage(usage);
  builder_.add_name(name);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Buffer> CreateBufferDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t usage = 0,
    uint32_t memoryHints = 0,
    uint32_t size = 0,
    DeepSeaScene::FileOrData data_type = DeepSeaScene::FileOrData::NONE,
    ::flatbuffers::Offset<void> data = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return DeepSeaScene::CreateBuffer(
      _fbb,
      name__,
      usage,
      memoryHints,
      size,
      data_type,
      data);
}

struct TextureInfo FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextureInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_DECORATION = 6,
    VT_DIMENSION = 8,
    VT_WIDTH = 10,
    VT_HEIGHT = 12,
    VT_DEPTH = 14,
    VT_MIPLEVELS = 16
  };
  DeepSeaScene::TextureFormat format() const {
    return static_cast<DeepSeaScene::TextureFormat>(GetField<uint8_t>(VT_FORMAT, 0));
  }
  DeepSeaScene::FormatDecoration decoration() const {
    return static_cast<DeepSeaScene::FormatDecoration>(GetField<uint8_t>(VT_DECORATION, 0));
  }
  DeepSeaScene::TextureDim dimension() const {
    return static_cast<DeepSeaScene::TextureDim>(GetField<uint8_t>(VT_DIMENSION, 0));
  }
  uint32_t width() const {
    return GetField<uint32_t>(VT_WIDTH, 0);
  }
  uint32_t height() const {
    return GetField<uint32_t>(VT_HEIGHT, 0);
  }
  uint32_t depth() const {
    return GetField<uint32_t>(VT_DEPTH, 0);
  }
  uint8_t mipLevels() const {
    return GetField<uint8_t>(VT_MIPLEVELS, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_FORMAT, 1) &&
           VerifyField<uint8_t>(verifier, VT_DECORATION, 1) &&
           VerifyField<uint8_t>(verifier, VT_DIMENSION, 1) &&
           VerifyField<uint32_t>(verifier, VT_WIDTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_HEIGHT, 4) &&
           VerifyField<uint32_t>(verifier, VT_DEPTH, 4) &&
           VerifyField<uint8_t>(verifier, VT_MIPLEVELS, 1) &&
           verifier.EndTable();
  }
};

struct TextureInfoBuilder {
  typedef TextureInfo Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_format(DeepSeaScene::TextureFormat format) {
    fbb_.AddElement<uint8_t>(TextureInfo::VT_FORMAT, static_cast<uint8_t>(format), 0);
  }
  void add_decoration(DeepSeaScene::FormatDecoration decoration) {
    fbb_.AddElement<uint8_t>(TextureInfo::VT_DECORATION, static_cast<uint8_t>(decoration), 0);
  }
  void add_dimension(DeepSeaScene::TextureDim dimension) {
    fbb_.AddElement<uint8_t>(TextureInfo::VT_DIMENSION, static_cast<uint8_t>(dimension), 0);
  }
  void add_width(uint32_t width) {
    fbb_.AddElement<uint32_t>(TextureInfo::VT_WIDTH, width, 0);
  }
  void add_height(uint32_t height) {
    fbb_.AddElement<uint32_t>(TextureInfo::VT_HEIGHT, height, 0);
  }
  void add_depth(uint32_t depth) {
    fbb_.AddElement<uint32_t>(TextureInfo::VT_DEPTH, depth, 0);
  }
  void add_mipLevels(uint8_t mipLevels) {
    fbb_.AddElement<uint8_t>(TextureInfo::VT_MIPLEVELS, mipLevels, 0);
  }
  explicit TextureInfoBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TextureInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TextureInfo>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<TextureInfo> CreateTextureInfo(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    DeepSeaScene::TextureFormat format = DeepSeaScene::TextureFormat::R4G4,
    DeepSeaScene::FormatDecoration decoration = DeepSeaScene::FormatDecoration::UNorm,
    DeepSeaScene::TextureDim dimension = DeepSeaScene::TextureDim::Dim1D,
    uint32_t width = 0,
    uint32_t height = 0,
    uint32_t depth = 0,
    uint8_t mipLevels = 0) {
  TextureInfoBuilder builder_(_fbb);
  builder_.add_depth(depth);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_mipLevels(mipLevels);
  builder_.add_dimension(dimension);
  builder_.add_decoration(decoration);
  builder_.add_format(format);
  return builder_.Finish();
}

struct Texture FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_USAGE = 6,
    VT_MEMORYHINTS = 8,
    VT_DATA_TYPE = 10,
    VT_DATA = 12,
    VT_TEXTUREINFO = 14
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t usage() const {
    return GetField<uint32_t>(VT_USAGE, 0);
  }
  uint32_t memoryHints() const {
    return GetField<uint32_t>(VT_MEMORYHINTS, 0);
  }
  DeepSeaScene::FileOrData data_type() const {
    return static_cast<DeepSeaScene::FileOrData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const DeepSeaScene::FileReference *data_as_FileReference() const {
    return data_type() == DeepSeaScene::FileOrData::FileReference ? static_cast<const DeepSeaScene::FileReference *>(data()) : nullptr;
  }
  const DeepSeaScene::RawData *data_as_RawData() const {
    return data_type() == DeepSeaScene::FileOrData::RawData ? static_cast<const DeepSeaScene::RawData *>(data()) : nullptr;
  }
  const DeepSeaScene::TextureInfo *textureInfo() const {
    return GetPointer<const DeepSeaScene::TextureInfo *>(VT_TEXTUREINFO);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_USAGE, 4) &&
           VerifyField<uint32_t>(verifier, VT_MEMORYHINTS, 4) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffset(verifier, VT_DATA) &&
           VerifyFileOrData(verifier, data(), data_type()) &&
           VerifyOffset(verifier, VT_TEXTUREINFO) &&
           verifier.VerifyTable(textureInfo()) &&
           verifier.EndTable();
  }
};

template<> inline const DeepSeaScene::FileReference *Texture::data_as<DeepSeaScene::FileReference>() const {
  return data_as_FileReference();
}

template<> inline const DeepSeaScene::RawData *Texture::data_as<DeepSeaScene::RawData>() const {
  return data_as_RawData();
}

struct TextureBuilder {
  typedef Texture Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Texture::VT_NAME, name);
  }
  void add_usage(uint32_t usage) {
    fbb_.AddElement<uint32_t>(Texture::VT_USAGE, usage, 0);
  }
  void add_memoryHints(uint32_t memoryHints) {
    fbb_.AddElement<uint32_t>(Texture::VT_MEMORYHINTS, memoryHints, 0);
  }
  void add_data_type(DeepSeaScene::FileOrData data_type) {
    fbb_.AddElement<uint8_t>(Texture::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(Texture::VT_DATA, data);
  }
  void add_textureInfo(::flatbuffers::Offset<DeepSeaScene::TextureInfo> textureInfo) {
    fbb_.AddOffset(Texture::VT_TEXTUREINFO, textureInfo);
  }
  explicit TextureBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Texture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Texture>(end);
    fbb_.Required(o, Texture::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<Texture> CreateTexture(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint32_t usage = 0,
    uint32_t memoryHints = 0,
    DeepSeaScene::FileOrData data_type = DeepSeaScene::FileOrData::NONE,
    ::flatbuffers::Offset<void> data = 0,
    ::flatbuffers::Offset<DeepSeaScene::TextureInfo> textureInfo = 0) {
  TextureBuilder builder_(_fbb);
  builder_.add_textureInfo(textureInfo);
  builder_.add_data(data);
  builder_.add_memoryHints(memoryHints);
  builder_.add_usage(usage);
  builder_.add_name(name);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Texture> CreateTextureDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t usage = 0,
    uint32_t memoryHints = 0,
    DeepSeaScene::FileOrData data_type = DeepSeaScene::FileOrData::NONE,
    ::flatbuffers::Offset<void> data = 0,
    ::flatbuffers::Offset<DeepSeaScene::TextureInfo> textureInfo = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return DeepSeaScene::CreateTexture(
      _fbb,
      name__,
      usage,
      memoryHints,
      data_type,
      data,
      textureInfo);
}

struct VariableElement FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VariableElementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_COUNT = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  DeepSeaScene::MaterialType type() const {
    return static_cast<DeepSeaScene::MaterialType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_COUNT, 4) &&
           verifier.EndTable();
  }
};

struct VariableElementBuilder {
  typedef VariableElement Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(VariableElement::VT_NAME, name);
  }
  void add_type(DeepSeaScene::MaterialType type) {
    fbb_.AddElement<uint8_t>(VariableElement::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(VariableElement::VT_COUNT, count, 0);
  }
  explicit VariableElementBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VariableElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VariableElement>(end);
    fbb_.Required(o, VariableElement::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<VariableElement> CreateVariableElement(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    DeepSeaScene::MaterialType type = DeepSeaScene::MaterialType::Float,
    uint32_t count = 0) {
  VariableElementBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VariableElement> CreateVariableElementDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    DeepSeaScene::MaterialType type = DeepSeaScene::MaterialType::Float,
    uint32_t count = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return DeepSeaScene::CreateVariableElement(
      _fbb,
      name__,
      type,
      count);
}

struct ShaderVariableGroupDesc FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShaderVariableGroupDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ELEMENTS = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VariableElement>> *elements() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VariableElement>> *>(VT_ELEMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(elements()) &&
           verifier.VerifyVectorOfTables(elements()) &&
           verifier.EndTable();
  }
};

struct ShaderVariableGroupDescBuilder {
  typedef ShaderVariableGroupDesc Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ShaderVariableGroupDesc::VT_NAME, name);
  }
  void add_elements(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VariableElement>>> elements) {
    fbb_.AddOffset(ShaderVariableGroupDesc::VT_ELEMENTS, elements);
  }
  explicit ShaderVariableGroupDescBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShaderVariableGroupDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShaderVariableGroupDesc>(end);
    fbb_.Required(o, ShaderVariableGroupDesc::VT_NAME);
    fbb_.Required(o, ShaderVariableGroupDesc::VT_ELEMENTS);
    return o;
  }
};

inline ::flatbuffers::Offset<ShaderVariableGroupDesc> CreateShaderVariableGroupDesc(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VariableElement>>> elements = 0) {
  ShaderVariableGroupDescBuilder builder_(_fbb);
  builder_.add_elements(elements);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ShaderVariableGroupDesc> CreateShaderVariableGroupDescDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<DeepSeaScene::VariableElement>> *elements = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto elements__ = elements ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaScene::VariableElement>>(*elements) : 0;
  return DeepSeaScene::CreateShaderVariableGroupDesc(
      _fbb,
      name__,
      elements__);
}

struct VariableData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VariableDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_FIRST = 8,
    VT_COUNT = 10,
    VT_DATA = 12
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  DeepSeaScene::MaterialType type() const {
    return static_cast<DeepSeaScene::MaterialType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  uint32_t first() const {
    return GetField<uint32_t>(VT_FIRST, 0);
  }
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_FIRST, 4) &&
           VerifyField<uint32_t>(verifier, VT_COUNT, 4) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct VariableDataBuilder {
  typedef VariableData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(VariableData::VT_NAME, name);
  }
  void add_type(DeepSeaScene::MaterialType type) {
    fbb_.AddElement<uint8_t>(VariableData::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_first(uint32_t first) {
    fbb_.AddElement<uint32_t>(VariableData::VT_FIRST, first, 0);
  }
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(VariableData::VT_COUNT, count, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(VariableData::VT_DATA, data);
  }
  explicit VariableDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VariableData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VariableData>(end);
    fbb_.Required(o, VariableData::VT_NAME);
    fbb_.Required(o, VariableData::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<VariableData> CreateVariableData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    DeepSeaScene::MaterialType type = DeepSeaScene::MaterialType::Float,
    uint32_t first = 0,
    uint32_t count = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  VariableDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_count(count);
  builder_.add_first(first);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VariableData> CreateVariableDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    DeepSeaScene::MaterialType type = DeepSeaScene::MaterialType::Float,
    uint32_t first = 0,
    uint32_t count = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return DeepSeaScene::CreateVariableData(
      _fbb,
      name__,
      type,
      first,
      count,
      data__);
}

struct ShaderVariableGroup FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShaderVariableGroupBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_DATA = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VariableData>> *data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VariableData>> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct ShaderVariableGroupBuilder {
  typedef ShaderVariableGroup Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ShaderVariableGroup::VT_NAME, name);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(ShaderVariableGroup::VT_DESCRIPTION, description);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VariableData>>> data) {
    fbb_.AddOffset(ShaderVariableGroup::VT_DATA, data);
  }
  explicit ShaderVariableGroupBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShaderVariableGroup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShaderVariableGroup>(end);
    fbb_.Required(o, ShaderVariableGroup::VT_NAME);
    fbb_.Required(o, ShaderVariableGroup::VT_DESCRIPTION);
    return o;
  }
};

inline ::flatbuffers::Offset<ShaderVariableGroup> CreateShaderVariableGroup(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VariableData>>> data = 0) {
  ShaderVariableGroupBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_description(description);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ShaderVariableGroup> CreateShaderVariableGroupDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *description = nullptr,
    const std::vector<::flatbuffers::Offset<DeepSeaScene::VariableData>> *data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto data__ = data ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaScene::VariableData>>(*data) : 0;
  return DeepSeaScene::CreateShaderVariableGroup(
      _fbb,
      name__,
      description__,
      data__);
}

struct MaterialElement FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaterialElementBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_TYPE = 6,
    VT_COUNT = 8,
    VT_BINDING = 10,
    VT_SHADERVARIABLEGROUPDESC = 12
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  DeepSeaScene::MaterialType type() const {
    return static_cast<DeepSeaScene::MaterialType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  DeepSeaScene::MaterialBinding binding() const {
    return static_cast<DeepSeaScene::MaterialBinding>(GetField<uint8_t>(VT_BINDING, 0));
  }
  const ::flatbuffers::String *shaderVariableGroupDesc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHADERVARIABLEGROUPDESC);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_COUNT, 4) &&
           VerifyField<uint8_t>(verifier, VT_BINDING, 1) &&
           VerifyOffset(verifier, VT_SHADERVARIABLEGROUPDESC) &&
           verifier.VerifyString(shaderVariableGroupDesc()) &&
           verifier.EndTable();
  }
};

struct MaterialElementBuilder {
  typedef MaterialElement Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(MaterialElement::VT_NAME, name);
  }
  void add_type(DeepSeaScene::MaterialType type) {
    fbb_.AddElement<uint8_t>(MaterialElement::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(MaterialElement::VT_COUNT, count, 0);
  }
  void add_binding(DeepSeaScene::MaterialBinding binding) {
    fbb_.AddElement<uint8_t>(MaterialElement::VT_BINDING, static_cast<uint8_t>(binding), 0);
  }
  void add_shaderVariableGroupDesc(::flatbuffers::Offset<::flatbuffers::String> shaderVariableGroupDesc) {
    fbb_.AddOffset(MaterialElement::VT_SHADERVARIABLEGROUPDESC, shaderVariableGroupDesc);
  }
  explicit MaterialElementBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MaterialElement> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MaterialElement>(end);
    fbb_.Required(o, MaterialElement::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<MaterialElement> CreateMaterialElement(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    DeepSeaScene::MaterialType type = DeepSeaScene::MaterialType::Float,
    uint32_t count = 0,
    DeepSeaScene::MaterialBinding binding = DeepSeaScene::MaterialBinding::Material,
    ::flatbuffers::Offset<::flatbuffers::String> shaderVariableGroupDesc = 0) {
  MaterialElementBuilder builder_(_fbb);
  builder_.add_shaderVariableGroupDesc(shaderVariableGroupDesc);
  builder_.add_count(count);
  builder_.add_name(name);
  builder_.add_binding(binding);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MaterialElement> CreateMaterialElementDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    DeepSeaScene::MaterialType type = DeepSeaScene::MaterialType::Float,
    uint32_t count = 0,
    DeepSeaScene::MaterialBinding binding = DeepSeaScene::MaterialBinding::Material,
    const char *shaderVariableGroupDesc = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto shaderVariableGroupDesc__ = shaderVariableGroupDesc ? _fbb.CreateString(shaderVariableGroupDesc) : 0;
  return DeepSeaScene::CreateMaterialElement(
      _fbb,
      name__,
      type,
      count,
      binding,
      shaderVariableGroupDesc__);
}

struct MaterialDesc FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaterialDescBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ELEMENTS = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::MaterialElement>> *elements() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::MaterialElement>> *>(VT_ELEMENTS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_ELEMENTS) &&
           verifier.VerifyVector(elements()) &&
           verifier.VerifyVectorOfTables(elements()) &&
           verifier.EndTable();
  }
};

struct MaterialDescBuilder {
  typedef MaterialDesc Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(MaterialDesc::VT_NAME, name);
  }
  void add_elements(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::MaterialElement>>> elements) {
    fbb_.AddOffset(MaterialDesc::VT_ELEMENTS, elements);
  }
  explicit MaterialDescBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MaterialDesc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MaterialDesc>(end);
    fbb_.Required(o, MaterialDesc::VT_NAME);
    fbb_.Required(o, MaterialDesc::VT_ELEMENTS);
    return o;
  }
};

inline ::flatbuffers::Offset<MaterialDesc> CreateMaterialDesc(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::MaterialElement>>> elements = 0) {
  MaterialDescBuilder builder_(_fbb);
  builder_.add_elements(elements);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<MaterialDesc> CreateMaterialDescDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<DeepSeaScene::MaterialElement>> *elements = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto elements__ = elements ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaScene::MaterialElement>>(*elements) : 0;
  return DeepSeaScene::CreateMaterialDesc(
      _fbb,
      name__,
      elements__);
}

struct Material FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MaterialBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_DATA = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *description() const {
    return GetPointer<const ::flatbuffers::String *>(VT_DESCRIPTION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VariableData>> *data() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VariableData>> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct MaterialBuilder {
  typedef Material Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Material::VT_NAME, name);
  }
  void add_description(::flatbuffers::Offset<::flatbuffers::String> description) {
    fbb_.AddOffset(Material::VT_DESCRIPTION, description);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VariableData>>> data) {
    fbb_.AddOffset(Material::VT_DATA, data);
  }
  explicit MaterialBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Material> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Material>(end);
    fbb_.Required(o, Material::VT_NAME);
    fbb_.Required(o, Material::VT_DESCRIPTION);
    return o;
  }
};

inline ::flatbuffers::Offset<Material> CreateMaterial(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> description = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VariableData>>> data = 0) {
  MaterialBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_description(description);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Material> CreateMaterialDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *description = nullptr,
    const std::vector<::flatbuffers::Offset<DeepSeaScene::VariableData>> *data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto data__ = data ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaScene::VariableData>>(*data) : 0;
  return DeepSeaScene::CreateMaterial(
      _fbb,
      name__,
      description__,
      data__);
}

struct ShaderModule FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShaderModuleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_MODULES = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VersionedShaderModule>> *modules() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VersionedShaderModule>> *>(VT_MODULES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_MODULES) &&
           verifier.VerifyVector(modules()) &&
           verifier.VerifyVectorOfTables(modules()) &&
           verifier.EndTable();
  }
};

struct ShaderModuleBuilder {
  typedef ShaderModule Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ShaderModule::VT_NAME, name);
  }
  void add_modules(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VersionedShaderModule>>> modules) {
    fbb_.AddOffset(ShaderModule::VT_MODULES, modules);
  }
  explicit ShaderModuleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ShaderModule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ShaderModule>(end);
    fbb_.Required(o, ShaderModule::VT_NAME);
    fbb_.Required(o, ShaderModule::VT_MODULES);
    return o;
  }
};

inline ::flatbuffers::Offset<ShaderModule> CreateShaderModule(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VersionedShaderModule>>> modules = 0) {
  ShaderModuleBuilder builder_(_fbb);
  builder_.add_modules(modules);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ShaderModule> CreateShaderModuleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<DeepSeaScene::VersionedShaderModule>> *modules = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto modules__ = modules ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaScene::VersionedShaderModule>>(*modules) : 0;
  return DeepSeaScene::CreateShaderModule(
      _fbb,
      name__,
      modules__);
}

struct Shader FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ShaderBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHADERMODULE = 6,
    VT_PIPELINE = 8,
    VT_MATERIALDESC = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *shaderModule() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SHADERMODULE);
  }
  const ::flatbuffers::String *pipeline() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PIPELINE);
  }
  const ::flatbuffers::String *materialDesc() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MATERIALDESC);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_SHADERMODULE) &&
           verifier.VerifyString(shaderModule()) &&
           VerifyOffset(verifier, VT_PIPELINE) &&
           verifier.VerifyString(pipeline()) &&
           VerifyOffsetRequired(verifier, VT_MATERIALDESC) &&
           verifier.VerifyString(materialDesc()) &&
           verifier.EndTable();
  }
};

struct ShaderBuilder {
  typedef Shader Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Shader::VT_NAME, name);
  }
  void add_shaderModule(::flatbuffers::Offset<::flatbuffers::String> shaderModule) {
    fbb_.AddOffset(Shader::VT_SHADERMODULE, shaderModule);
  }
  void add_pipeline(::flatbuffers::Offset<::flatbuffers::String> pipeline) {
    fbb_.AddOffset(Shader::VT_PIPELINE, pipeline);
  }
  void add_materialDesc(::flatbuffers::Offset<::flatbuffers::String> materialDesc) {
    fbb_.AddOffset(Shader::VT_MATERIALDESC, materialDesc);
  }
  explicit ShaderBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Shader> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Shader>(end);
    fbb_.Required(o, Shader::VT_NAME);
    fbb_.Required(o, Shader::VT_SHADERMODULE);
    fbb_.Required(o, Shader::VT_MATERIALDESC);
    return o;
  }
};

inline ::flatbuffers::Offset<Shader> CreateShader(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> shaderModule = 0,
    ::flatbuffers::Offset<::flatbuffers::String> pipeline = 0,
    ::flatbuffers::Offset<::flatbuffers::String> materialDesc = 0) {
  ShaderBuilder builder_(_fbb);
  builder_.add_materialDesc(materialDesc);
  builder_.add_pipeline(pipeline);
  builder_.add_shaderModule(shaderModule);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Shader> CreateShaderDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *shaderModule = nullptr,
    const char *pipeline = nullptr,
    const char *materialDesc = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto shaderModule__ = shaderModule ? _fbb.CreateString(shaderModule) : 0;
  auto pipeline__ = pipeline ? _fbb.CreateString(pipeline) : 0;
  auto materialDesc__ = materialDesc ? _fbb.CreateString(materialDesc) : 0;
  return DeepSeaScene::CreateShader(
      _fbb,
      name__,
      shaderModule__,
      pipeline__,
      materialDesc__);
}

struct VertexFormat FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VertexFormatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ATTRIBUTES = 4,
    VT_INSTANCED = 6
  };
  const ::flatbuffers::Vector<const DeepSeaScene::VertexAttribute *> *attributes() const {
    return GetPointer<const ::flatbuffers::Vector<const DeepSeaScene::VertexAttribute *> *>(VT_ATTRIBUTES);
  }
  bool instanced() const {
    return GetField<uint8_t>(VT_INSTANCED, 0) != 0;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ATTRIBUTES) &&
           verifier.VerifyVector(attributes()) &&
           VerifyField<uint8_t>(verifier, VT_INSTANCED, 1) &&
           verifier.EndTable();
  }
};

struct VertexFormatBuilder {
  typedef VertexFormat Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_attributes(::flatbuffers::Offset<::flatbuffers::Vector<const DeepSeaScene::VertexAttribute *>> attributes) {
    fbb_.AddOffset(VertexFormat::VT_ATTRIBUTES, attributes);
  }
  void add_instanced(bool instanced) {
    fbb_.AddElement<uint8_t>(VertexFormat::VT_INSTANCED, static_cast<uint8_t>(instanced), 0);
  }
  explicit VertexFormatBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VertexFormat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VertexFormat>(end);
    fbb_.Required(o, VertexFormat::VT_ATTRIBUTES);
    return o;
  }
};

inline ::flatbuffers::Offset<VertexFormat> CreateVertexFormat(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<const DeepSeaScene::VertexAttribute *>> attributes = 0,
    bool instanced = false) {
  VertexFormatBuilder builder_(_fbb);
  builder_.add_attributes(attributes);
  builder_.add_instanced(instanced);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VertexFormat> CreateVertexFormatDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<DeepSeaScene::VertexAttribute> *attributes = nullptr,
    bool instanced = false) {
  auto attributes__ = attributes ? _fbb.CreateVectorOfStructs<DeepSeaScene::VertexAttribute>(*attributes) : 0;
  return DeepSeaScene::CreateVertexFormat(
      _fbb,
      attributes__,
      instanced);
}

struct VertexBuffer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VertexBufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_OFFSET = 6,
    VT_COUNT = 8,
    VT_FORMAT = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  const DeepSeaScene::VertexFormat *format() const {
    return GetPointer<const DeepSeaScene::VertexFormat *>(VT_FORMAT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyField<uint32_t>(verifier, VT_COUNT, 4) &&
           VerifyOffsetRequired(verifier, VT_FORMAT) &&
           verifier.VerifyTable(format()) &&
           verifier.EndTable();
  }
};

struct VertexBufferBuilder {
  typedef VertexBuffer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(VertexBuffer::VT_NAME, name);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(VertexBuffer::VT_OFFSET, offset, 0);
  }
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(VertexBuffer::VT_COUNT, count, 0);
  }
  void add_format(::flatbuffers::Offset<DeepSeaScene::VertexFormat> format) {
    fbb_.AddOffset(VertexBuffer::VT_FORMAT, format);
  }
  explicit VertexBufferBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VertexBuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VertexBuffer>(end);
    fbb_.Required(o, VertexBuffer::VT_NAME);
    fbb_.Required(o, VertexBuffer::VT_FORMAT);
    return o;
  }
};

inline ::flatbuffers::Offset<VertexBuffer> CreateVertexBuffer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint32_t offset = 0,
    uint32_t count = 0,
    ::flatbuffers::Offset<DeepSeaScene::VertexFormat> format = 0) {
  VertexBufferBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_count(count);
  builder_.add_offset(offset);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VertexBuffer> CreateVertexBufferDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t offset = 0,
    uint32_t count = 0,
    ::flatbuffers::Offset<DeepSeaScene::VertexFormat> format = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return DeepSeaScene::CreateVertexBuffer(
      _fbb,
      name__,
      offset,
      count,
      format);
}

struct IndexBuffer FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef IndexBufferBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_OFFSET = 6,
    VT_COUNT = 8,
    VT_INDEXSIZE = 10
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  uint32_t offset() const {
    return GetField<uint32_t>(VT_OFFSET, 0);
  }
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  uint8_t indexSize() const {
    return GetField<uint8_t>(VT_INDEXSIZE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint32_t>(verifier, VT_OFFSET, 4) &&
           VerifyField<uint32_t>(verifier, VT_COUNT, 4) &&
           VerifyField<uint8_t>(verifier, VT_INDEXSIZE, 1) &&
           verifier.EndTable();
  }
};

struct IndexBufferBuilder {
  typedef IndexBuffer Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(IndexBuffer::VT_NAME, name);
  }
  void add_offset(uint32_t offset) {
    fbb_.AddElement<uint32_t>(IndexBuffer::VT_OFFSET, offset, 0);
  }
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(IndexBuffer::VT_COUNT, count, 0);
  }
  void add_indexSize(uint8_t indexSize) {
    fbb_.AddElement<uint8_t>(IndexBuffer::VT_INDEXSIZE, indexSize, 0);
  }
  explicit IndexBufferBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<IndexBuffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<IndexBuffer>(end);
    fbb_.Required(o, IndexBuffer::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<IndexBuffer> CreateIndexBuffer(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    uint32_t offset = 0,
    uint32_t count = 0,
    uint8_t indexSize = 0) {
  IndexBufferBuilder builder_(_fbb);
  builder_.add_count(count);
  builder_.add_offset(offset);
  builder_.add_name(name);
  builder_.add_indexSize(indexSize);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<IndexBuffer> CreateIndexBufferDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint32_t offset = 0,
    uint32_t count = 0,
    uint8_t indexSize = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return DeepSeaScene::CreateIndexBuffer(
      _fbb,
      name__,
      offset,
      count,
      indexSize);
}

struct DrawGeometry FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DrawGeometryBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VERTEXBUFFERS = 6,
    VT_INDEXBUFFER = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VertexBuffer>> *vertexBuffers() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VertexBuffer>> *>(VT_VERTEXBUFFERS);
  }
  const DeepSeaScene::IndexBuffer *indexBuffer() const {
    return GetPointer<const DeepSeaScene::IndexBuffer *>(VT_INDEXBUFFER);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_VERTEXBUFFERS) &&
           verifier.VerifyVector(vertexBuffers()) &&
           verifier.VerifyVectorOfTables(vertexBuffers()) &&
           VerifyOffset(verifier, VT_INDEXBUFFER) &&
           verifier.VerifyTable(indexBuffer()) &&
           verifier.EndTable();
  }
};

struct DrawGeometryBuilder {
  typedef DrawGeometry Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(DrawGeometry::VT_NAME, name);
  }
  void add_vertexBuffers(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VertexBuffer>>> vertexBuffers) {
    fbb_.AddOffset(DrawGeometry::VT_VERTEXBUFFERS, vertexBuffers);
  }
  void add_indexBuffer(::flatbuffers::Offset<DeepSeaScene::IndexBuffer> indexBuffer) {
    fbb_.AddOffset(DrawGeometry::VT_INDEXBUFFER, indexBuffer);
  }
  explicit DrawGeometryBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DrawGeometry> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DrawGeometry>(end);
    fbb_.Required(o, DrawGeometry::VT_NAME);
    fbb_.Required(o, DrawGeometry::VT_VERTEXBUFFERS);
    return o;
  }
};

inline ::flatbuffers::Offset<DrawGeometry> CreateDrawGeometry(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::VertexBuffer>>> vertexBuffers = 0,
    ::flatbuffers::Offset<DeepSeaScene::IndexBuffer> indexBuffer = 0) {
  DrawGeometryBuilder builder_(_fbb);
  builder_.add_indexBuffer(indexBuffer);
  builder_.add_vertexBuffers(vertexBuffers);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<DrawGeometry> CreateDrawGeometryDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<DeepSeaScene::VertexBuffer>> *vertexBuffers = nullptr,
    ::flatbuffers::Offset<DeepSeaScene::IndexBuffer> indexBuffer = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto vertexBuffers__ = vertexBuffers ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaScene::VertexBuffer>>(*vertexBuffers) : 0;
  return DeepSeaScene::CreateDrawGeometry(
      _fbb,
      name__,
      vertexBuffers__,
      indexBuffer);
}

struct SceneNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SceneNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NODE = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const DeepSeaScene::ObjectData *node() const {
    return GetPointer<const DeepSeaScene::ObjectData *>(VT_NODE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           verifier.EndTable();
  }
};

struct SceneNodeBuilder {
  typedef SceneNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(SceneNode::VT_NAME, name);
  }
  void add_node(::flatbuffers::Offset<DeepSeaScene::ObjectData> node) {
    fbb_.AddOffset(SceneNode::VT_NODE, node);
  }
  explicit SceneNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SceneNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SceneNode>(end);
    fbb_.Required(o, SceneNode::VT_NAME);
    fbb_.Required(o, SceneNode::VT_NODE);
    return o;
  }
};

inline ::flatbuffers::Offset<SceneNode> CreateSceneNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<DeepSeaScene::ObjectData> node = 0) {
  SceneNodeBuilder builder_(_fbb);
  builder_.add_node(node);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SceneNode> CreateSceneNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ::flatbuffers::Offset<DeepSeaScene::ObjectData> node = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return DeepSeaScene::CreateSceneNode(
      _fbb,
      name__,
      node);
}

struct CustomResource FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef CustomResourceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_RESOURCE = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const DeepSeaScene::ObjectData *resource() const {
    return GetPointer<const DeepSeaScene::ObjectData *>(VT_RESOURCE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_RESOURCE) &&
           verifier.VerifyTable(resource()) &&
           verifier.EndTable();
  }
};

struct CustomResourceBuilder {
  typedef CustomResource Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(CustomResource::VT_NAME, name);
  }
  void add_resource(::flatbuffers::Offset<DeepSeaScene::ObjectData> resource) {
    fbb_.AddOffset(CustomResource::VT_RESOURCE, resource);
  }
  explicit CustomResourceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<CustomResource> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<CustomResource>(end);
    fbb_.Required(o, CustomResource::VT_NAME);
    fbb_.Required(o, CustomResource::VT_RESOURCE);
    return o;
  }
};

inline ::flatbuffers::Offset<CustomResource> CreateCustomResource(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<DeepSeaScene::ObjectData> resource = 0) {
  CustomResourceBuilder builder_(_fbb);
  builder_.add_resource(resource);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<CustomResource> CreateCustomResourceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    ::flatbuffers::Offset<DeepSeaScene::ObjectData> resource = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return DeepSeaScene::CreateCustomResource(
      _fbb,
      name__,
      resource);
}

struct SceneResource FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SceneResourceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESOURCE_TYPE = 4,
    VT_RESOURCE = 6
  };
  DeepSeaScene::SceneResourceUnion resource_type() const {
    return static_cast<DeepSeaScene::SceneResourceUnion>(GetField<uint8_t>(VT_RESOURCE_TYPE, 0));
  }
  const void *resource() const {
    return GetPointer<const void *>(VT_RESOURCE);
  }
  template<typename T> const T *resource_as() const;
  const DeepSeaScene::Buffer *resource_as_Buffer() const {
    return resource_type() == DeepSeaScene::SceneResourceUnion::Buffer ? static_cast<const DeepSeaScene::Buffer *>(resource()) : nullptr;
  }
  const DeepSeaScene::Texture *resource_as_Texture() const {
    return resource_type() == DeepSeaScene::SceneResourceUnion::Texture ? static_cast<const DeepSeaScene::Texture *>(resource()) : nullptr;
  }
  const DeepSeaScene::ShaderVariableGroupDesc *resource_as_ShaderVariableGroupDesc() const {
    return resource_type() == DeepSeaScene::SceneResourceUnion::ShaderVariableGroupDesc ? static_cast<const DeepSeaScene::ShaderVariableGroupDesc *>(resource()) : nullptr;
  }
  const DeepSeaScene::ShaderVariableGroup *resource_as_ShaderVariableGroup() const {
    return resource_type() == DeepSeaScene::SceneResourceUnion::ShaderVariableGroup ? static_cast<const DeepSeaScene::ShaderVariableGroup *>(resource()) : nullptr;
  }
  const DeepSeaScene::MaterialDesc *resource_as_MaterialDesc() const {
    return resource_type() == DeepSeaScene::SceneResourceUnion::MaterialDesc ? static_cast<const DeepSeaScene::MaterialDesc *>(resource()) : nullptr;
  }
  const DeepSeaScene::Material *resource_as_Material() const {
    return resource_type() == DeepSeaScene::SceneResourceUnion::Material ? static_cast<const DeepSeaScene::Material *>(resource()) : nullptr;
  }
  const DeepSeaScene::ShaderModule *resource_as_ShaderModule() const {
    return resource_type() == DeepSeaScene::SceneResourceUnion::ShaderModule ? static_cast<const DeepSeaScene::ShaderModule *>(resource()) : nullptr;
  }
  const DeepSeaScene::Shader *resource_as_Shader() const {
    return resource_type() == DeepSeaScene::SceneResourceUnion::Shader ? static_cast<const DeepSeaScene::Shader *>(resource()) : nullptr;
  }
  const DeepSeaScene::DrawGeometry *resource_as_DrawGeometry() const {
    return resource_type() == DeepSeaScene::SceneResourceUnion::DrawGeometry ? static_cast<const DeepSeaScene::DrawGeometry *>(resource()) : nullptr;
  }
  const DeepSeaScene::SceneNode *resource_as_SceneNode() const {
    return resource_type() == DeepSeaScene::SceneResourceUnion::SceneNode ? static_cast<const DeepSeaScene::SceneNode *>(resource()) : nullptr;
  }
  const DeepSeaScene::CustomResource *resource_as_CustomResource() const {
    return resource_type() == DeepSeaScene::SceneResourceUnion::CustomResource ? static_cast<const DeepSeaScene::CustomResource *>(resource()) : nullptr;
  }
  const DeepSeaScene::ObjectData *resource_as_ResourceAction() const {
    return resource_type() == DeepSeaScene::SceneResourceUnion::ResourceAction ? static_cast<const DeepSeaScene::ObjectData *>(resource()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RESOURCE_TYPE, 1) &&
           VerifyOffset(verifier, VT_RESOURCE) &&
           VerifySceneResourceUnion(verifier, resource(), resource_type()) &&
           verifier.EndTable();
  }
};

template<> inline const DeepSeaScene::Buffer *SceneResource::resource_as<DeepSeaScene::Buffer>() const {
  return resource_as_Buffer();
}

template<> inline const DeepSeaScene::Texture *SceneResource::resource_as<DeepSeaScene::Texture>() const {
  return resource_as_Texture();
}

template<> inline const DeepSeaScene::ShaderVariableGroupDesc *SceneResource::resource_as<DeepSeaScene::ShaderVariableGroupDesc>() const {
  return resource_as_ShaderVariableGroupDesc();
}

template<> inline const DeepSeaScene::ShaderVariableGroup *SceneResource::resource_as<DeepSeaScene::ShaderVariableGroup>() const {
  return resource_as_ShaderVariableGroup();
}

template<> inline const DeepSeaScene::MaterialDesc *SceneResource::resource_as<DeepSeaScene::MaterialDesc>() const {
  return resource_as_MaterialDesc();
}

template<> inline const DeepSeaScene::Material *SceneResource::resource_as<DeepSeaScene::Material>() const {
  return resource_as_Material();
}

template<> inline const DeepSeaScene::ShaderModule *SceneResource::resource_as<DeepSeaScene::ShaderModule>() const {
  return resource_as_ShaderModule();
}

template<> inline const DeepSeaScene::Shader *SceneResource::resource_as<DeepSeaScene::Shader>() const {
  return resource_as_Shader();
}

template<> inline const DeepSeaScene::DrawGeometry *SceneResource::resource_as<DeepSeaScene::DrawGeometry>() const {
  return resource_as_DrawGeometry();
}

template<> inline const DeepSeaScene::SceneNode *SceneResource::resource_as<DeepSeaScene::SceneNode>() const {
  return resource_as_SceneNode();
}

template<> inline const DeepSeaScene::CustomResource *SceneResource::resource_as<DeepSeaScene::CustomResource>() const {
  return resource_as_CustomResource();
}

template<> inline const DeepSeaScene::ObjectData *SceneResource::resource_as<DeepSeaScene::ObjectData>() const {
  return resource_as_ResourceAction();
}

struct SceneResourceBuilder {
  typedef SceneResource Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_resource_type(DeepSeaScene::SceneResourceUnion resource_type) {
    fbb_.AddElement<uint8_t>(SceneResource::VT_RESOURCE_TYPE, static_cast<uint8_t>(resource_type), 0);
  }
  void add_resource(::flatbuffers::Offset<void> resource) {
    fbb_.AddOffset(SceneResource::VT_RESOURCE, resource);
  }
  explicit SceneResourceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SceneResource> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SceneResource>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SceneResource> CreateSceneResource(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    DeepSeaScene::SceneResourceUnion resource_type = DeepSeaScene::SceneResourceUnion::NONE,
    ::flatbuffers::Offset<void> resource = 0) {
  SceneResourceBuilder builder_(_fbb);
  builder_.add_resource(resource);
  builder_.add_resource_type(resource_type);
  return builder_.Finish();
}

struct SceneResources FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef SceneResourcesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESOURCES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::SceneResource>> *resources() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::SceneResource>> *>(VT_RESOURCES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_RESOURCES) &&
           verifier.VerifyVector(resources()) &&
           verifier.VerifyVectorOfTables(resources()) &&
           verifier.EndTable();
  }
};

struct SceneResourcesBuilder {
  typedef SceneResources Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_resources(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::SceneResource>>> resources) {
    fbb_.AddOffset(SceneResources::VT_RESOURCES, resources);
  }
  explicit SceneResourcesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<SceneResources> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<SceneResources>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<SceneResources> CreateSceneResources(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaScene::SceneResource>>> resources = 0) {
  SceneResourcesBuilder builder_(_fbb);
  builder_.add_resources(resources);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<SceneResources> CreateSceneResourcesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<DeepSeaScene::SceneResource>> *resources = nullptr) {
  auto resources__ = resources ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaScene::SceneResource>>(*resources) : 0;
  return DeepSeaScene::CreateSceneResources(
      _fbb,
      resources__);
}

inline bool VerifySceneResourceUnion(::flatbuffers::Verifier &verifier, const void *obj, SceneResourceUnion type) {
  switch (type) {
    case SceneResourceUnion::NONE: {
      return true;
    }
    case SceneResourceUnion::Buffer: {
      auto ptr = reinterpret_cast<const DeepSeaScene::Buffer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SceneResourceUnion::Texture: {
      auto ptr = reinterpret_cast<const DeepSeaScene::Texture *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SceneResourceUnion::ShaderVariableGroupDesc: {
      auto ptr = reinterpret_cast<const DeepSeaScene::ShaderVariableGroupDesc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SceneResourceUnion::ShaderVariableGroup: {
      auto ptr = reinterpret_cast<const DeepSeaScene::ShaderVariableGroup *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SceneResourceUnion::MaterialDesc: {
      auto ptr = reinterpret_cast<const DeepSeaScene::MaterialDesc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SceneResourceUnion::Material: {
      auto ptr = reinterpret_cast<const DeepSeaScene::Material *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SceneResourceUnion::ShaderModule: {
      auto ptr = reinterpret_cast<const DeepSeaScene::ShaderModule *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SceneResourceUnion::Shader: {
      auto ptr = reinterpret_cast<const DeepSeaScene::Shader *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SceneResourceUnion::DrawGeometry: {
      auto ptr = reinterpret_cast<const DeepSeaScene::DrawGeometry *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SceneResourceUnion::SceneNode: {
      auto ptr = reinterpret_cast<const DeepSeaScene::SceneNode *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SceneResourceUnion::CustomResource: {
      auto ptr = reinterpret_cast<const DeepSeaScene::CustomResource *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case SceneResourceUnion::ResourceAction: {
      auto ptr = reinterpret_cast<const DeepSeaScene::ObjectData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifySceneResourceUnionVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<SceneResourceUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifySceneResourceUnion(
        verifier,  values->Get(i), types->GetEnum<SceneResourceUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline const DeepSeaScene::SceneResources *GetSceneResources(const void *buf) {
  return ::flatbuffers::GetRoot<DeepSeaScene::SceneResources>(buf);
}

inline const DeepSeaScene::SceneResources *GetSizePrefixedSceneResources(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<DeepSeaScene::SceneResources>(buf);
}

inline bool VerifySceneResourcesBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DeepSeaScene::SceneResources>(nullptr);
}

inline bool VerifySizePrefixedSceneResourcesBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DeepSeaScene::SceneResources>(nullptr);
}

inline void FinishSceneResourcesBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DeepSeaScene::SceneResources> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSceneResourcesBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DeepSeaScene::SceneResources> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace DeepSeaScene

#endif  // FLATBUFFERS_GENERATED_SCENERESOURCES_DEEPSEASCENE_H_
