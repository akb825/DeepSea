// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCENE_DEEPSEASCENE_H_
#define FLATBUFFERS_GENERATED_SCENE_DEEPSEASCENE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 8,
             "Non-compatible flatbuffers version included");

#include "DeepSea/Scene/Flatbuffers/SceneCommon_generated.h"

namespace DeepSeaScene {

struct SceneItemList;
struct SceneItemListBuilder;

struct SceneItemLists;
struct SceneItemListsBuilder;

struct ClearColorFloat;
struct ClearColorFloatBuilder;

struct ClearColorInt;
struct ClearColorIntBuilder;

struct ClearColorUInt;
struct ClearColorUIntBuilder;

struct ClearDepthStencil;
struct ClearDepthStencilBuilder;

struct Attachment;
struct AttachmentBuilder;

struct AttachmentRef;

struct RenderSubpass;
struct RenderSubpassBuilder;

struct SubpassDependency;

struct RenderPass;
struct RenderPassBuilder;

struct ScenePipelineItem;
struct ScenePipelineItemBuilder;

struct Scene;
struct SceneBuilder;

enum class ClearValue : uint8_t {
  NONE = 0,
  ClearColorFloat = 1,
  ClearColorInt = 2,
  ClearColorUInt = 3,
  ClearDepthStencil = 4,
  MIN = NONE,
  MAX = ClearDepthStencil
};

inline const ClearValue (&EnumValuesClearValue())[5] {
  static const ClearValue values[] = {
    ClearValue::NONE,
    ClearValue::ClearColorFloat,
    ClearValue::ClearColorInt,
    ClearValue::ClearColorUInt,
    ClearValue::ClearDepthStencil
  };
  return values;
}

inline const char * const *EnumNamesClearValue() {
  static const char * const names[6] = {
    "NONE",
    "ClearColorFloat",
    "ClearColorInt",
    "ClearColorUInt",
    "ClearDepthStencil",
    nullptr
  };
  return names;
}

inline const char *EnumNameClearValue(ClearValue e) {
  if (flatbuffers::IsOutRange(e, ClearValue::NONE, ClearValue::ClearDepthStencil)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesClearValue()[index];
}

template<typename T> struct ClearValueTraits {
  static const ClearValue enum_value = ClearValue::NONE;
};

template<> struct ClearValueTraits<DeepSeaScene::ClearColorFloat> {
  static const ClearValue enum_value = ClearValue::ClearColorFloat;
};

template<> struct ClearValueTraits<DeepSeaScene::ClearColorInt> {
  static const ClearValue enum_value = ClearValue::ClearColorInt;
};

template<> struct ClearValueTraits<DeepSeaScene::ClearColorUInt> {
  static const ClearValue enum_value = ClearValue::ClearColorUInt;
};

template<> struct ClearValueTraits<DeepSeaScene::ClearDepthStencil> {
  static const ClearValue enum_value = ClearValue::ClearDepthStencil;
};

bool VerifyClearValue(flatbuffers::Verifier &verifier, const void *obj, ClearValue type);
bool VerifyClearValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<ClearValue> *types);

enum class ScenePipelineItemUnion : uint8_t {
  NONE = 0,
  RenderPass = 1,
  SceneItemList = 2,
  MIN = NONE,
  MAX = SceneItemList
};

inline const ScenePipelineItemUnion (&EnumValuesScenePipelineItemUnion())[3] {
  static const ScenePipelineItemUnion values[] = {
    ScenePipelineItemUnion::NONE,
    ScenePipelineItemUnion::RenderPass,
    ScenePipelineItemUnion::SceneItemList
  };
  return values;
}

inline const char * const *EnumNamesScenePipelineItemUnion() {
  static const char * const names[4] = {
    "NONE",
    "RenderPass",
    "SceneItemList",
    nullptr
  };
  return names;
}

inline const char *EnumNameScenePipelineItemUnion(ScenePipelineItemUnion e) {
  if (flatbuffers::IsOutRange(e, ScenePipelineItemUnion::NONE, ScenePipelineItemUnion::SceneItemList)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScenePipelineItemUnion()[index];
}

template<typename T> struct ScenePipelineItemUnionTraits {
  static const ScenePipelineItemUnion enum_value = ScenePipelineItemUnion::NONE;
};

template<> struct ScenePipelineItemUnionTraits<DeepSeaScene::RenderPass> {
  static const ScenePipelineItemUnion enum_value = ScenePipelineItemUnion::RenderPass;
};

template<> struct ScenePipelineItemUnionTraits<DeepSeaScene::SceneItemList> {
  static const ScenePipelineItemUnion enum_value = ScenePipelineItemUnion::SceneItemList;
};

bool VerifyScenePipelineItemUnion(flatbuffers::Verifier &verifier, const void *obj, ScenePipelineItemUnion type);
bool VerifyScenePipelineItemUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<ScenePipelineItemUnion> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) AttachmentRef FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t index_;
  uint8_t resolve_;
  int8_t padding0__;  int16_t padding1__;

 public:
  AttachmentRef()
      : index_(0),
        resolve_(0),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  AttachmentRef(uint32_t _index, bool _resolve)
      : index_(flatbuffers::EndianScalar(_index)),
        resolve_(flatbuffers::EndianScalar(static_cast<uint8_t>(_resolve))),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  uint32_t index() const {
    return flatbuffers::EndianScalar(index_);
  }
  bool resolve() const {
    return flatbuffers::EndianScalar(resolve_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(AttachmentRef, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SubpassDependency FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t srcSubpass_;
  uint32_t srcStages_;
  uint32_t srcAccess_;
  uint32_t dstSubpass_;
  uint32_t dstStages_;
  uint32_t dstAccess_;
  uint8_t regionDependency_;
  int8_t padding0__;  int16_t padding1__;

 public:
  SubpassDependency()
      : srcSubpass_(0),
        srcStages_(0),
        srcAccess_(0),
        dstSubpass_(0),
        dstStages_(0),
        dstAccess_(0),
        regionDependency_(0),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  SubpassDependency(uint32_t _srcSubpass, uint32_t _srcStages, uint32_t _srcAccess, uint32_t _dstSubpass, uint32_t _dstStages, uint32_t _dstAccess, bool _regionDependency)
      : srcSubpass_(flatbuffers::EndianScalar(_srcSubpass)),
        srcStages_(flatbuffers::EndianScalar(_srcStages)),
        srcAccess_(flatbuffers::EndianScalar(_srcAccess)),
        dstSubpass_(flatbuffers::EndianScalar(_dstSubpass)),
        dstStages_(flatbuffers::EndianScalar(_dstStages)),
        dstAccess_(flatbuffers::EndianScalar(_dstAccess)),
        regionDependency_(flatbuffers::EndianScalar(static_cast<uint8_t>(_regionDependency))),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  uint32_t srcSubpass() const {
    return flatbuffers::EndianScalar(srcSubpass_);
  }
  uint32_t srcStages() const {
    return flatbuffers::EndianScalar(srcStages_);
  }
  uint32_t srcAccess() const {
    return flatbuffers::EndianScalar(srcAccess_);
  }
  uint32_t dstSubpass() const {
    return flatbuffers::EndianScalar(dstSubpass_);
  }
  uint32_t dstStages() const {
    return flatbuffers::EndianScalar(dstStages_);
  }
  uint32_t dstAccess() const {
    return flatbuffers::EndianScalar(dstAccess_);
  }
  bool regionDependency() const {
    return flatbuffers::EndianScalar(regionDependency_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(SubpassDependency, 28);

struct SceneItemList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SceneItemListBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_NAME = 6,
    VT_DATA = 8
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct SceneItemListBuilder {
  typedef SceneItemList Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(SceneItemList::VT_TYPE, type);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SceneItemList::VT_NAME, name);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(SceneItemList::VT_DATA, data);
  }
  explicit SceneItemListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SceneItemList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SceneItemList>(end);
    fbb_.Required(o, SceneItemList::VT_TYPE);
    fbb_.Required(o, SceneItemList::VT_NAME);
    fbb_.Required(o, SceneItemList::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<SceneItemList> CreateSceneItemList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  SceneItemListBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SceneItemList> CreateSceneItemListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *name = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return DeepSeaScene::CreateSceneItemList(
      _fbb,
      type__,
      name__,
      data__);
}

struct SceneItemLists FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SceneItemListsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMLISTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::SceneItemList>> *itemLists() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::SceneItemList>> *>(VT_ITEMLISTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMLISTS) &&
           verifier.VerifyVector(itemLists()) &&
           verifier.VerifyVectorOfTables(itemLists()) &&
           verifier.EndTable();
  }
};

struct SceneItemListsBuilder {
  typedef SceneItemLists Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemLists(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::SceneItemList>>> itemLists) {
    fbb_.AddOffset(SceneItemLists::VT_ITEMLISTS, itemLists);
  }
  explicit SceneItemListsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SceneItemLists> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SceneItemLists>(end);
    fbb_.Required(o, SceneItemLists::VT_ITEMLISTS);
    return o;
  }
};

inline flatbuffers::Offset<SceneItemLists> CreateSceneItemLists(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::SceneItemList>>> itemLists = 0) {
  SceneItemListsBuilder builder_(_fbb);
  builder_.add_itemLists(itemLists);
  return builder_.Finish();
}

inline flatbuffers::Offset<SceneItemLists> CreateSceneItemListsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DeepSeaScene::SceneItemList>> *itemLists = nullptr) {
  auto itemLists__ = itemLists ? _fbb.CreateVector<flatbuffers::Offset<DeepSeaScene::SceneItemList>>(*itemLists) : 0;
  return DeepSeaScene::CreateSceneItemLists(
      _fbb,
      itemLists__);
}

struct ClearColorFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClearColorFloatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RED = 4,
    VT_GREEN = 6,
    VT_BLUE = 8,
    VT_ALPHA = 10
  };
  float red() const {
    return GetField<float>(VT_RED, 0.0f);
  }
  float green() const {
    return GetField<float>(VT_GREEN, 0.0f);
  }
  float blue() const {
    return GetField<float>(VT_BLUE, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RED, 4) &&
           VerifyField<float>(verifier, VT_GREEN, 4) &&
           VerifyField<float>(verifier, VT_BLUE, 4) &&
           VerifyField<float>(verifier, VT_ALPHA, 4) &&
           verifier.EndTable();
  }
};

struct ClearColorFloatBuilder {
  typedef ClearColorFloat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_red(float red) {
    fbb_.AddElement<float>(ClearColorFloat::VT_RED, red, 0.0f);
  }
  void add_green(float green) {
    fbb_.AddElement<float>(ClearColorFloat::VT_GREEN, green, 0.0f);
  }
  void add_blue(float blue) {
    fbb_.AddElement<float>(ClearColorFloat::VT_BLUE, blue, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(ClearColorFloat::VT_ALPHA, alpha, 0.0f);
  }
  explicit ClearColorFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClearColorFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClearColorFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClearColorFloat> CreateClearColorFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    float red = 0.0f,
    float green = 0.0f,
    float blue = 0.0f,
    float alpha = 0.0f) {
  ClearColorFloatBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_blue(blue);
  builder_.add_green(green);
  builder_.add_red(red);
  return builder_.Finish();
}

struct ClearColorInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClearColorIntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RED = 4,
    VT_GREEN = 6,
    VT_BLUE = 8,
    VT_ALPHA = 10
  };
  int32_t red() const {
    return GetField<int32_t>(VT_RED, 0);
  }
  int32_t green() const {
    return GetField<int32_t>(VT_GREEN, 0);
  }
  int32_t blue() const {
    return GetField<int32_t>(VT_BLUE, 0);
  }
  int32_t alpha() const {
    return GetField<int32_t>(VT_ALPHA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RED, 4) &&
           VerifyField<int32_t>(verifier, VT_GREEN, 4) &&
           VerifyField<int32_t>(verifier, VT_BLUE, 4) &&
           VerifyField<int32_t>(verifier, VT_ALPHA, 4) &&
           verifier.EndTable();
  }
};

struct ClearColorIntBuilder {
  typedef ClearColorInt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_red(int32_t red) {
    fbb_.AddElement<int32_t>(ClearColorInt::VT_RED, red, 0);
  }
  void add_green(int32_t green) {
    fbb_.AddElement<int32_t>(ClearColorInt::VT_GREEN, green, 0);
  }
  void add_blue(int32_t blue) {
    fbb_.AddElement<int32_t>(ClearColorInt::VT_BLUE, blue, 0);
  }
  void add_alpha(int32_t alpha) {
    fbb_.AddElement<int32_t>(ClearColorInt::VT_ALPHA, alpha, 0);
  }
  explicit ClearColorIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClearColorInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClearColorInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClearColorInt> CreateClearColorInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t red = 0,
    int32_t green = 0,
    int32_t blue = 0,
    int32_t alpha = 0) {
  ClearColorIntBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_blue(blue);
  builder_.add_green(green);
  builder_.add_red(red);
  return builder_.Finish();
}

struct ClearColorUInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClearColorUIntBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RED = 4,
    VT_GREEN = 6,
    VT_BLUE = 8,
    VT_ALPHA = 10
  };
  uint32_t red() const {
    return GetField<uint32_t>(VT_RED, 0);
  }
  uint32_t green() const {
    return GetField<uint32_t>(VT_GREEN, 0);
  }
  uint32_t blue() const {
    return GetField<uint32_t>(VT_BLUE, 0);
  }
  uint32_t alpha() const {
    return GetField<uint32_t>(VT_ALPHA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RED, 4) &&
           VerifyField<uint32_t>(verifier, VT_GREEN, 4) &&
           VerifyField<uint32_t>(verifier, VT_BLUE, 4) &&
           VerifyField<uint32_t>(verifier, VT_ALPHA, 4) &&
           verifier.EndTable();
  }
};

struct ClearColorUIntBuilder {
  typedef ClearColorUInt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_red(uint32_t red) {
    fbb_.AddElement<uint32_t>(ClearColorUInt::VT_RED, red, 0);
  }
  void add_green(uint32_t green) {
    fbb_.AddElement<uint32_t>(ClearColorUInt::VT_GREEN, green, 0);
  }
  void add_blue(uint32_t blue) {
    fbb_.AddElement<uint32_t>(ClearColorUInt::VT_BLUE, blue, 0);
  }
  void add_alpha(uint32_t alpha) {
    fbb_.AddElement<uint32_t>(ClearColorUInt::VT_ALPHA, alpha, 0);
  }
  explicit ClearColorUIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClearColorUInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClearColorUInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClearColorUInt> CreateClearColorUInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t red = 0,
    uint32_t green = 0,
    uint32_t blue = 0,
    uint32_t alpha = 0) {
  ClearColorUIntBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_blue(blue);
  builder_.add_green(green);
  builder_.add_red(red);
  return builder_.Finish();
}

struct ClearDepthStencil FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClearDepthStencilBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEPTH = 4,
    VT_STENCIL = 6
  };
  float depth() const {
    return GetField<float>(VT_DEPTH, 0.0f);
  }
  uint32_t stencil() const {
    return GetField<uint32_t>(VT_STENCIL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_DEPTH, 4) &&
           VerifyField<uint32_t>(verifier, VT_STENCIL, 4) &&
           verifier.EndTable();
  }
};

struct ClearDepthStencilBuilder {
  typedef ClearDepthStencil Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_depth(float depth) {
    fbb_.AddElement<float>(ClearDepthStencil::VT_DEPTH, depth, 0.0f);
  }
  void add_stencil(uint32_t stencil) {
    fbb_.AddElement<uint32_t>(ClearDepthStencil::VT_STENCIL, stencil, 0);
  }
  explicit ClearDepthStencilBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ClearDepthStencil> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClearDepthStencil>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClearDepthStencil> CreateClearDepthStencil(
    flatbuffers::FlatBufferBuilder &_fbb,
    float depth = 0.0f,
    uint32_t stencil = 0) {
  ClearDepthStencilBuilder builder_(_fbb);
  builder_.add_stencil(stencil);
  builder_.add_depth(depth);
  return builder_.Finish();
}

struct Attachment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttachmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USAGE = 4,
    VT_FORMAT = 6,
    VT_DECORATION = 8,
    VT_SAMPLES = 10,
    VT_CLEARVALUE_TYPE = 12,
    VT_CLEARVALUE = 14
  };
  uint32_t usage() const {
    return GetField<uint32_t>(VT_USAGE, 0);
  }
  DeepSeaScene::TextureFormat format() const {
    return static_cast<DeepSeaScene::TextureFormat>(GetField<uint8_t>(VT_FORMAT, 0));
  }
  DeepSeaScene::FormatDecoration decoration() const {
    return static_cast<DeepSeaScene::FormatDecoration>(GetField<uint8_t>(VT_DECORATION, 0));
  }
  uint32_t samples() const {
    return GetField<uint32_t>(VT_SAMPLES, 0);
  }
  DeepSeaScene::ClearValue clearValue_type() const {
    return static_cast<DeepSeaScene::ClearValue>(GetField<uint8_t>(VT_CLEARVALUE_TYPE, 0));
  }
  const void *clearValue() const {
    return GetPointer<const void *>(VT_CLEARVALUE);
  }
  template<typename T> const T *clearValue_as() const;
  const DeepSeaScene::ClearColorFloat *clearValue_as_ClearColorFloat() const {
    return clearValue_type() == DeepSeaScene::ClearValue::ClearColorFloat ? static_cast<const DeepSeaScene::ClearColorFloat *>(clearValue()) : nullptr;
  }
  const DeepSeaScene::ClearColorInt *clearValue_as_ClearColorInt() const {
    return clearValue_type() == DeepSeaScene::ClearValue::ClearColorInt ? static_cast<const DeepSeaScene::ClearColorInt *>(clearValue()) : nullptr;
  }
  const DeepSeaScene::ClearColorUInt *clearValue_as_ClearColorUInt() const {
    return clearValue_type() == DeepSeaScene::ClearValue::ClearColorUInt ? static_cast<const DeepSeaScene::ClearColorUInt *>(clearValue()) : nullptr;
  }
  const DeepSeaScene::ClearDepthStencil *clearValue_as_ClearDepthStencil() const {
    return clearValue_type() == DeepSeaScene::ClearValue::ClearDepthStencil ? static_cast<const DeepSeaScene::ClearDepthStencil *>(clearValue()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_USAGE, 4) &&
           VerifyField<uint8_t>(verifier, VT_FORMAT, 1) &&
           VerifyField<uint8_t>(verifier, VT_DECORATION, 1) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLES, 4) &&
           VerifyField<uint8_t>(verifier, VT_CLEARVALUE_TYPE, 1) &&
           VerifyOffset(verifier, VT_CLEARVALUE) &&
           VerifyClearValue(verifier, clearValue(), clearValue_type()) &&
           verifier.EndTable();
  }
};

template<> inline const DeepSeaScene::ClearColorFloat *Attachment::clearValue_as<DeepSeaScene::ClearColorFloat>() const {
  return clearValue_as_ClearColorFloat();
}

template<> inline const DeepSeaScene::ClearColorInt *Attachment::clearValue_as<DeepSeaScene::ClearColorInt>() const {
  return clearValue_as_ClearColorInt();
}

template<> inline const DeepSeaScene::ClearColorUInt *Attachment::clearValue_as<DeepSeaScene::ClearColorUInt>() const {
  return clearValue_as_ClearColorUInt();
}

template<> inline const DeepSeaScene::ClearDepthStencil *Attachment::clearValue_as<DeepSeaScene::ClearDepthStencil>() const {
  return clearValue_as_ClearDepthStencil();
}

struct AttachmentBuilder {
  typedef Attachment Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_usage(uint32_t usage) {
    fbb_.AddElement<uint32_t>(Attachment::VT_USAGE, usage, 0);
  }
  void add_format(DeepSeaScene::TextureFormat format) {
    fbb_.AddElement<uint8_t>(Attachment::VT_FORMAT, static_cast<uint8_t>(format), 0);
  }
  void add_decoration(DeepSeaScene::FormatDecoration decoration) {
    fbb_.AddElement<uint8_t>(Attachment::VT_DECORATION, static_cast<uint8_t>(decoration), 0);
  }
  void add_samples(uint32_t samples) {
    fbb_.AddElement<uint32_t>(Attachment::VT_SAMPLES, samples, 0);
  }
  void add_clearValue_type(DeepSeaScene::ClearValue clearValue_type) {
    fbb_.AddElement<uint8_t>(Attachment::VT_CLEARVALUE_TYPE, static_cast<uint8_t>(clearValue_type), 0);
  }
  void add_clearValue(flatbuffers::Offset<void> clearValue) {
    fbb_.AddOffset(Attachment::VT_CLEARVALUE, clearValue);
  }
  explicit AttachmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Attachment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Attachment>(end);
    return o;
  }
};

inline flatbuffers::Offset<Attachment> CreateAttachment(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t usage = 0,
    DeepSeaScene::TextureFormat format = DeepSeaScene::TextureFormat::R4G4,
    DeepSeaScene::FormatDecoration decoration = DeepSeaScene::FormatDecoration::UNorm,
    uint32_t samples = 0,
    DeepSeaScene::ClearValue clearValue_type = DeepSeaScene::ClearValue::NONE,
    flatbuffers::Offset<void> clearValue = 0) {
  AttachmentBuilder builder_(_fbb);
  builder_.add_clearValue(clearValue);
  builder_.add_samples(samples);
  builder_.add_usage(usage);
  builder_.add_clearValue_type(clearValue_type);
  builder_.add_decoration(decoration);
  builder_.add_format(format);
  return builder_.Finish();
}

struct RenderSubpass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RenderSubpassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INPUTATTACHMENTS = 6,
    VT_COLORATTACHMENTS = 8,
    VT_DEPTHSTENCILATTACHMENT = 10,
    VT_DRAWLISTS = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint32_t> *inputAttachments() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTATTACHMENTS);
  }
  const flatbuffers::Vector<const DeepSeaScene::AttachmentRef *> *colorAttachments() const {
    return GetPointer<const flatbuffers::Vector<const DeepSeaScene::AttachmentRef *> *>(VT_COLORATTACHMENTS);
  }
  const DeepSeaScene::AttachmentRef *depthStencilAttachment() const {
    return GetStruct<const DeepSeaScene::AttachmentRef *>(VT_DEPTHSTENCILATTACHMENT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::SceneItemList>> *drawLists() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::SceneItemList>> *>(VT_DRAWLISTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTATTACHMENTS) &&
           verifier.VerifyVector(inputAttachments()) &&
           VerifyOffset(verifier, VT_COLORATTACHMENTS) &&
           verifier.VerifyVector(colorAttachments()) &&
           VerifyField<DeepSeaScene::AttachmentRef>(verifier, VT_DEPTHSTENCILATTACHMENT, 4) &&
           VerifyOffsetRequired(verifier, VT_DRAWLISTS) &&
           verifier.VerifyVector(drawLists()) &&
           verifier.VerifyVectorOfTables(drawLists()) &&
           verifier.EndTable();
  }
};

struct RenderSubpassBuilder {
  typedef RenderSubpass Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RenderSubpass::VT_NAME, name);
  }
  void add_inputAttachments(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputAttachments) {
    fbb_.AddOffset(RenderSubpass::VT_INPUTATTACHMENTS, inputAttachments);
  }
  void add_colorAttachments(flatbuffers::Offset<flatbuffers::Vector<const DeepSeaScene::AttachmentRef *>> colorAttachments) {
    fbb_.AddOffset(RenderSubpass::VT_COLORATTACHMENTS, colorAttachments);
  }
  void add_depthStencilAttachment(const DeepSeaScene::AttachmentRef *depthStencilAttachment) {
    fbb_.AddStruct(RenderSubpass::VT_DEPTHSTENCILATTACHMENT, depthStencilAttachment);
  }
  void add_drawLists(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::SceneItemList>>> drawLists) {
    fbb_.AddOffset(RenderSubpass::VT_DRAWLISTS, drawLists);
  }
  explicit RenderSubpassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RenderSubpass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RenderSubpass>(end);
    fbb_.Required(o, RenderSubpass::VT_NAME);
    fbb_.Required(o, RenderSubpass::VT_DRAWLISTS);
    return o;
  }
};

inline flatbuffers::Offset<RenderSubpass> CreateRenderSubpass(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputAttachments = 0,
    flatbuffers::Offset<flatbuffers::Vector<const DeepSeaScene::AttachmentRef *>> colorAttachments = 0,
    const DeepSeaScene::AttachmentRef *depthStencilAttachment = nullptr,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::SceneItemList>>> drawLists = 0) {
  RenderSubpassBuilder builder_(_fbb);
  builder_.add_drawLists(drawLists);
  builder_.add_depthStencilAttachment(depthStencilAttachment);
  builder_.add_colorAttachments(colorAttachments);
  builder_.add_inputAttachments(inputAttachments);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<RenderSubpass> CreateRenderSubpassDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint32_t> *inputAttachments = nullptr,
    const std::vector<DeepSeaScene::AttachmentRef> *colorAttachments = nullptr,
    const DeepSeaScene::AttachmentRef *depthStencilAttachment = nullptr,
    const std::vector<flatbuffers::Offset<DeepSeaScene::SceneItemList>> *drawLists = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputAttachments__ = inputAttachments ? _fbb.CreateVector<uint32_t>(*inputAttachments) : 0;
  auto colorAttachments__ = colorAttachments ? _fbb.CreateVectorOfStructs<DeepSeaScene::AttachmentRef>(*colorAttachments) : 0;
  auto drawLists__ = drawLists ? _fbb.CreateVector<flatbuffers::Offset<DeepSeaScene::SceneItemList>>(*drawLists) : 0;
  return DeepSeaScene::CreateRenderSubpass(
      _fbb,
      name__,
      inputAttachments__,
      colorAttachments__,
      depthStencilAttachment,
      drawLists__);
}

struct RenderPass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RenderPassBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FRAMEBUFFER = 4,
    VT_ATTACHMENTS = 6,
    VT_SUBPASSES = 8,
    VT_DEPENDENCIES = 10
  };
  const flatbuffers::String *framebuffer() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAMEBUFFER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::Attachment>> *attachments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::Attachment>> *>(VT_ATTACHMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::RenderSubpass>> *subpasses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::RenderSubpass>> *>(VT_SUBPASSES);
  }
  const flatbuffers::Vector<const DeepSeaScene::SubpassDependency *> *dependencies() const {
    return GetPointer<const flatbuffers::Vector<const DeepSeaScene::SubpassDependency *> *>(VT_DEPENDENCIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_FRAMEBUFFER) &&
           verifier.VerifyString(framebuffer()) &&
           VerifyOffset(verifier, VT_ATTACHMENTS) &&
           verifier.VerifyVector(attachments()) &&
           verifier.VerifyVectorOfTables(attachments()) &&
           VerifyOffsetRequired(verifier, VT_SUBPASSES) &&
           verifier.VerifyVector(subpasses()) &&
           verifier.VerifyVectorOfTables(subpasses()) &&
           VerifyOffset(verifier, VT_DEPENDENCIES) &&
           verifier.VerifyVector(dependencies()) &&
           verifier.EndTable();
  }
};

struct RenderPassBuilder {
  typedef RenderPass Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_framebuffer(flatbuffers::Offset<flatbuffers::String> framebuffer) {
    fbb_.AddOffset(RenderPass::VT_FRAMEBUFFER, framebuffer);
  }
  void add_attachments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::Attachment>>> attachments) {
    fbb_.AddOffset(RenderPass::VT_ATTACHMENTS, attachments);
  }
  void add_subpasses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::RenderSubpass>>> subpasses) {
    fbb_.AddOffset(RenderPass::VT_SUBPASSES, subpasses);
  }
  void add_dependencies(flatbuffers::Offset<flatbuffers::Vector<const DeepSeaScene::SubpassDependency *>> dependencies) {
    fbb_.AddOffset(RenderPass::VT_DEPENDENCIES, dependencies);
  }
  explicit RenderPassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RenderPass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RenderPass>(end);
    fbb_.Required(o, RenderPass::VT_FRAMEBUFFER);
    fbb_.Required(o, RenderPass::VT_SUBPASSES);
    return o;
  }
};

inline flatbuffers::Offset<RenderPass> CreateRenderPass(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> framebuffer = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::Attachment>>> attachments = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::RenderSubpass>>> subpasses = 0,
    flatbuffers::Offset<flatbuffers::Vector<const DeepSeaScene::SubpassDependency *>> dependencies = 0) {
  RenderPassBuilder builder_(_fbb);
  builder_.add_dependencies(dependencies);
  builder_.add_subpasses(subpasses);
  builder_.add_attachments(attachments);
  builder_.add_framebuffer(framebuffer);
  return builder_.Finish();
}

inline flatbuffers::Offset<RenderPass> CreateRenderPassDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *framebuffer = nullptr,
    const std::vector<flatbuffers::Offset<DeepSeaScene::Attachment>> *attachments = nullptr,
    const std::vector<flatbuffers::Offset<DeepSeaScene::RenderSubpass>> *subpasses = nullptr,
    const std::vector<DeepSeaScene::SubpassDependency> *dependencies = nullptr) {
  auto framebuffer__ = framebuffer ? _fbb.CreateString(framebuffer) : 0;
  auto attachments__ = attachments ? _fbb.CreateVector<flatbuffers::Offset<DeepSeaScene::Attachment>>(*attachments) : 0;
  auto subpasses__ = subpasses ? _fbb.CreateVector<flatbuffers::Offset<DeepSeaScene::RenderSubpass>>(*subpasses) : 0;
  auto dependencies__ = dependencies ? _fbb.CreateVectorOfStructs<DeepSeaScene::SubpassDependency>(*dependencies) : 0;
  return DeepSeaScene::CreateRenderPass(
      _fbb,
      framebuffer__,
      attachments__,
      subpasses__,
      dependencies__);
}

struct ScenePipelineItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScenePipelineItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM_TYPE = 4,
    VT_ITEM = 6
  };
  DeepSeaScene::ScenePipelineItemUnion item_type() const {
    return static_cast<DeepSeaScene::ScenePipelineItemUnion>(GetField<uint8_t>(VT_ITEM_TYPE, 0));
  }
  const void *item() const {
    return GetPointer<const void *>(VT_ITEM);
  }
  template<typename T> const T *item_as() const;
  const DeepSeaScene::RenderPass *item_as_RenderPass() const {
    return item_type() == DeepSeaScene::ScenePipelineItemUnion::RenderPass ? static_cast<const DeepSeaScene::RenderPass *>(item()) : nullptr;
  }
  const DeepSeaScene::SceneItemList *item_as_SceneItemList() const {
    return item_type() == DeepSeaScene::ScenePipelineItemUnion::SceneItemList ? static_cast<const DeepSeaScene::SceneItemList *>(item()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ITEM_TYPE, 1) &&
           VerifyOffset(verifier, VT_ITEM) &&
           VerifyScenePipelineItemUnion(verifier, item(), item_type()) &&
           verifier.EndTable();
  }
};

template<> inline const DeepSeaScene::RenderPass *ScenePipelineItem::item_as<DeepSeaScene::RenderPass>() const {
  return item_as_RenderPass();
}

template<> inline const DeepSeaScene::SceneItemList *ScenePipelineItem::item_as<DeepSeaScene::SceneItemList>() const {
  return item_as_SceneItemList();
}

struct ScenePipelineItemBuilder {
  typedef ScenePipelineItem Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_item_type(DeepSeaScene::ScenePipelineItemUnion item_type) {
    fbb_.AddElement<uint8_t>(ScenePipelineItem::VT_ITEM_TYPE, static_cast<uint8_t>(item_type), 0);
  }
  void add_item(flatbuffers::Offset<void> item) {
    fbb_.AddOffset(ScenePipelineItem::VT_ITEM, item);
  }
  explicit ScenePipelineItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScenePipelineItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScenePipelineItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScenePipelineItem> CreateScenePipelineItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    DeepSeaScene::ScenePipelineItemUnion item_type = DeepSeaScene::ScenePipelineItemUnion::NONE,
    flatbuffers::Offset<void> item = 0) {
  ScenePipelineItemBuilder builder_(_fbb);
  builder_.add_item(item);
  builder_.add_item_type(item_type);
  return builder_.Finish();
}

struct Scene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SceneBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAREDITEMS = 4,
    VT_PIPELINE = 6,
    VT_GLOBALDATA = 8,
    VT_NODES = 10
  };
  const flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::SceneItemLists>> *sharedItems() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::SceneItemLists>> *>(VT_SHAREDITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::ScenePipelineItem>> *pipeline() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::ScenePipelineItem>> *>(VT_PIPELINE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::ObjectData>> *globalData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::ObjectData>> *>(VT_GLOBALDATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_NODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAREDITEMS) &&
           verifier.VerifyVector(sharedItems()) &&
           verifier.VerifyVectorOfTables(sharedItems()) &&
           VerifyOffsetRequired(verifier, VT_PIPELINE) &&
           verifier.VerifyVector(pipeline()) &&
           verifier.VerifyVectorOfTables(pipeline()) &&
           VerifyOffset(verifier, VT_GLOBALDATA) &&
           verifier.VerifyVector(globalData()) &&
           verifier.VerifyVectorOfTables(globalData()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfStrings(nodes()) &&
           verifier.EndTable();
  }
};

struct SceneBuilder {
  typedef Scene Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sharedItems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::SceneItemLists>>> sharedItems) {
    fbb_.AddOffset(Scene::VT_SHAREDITEMS, sharedItems);
  }
  void add_pipeline(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::ScenePipelineItem>>> pipeline) {
    fbb_.AddOffset(Scene::VT_PIPELINE, pipeline);
  }
  void add_globalData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::ObjectData>>> globalData) {
    fbb_.AddOffset(Scene::VT_GLOBALDATA, globalData);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> nodes) {
    fbb_.AddOffset(Scene::VT_NODES, nodes);
  }
  explicit SceneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Scene> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scene>(end);
    fbb_.Required(o, Scene::VT_PIPELINE);
    return o;
  }
};

inline flatbuffers::Offset<Scene> CreateScene(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::SceneItemLists>>> sharedItems = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::ScenePipelineItem>>> pipeline = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<DeepSeaScene::ObjectData>>> globalData = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> nodes = 0) {
  SceneBuilder builder_(_fbb);
  builder_.add_nodes(nodes);
  builder_.add_globalData(globalData);
  builder_.add_pipeline(pipeline);
  builder_.add_sharedItems(sharedItems);
  return builder_.Finish();
}

inline flatbuffers::Offset<Scene> CreateSceneDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<DeepSeaScene::SceneItemLists>> *sharedItems = nullptr,
    const std::vector<flatbuffers::Offset<DeepSeaScene::ScenePipelineItem>> *pipeline = nullptr,
    const std::vector<flatbuffers::Offset<DeepSeaScene::ObjectData>> *globalData = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *nodes = nullptr) {
  auto sharedItems__ = sharedItems ? _fbb.CreateVector<flatbuffers::Offset<DeepSeaScene::SceneItemLists>>(*sharedItems) : 0;
  auto pipeline__ = pipeline ? _fbb.CreateVector<flatbuffers::Offset<DeepSeaScene::ScenePipelineItem>>(*pipeline) : 0;
  auto globalData__ = globalData ? _fbb.CreateVector<flatbuffers::Offset<DeepSeaScene::ObjectData>>(*globalData) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*nodes) : 0;
  return DeepSeaScene::CreateScene(
      _fbb,
      sharedItems__,
      pipeline__,
      globalData__,
      nodes__);
}

inline bool VerifyClearValue(flatbuffers::Verifier &verifier, const void *obj, ClearValue type) {
  switch (type) {
    case ClearValue::NONE: {
      return true;
    }
    case ClearValue::ClearColorFloat: {
      auto ptr = reinterpret_cast<const DeepSeaScene::ClearColorFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClearValue::ClearColorInt: {
      auto ptr = reinterpret_cast<const DeepSeaScene::ClearColorInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClearValue::ClearColorUInt: {
      auto ptr = reinterpret_cast<const DeepSeaScene::ClearColorUInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClearValue::ClearDepthStencil: {
      auto ptr = reinterpret_cast<const DeepSeaScene::ClearDepthStencil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyClearValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<ClearValue> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyClearValue(
        verifier,  values->Get(i), types->GetEnum<ClearValue>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyScenePipelineItemUnion(flatbuffers::Verifier &verifier, const void *obj, ScenePipelineItemUnion type) {
  switch (type) {
    case ScenePipelineItemUnion::NONE: {
      return true;
    }
    case ScenePipelineItemUnion::RenderPass: {
      auto ptr = reinterpret_cast<const DeepSeaScene::RenderPass *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScenePipelineItemUnion::SceneItemList: {
      auto ptr = reinterpret_cast<const DeepSeaScene::SceneItemList *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyScenePipelineItemUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<ScenePipelineItemUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyScenePipelineItemUnion(
        verifier,  values->Get(i), types->GetEnum<ScenePipelineItemUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline const DeepSeaScene::Scene *GetScene(const void *buf) {
  return flatbuffers::GetRoot<DeepSeaScene::Scene>(buf);
}

inline const DeepSeaScene::Scene *GetSizePrefixedScene(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<DeepSeaScene::Scene>(buf);
}

inline bool VerifySceneBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DeepSeaScene::Scene>(nullptr);
}

inline bool VerifySizePrefixedSceneBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DeepSeaScene::Scene>(nullptr);
}

inline void FinishSceneBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DeepSeaScene::Scene> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSceneBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DeepSeaScene::Scene> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace DeepSeaScene

#endif  // FLATBUFFERS_GENERATED_SCENE_DEEPSEASCENE_H_
