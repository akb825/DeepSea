// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCENECOMMON_DEEPSEASCENE_H_
#define FLATBUFFERS_GENERATED_SCENECOMMON_DEEPSEASCENE_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace DeepSeaScene {

struct ObjectData;
struct ObjectDataBuilder;

struct Vector2f;

struct Vector3f;

struct Vector4f;

struct Color3f;

struct Color4f;

struct AlignedBox3f;

struct Matrix33f;

struct Matrix44f;

struct OrientedBox3f;

struct FileReference;
struct FileReferenceBuilder;

struct RelativePathReference;
struct RelativePathReferenceBuilder;

struct RawData;
struct RawDataBuilder;

struct VersionedShaderModule;
struct VersionedShaderModuleBuilder;

struct DynamicRenderStates;
struct DynamicRenderStatesBuilder;

enum class FileResourceType : uint8_t {
  Embedded = 0,
  Installed = 1,
  Dynamic = 2,
  External = 3,
  MIN = Embedded,
  MAX = External
};

inline const FileResourceType (&EnumValuesFileResourceType())[4] {
  static const FileResourceType values[] = {
    FileResourceType::Embedded,
    FileResourceType::Installed,
    FileResourceType::Dynamic,
    FileResourceType::External
  };
  return values;
}

inline const char * const *EnumNamesFileResourceType() {
  static const char * const names[5] = {
    "Embedded",
    "Installed",
    "Dynamic",
    "External",
    nullptr
  };
  return names;
}

inline const char *EnumNameFileResourceType(FileResourceType e) {
  if (::flatbuffers::IsOutRange(e, FileResourceType::Embedded, FileResourceType::External)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFileResourceType()[index];
}

enum class TextureFormat : uint8_t {
  R4G4 = 0,
  R4G4B4A4 = 1,
  B4G4R4A4 = 2,
  A4R4G4B4 = 3,
  R5G6B5 = 4,
  B5G6R5 = 5,
  R5G5B5A1 = 6,
  B5G5R5A1 = 7,
  A1R5G5B5 = 8,
  R8 = 9,
  R8G8 = 10,
  R8G8B8 = 11,
  B8G8R8 = 12,
  R8G8B8A8 = 13,
  B8G8R8A8 = 14,
  A8B8G8R8 = 15,
  A2R10G10B10 = 16,
  A2B10G10R10 = 17,
  R16 = 18,
  R16G16 = 19,
  R16G16B16 = 20,
  R16G16B16A16 = 21,
  R32 = 22,
  R32G32 = 23,
  R32G32B32 = 24,
  R32G32B32A32 = 25,
  R64 = 26,
  R64G64 = 27,
  R64G64B64 = 28,
  R64G64B64A64 = 29,
  B10G11R11_UFloat = 30,
  E5B9G9R9_UFloat = 31,
  D16 = 32,
  X8D24 = 33,
  D32_Float = 34,
  S8 = 35,
  D16S8 = 36,
  D24S8 = 37,
  D32S8_Float = 38,
  BC1_RGB = 39,
  BC1_RGBA = 40,
  BC2 = 41,
  BC3 = 42,
  BC4 = 43,
  BC5 = 44,
  BC6H = 45,
  BC7 = 46,
  ETC1 = 47,
  ETC2_R8G8B8 = 48,
  ETC2_R8G8B8A1 = 49,
  ETC2_R8G8B8A8 = 50,
  EAC_R11 = 51,
  EAC_R11G11 = 52,
  ASTC_4x4 = 53,
  ASTC_5x4 = 54,
  ASTC_5x5 = 55,
  ASTC_6x5 = 56,
  ASTC_6x6 = 57,
  ASTC_8x5 = 58,
  ASTC_8x6 = 59,
  ASTC_8x8 = 60,
  ASTC_10x5 = 61,
  ASTC_10x6 = 62,
  ASTC_10x8 = 63,
  ASTC_10x10 = 64,
  ASTC_12x10 = 65,
  ASTC_12x12 = 66,
  PVRTC1_RGB_2BPP = 67,
  PVRTC1_RGBA_2BPP = 68,
  PVRTC1_RGB_4BPP = 69,
  PVRTC1_RGBA_4BPP = 70,
  PVRTC2_RGBA_2BPP = 71,
  PVRTC2_RGBA_4BPP = 72,
  SurfaceColor = 73,
  SurfaceDepthStencil = 74,
  MIN = R4G4,
  MAX = SurfaceDepthStencil
};

inline const TextureFormat (&EnumValuesTextureFormat())[75] {
  static const TextureFormat values[] = {
    TextureFormat::R4G4,
    TextureFormat::R4G4B4A4,
    TextureFormat::B4G4R4A4,
    TextureFormat::A4R4G4B4,
    TextureFormat::R5G6B5,
    TextureFormat::B5G6R5,
    TextureFormat::R5G5B5A1,
    TextureFormat::B5G5R5A1,
    TextureFormat::A1R5G5B5,
    TextureFormat::R8,
    TextureFormat::R8G8,
    TextureFormat::R8G8B8,
    TextureFormat::B8G8R8,
    TextureFormat::R8G8B8A8,
    TextureFormat::B8G8R8A8,
    TextureFormat::A8B8G8R8,
    TextureFormat::A2R10G10B10,
    TextureFormat::A2B10G10R10,
    TextureFormat::R16,
    TextureFormat::R16G16,
    TextureFormat::R16G16B16,
    TextureFormat::R16G16B16A16,
    TextureFormat::R32,
    TextureFormat::R32G32,
    TextureFormat::R32G32B32,
    TextureFormat::R32G32B32A32,
    TextureFormat::R64,
    TextureFormat::R64G64,
    TextureFormat::R64G64B64,
    TextureFormat::R64G64B64A64,
    TextureFormat::B10G11R11_UFloat,
    TextureFormat::E5B9G9R9_UFloat,
    TextureFormat::D16,
    TextureFormat::X8D24,
    TextureFormat::D32_Float,
    TextureFormat::S8,
    TextureFormat::D16S8,
    TextureFormat::D24S8,
    TextureFormat::D32S8_Float,
    TextureFormat::BC1_RGB,
    TextureFormat::BC1_RGBA,
    TextureFormat::BC2,
    TextureFormat::BC3,
    TextureFormat::BC4,
    TextureFormat::BC5,
    TextureFormat::BC6H,
    TextureFormat::BC7,
    TextureFormat::ETC1,
    TextureFormat::ETC2_R8G8B8,
    TextureFormat::ETC2_R8G8B8A1,
    TextureFormat::ETC2_R8G8B8A8,
    TextureFormat::EAC_R11,
    TextureFormat::EAC_R11G11,
    TextureFormat::ASTC_4x4,
    TextureFormat::ASTC_5x4,
    TextureFormat::ASTC_5x5,
    TextureFormat::ASTC_6x5,
    TextureFormat::ASTC_6x6,
    TextureFormat::ASTC_8x5,
    TextureFormat::ASTC_8x6,
    TextureFormat::ASTC_8x8,
    TextureFormat::ASTC_10x5,
    TextureFormat::ASTC_10x6,
    TextureFormat::ASTC_10x8,
    TextureFormat::ASTC_10x10,
    TextureFormat::ASTC_12x10,
    TextureFormat::ASTC_12x12,
    TextureFormat::PVRTC1_RGB_2BPP,
    TextureFormat::PVRTC1_RGBA_2BPP,
    TextureFormat::PVRTC1_RGB_4BPP,
    TextureFormat::PVRTC1_RGBA_4BPP,
    TextureFormat::PVRTC2_RGBA_2BPP,
    TextureFormat::PVRTC2_RGBA_4BPP,
    TextureFormat::SurfaceColor,
    TextureFormat::SurfaceDepthStencil
  };
  return values;
}

inline const char * const *EnumNamesTextureFormat() {
  static const char * const names[76] = {
    "R4G4",
    "R4G4B4A4",
    "B4G4R4A4",
    "A4R4G4B4",
    "R5G6B5",
    "B5G6R5",
    "R5G5B5A1",
    "B5G5R5A1",
    "A1R5G5B5",
    "R8",
    "R8G8",
    "R8G8B8",
    "B8G8R8",
    "R8G8B8A8",
    "B8G8R8A8",
    "A8B8G8R8",
    "A2R10G10B10",
    "A2B10G10R10",
    "R16",
    "R16G16",
    "R16G16B16",
    "R16G16B16A16",
    "R32",
    "R32G32",
    "R32G32B32",
    "R32G32B32A32",
    "R64",
    "R64G64",
    "R64G64B64",
    "R64G64B64A64",
    "B10G11R11_UFloat",
    "E5B9G9R9_UFloat",
    "D16",
    "X8D24",
    "D32_Float",
    "S8",
    "D16S8",
    "D24S8",
    "D32S8_Float",
    "BC1_RGB",
    "BC1_RGBA",
    "BC2",
    "BC3",
    "BC4",
    "BC5",
    "BC6H",
    "BC7",
    "ETC1",
    "ETC2_R8G8B8",
    "ETC2_R8G8B8A1",
    "ETC2_R8G8B8A8",
    "EAC_R11",
    "EAC_R11G11",
    "ASTC_4x4",
    "ASTC_5x4",
    "ASTC_5x5",
    "ASTC_6x5",
    "ASTC_6x6",
    "ASTC_8x5",
    "ASTC_8x6",
    "ASTC_8x8",
    "ASTC_10x5",
    "ASTC_10x6",
    "ASTC_10x8",
    "ASTC_10x10",
    "ASTC_12x10",
    "ASTC_12x12",
    "PVRTC1_RGB_2BPP",
    "PVRTC1_RGBA_2BPP",
    "PVRTC1_RGB_4BPP",
    "PVRTC1_RGBA_4BPP",
    "PVRTC2_RGBA_2BPP",
    "PVRTC2_RGBA_4BPP",
    "SurfaceColor",
    "SurfaceDepthStencil",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureFormat(TextureFormat e) {
  if (::flatbuffers::IsOutRange(e, TextureFormat::R4G4, TextureFormat::SurfaceDepthStencil)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureFormat()[index];
}

enum class TextureDim : uint8_t {
  Dim1D = 0,
  Dim2D = 1,
  Dim3D = 2,
  DimCube = 3,
  MIN = Dim1D,
  MAX = DimCube
};

inline const TextureDim (&EnumValuesTextureDim())[4] {
  static const TextureDim values[] = {
    TextureDim::Dim1D,
    TextureDim::Dim2D,
    TextureDim::Dim3D,
    TextureDim::DimCube
  };
  return values;
}

inline const char * const *EnumNamesTextureDim() {
  static const char * const names[5] = {
    "Dim1D",
    "Dim2D",
    "Dim3D",
    "DimCube",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureDim(TextureDim e) {
  if (::flatbuffers::IsOutRange(e, TextureDim::Dim1D, TextureDim::DimCube)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureDim()[index];
}

enum class CubeFace : uint8_t {
  PosX = 0,
  NegX = 1,
  PosY = 2,
  NegY = 3,
  PosZ = 4,
  NegZ = 5,
  MIN = PosX,
  MAX = NegZ
};

inline const CubeFace (&EnumValuesCubeFace())[6] {
  static const CubeFace values[] = {
    CubeFace::PosX,
    CubeFace::NegX,
    CubeFace::PosY,
    CubeFace::NegY,
    CubeFace::PosZ,
    CubeFace::NegZ
  };
  return values;
}

inline const char * const *EnumNamesCubeFace() {
  static const char * const names[7] = {
    "PosX",
    "NegX",
    "PosY",
    "NegY",
    "PosZ",
    "NegZ",
    nullptr
  };
  return names;
}

inline const char *EnumNameCubeFace(CubeFace e) {
  if (::flatbuffers::IsOutRange(e, CubeFace::PosX, CubeFace::NegZ)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCubeFace()[index];
}

enum class MaterialType : uint8_t {
  Float = 0,
  Vec2 = 1,
  Vec3 = 2,
  Vec4 = 3,
  Double = 4,
  DVec2 = 5,
  DVec3 = 6,
  DVec4 = 7,
  Int = 8,
  IVec2 = 9,
  IVec3 = 10,
  IVec4 = 11,
  UInt = 12,
  UVec2 = 13,
  UVec3 = 14,
  UVec4 = 15,
  Bool = 16,
  BVec2 = 17,
  BVec3 = 18,
  BVec4 = 19,
  Mat2 = 20,
  Mat3 = 21,
  Mat4 = 22,
  Mat2x3 = 23,
  Mat2x4 = 24,
  Mat3x2 = 25,
  Mat3x4 = 26,
  Mat4x2 = 27,
  Mat4x3 = 28,
  DMat2 = 29,
  DMat3 = 30,
  DMat4 = 31,
  DMat2x3 = 32,
  DMat2x4 = 33,
  DMat3x2 = 34,
  DMat3x4 = 35,
  DMat4x2 = 36,
  DMat4x3 = 37,
  Texture = 38,
  Image = 39,
  SubpassInput = 40,
  TextureBuffer = 41,
  ImageBuffer = 42,
  VariableGroup = 43,
  UniformBlock = 44,
  UniformBuffer = 45,
  MIN = Float,
  MAX = UniformBuffer
};

inline const MaterialType (&EnumValuesMaterialType())[46] {
  static const MaterialType values[] = {
    MaterialType::Float,
    MaterialType::Vec2,
    MaterialType::Vec3,
    MaterialType::Vec4,
    MaterialType::Double,
    MaterialType::DVec2,
    MaterialType::DVec3,
    MaterialType::DVec4,
    MaterialType::Int,
    MaterialType::IVec2,
    MaterialType::IVec3,
    MaterialType::IVec4,
    MaterialType::UInt,
    MaterialType::UVec2,
    MaterialType::UVec3,
    MaterialType::UVec4,
    MaterialType::Bool,
    MaterialType::BVec2,
    MaterialType::BVec3,
    MaterialType::BVec4,
    MaterialType::Mat2,
    MaterialType::Mat3,
    MaterialType::Mat4,
    MaterialType::Mat2x3,
    MaterialType::Mat2x4,
    MaterialType::Mat3x2,
    MaterialType::Mat3x4,
    MaterialType::Mat4x2,
    MaterialType::Mat4x3,
    MaterialType::DMat2,
    MaterialType::DMat3,
    MaterialType::DMat4,
    MaterialType::DMat2x3,
    MaterialType::DMat2x4,
    MaterialType::DMat3x2,
    MaterialType::DMat3x4,
    MaterialType::DMat4x2,
    MaterialType::DMat4x3,
    MaterialType::Texture,
    MaterialType::Image,
    MaterialType::SubpassInput,
    MaterialType::TextureBuffer,
    MaterialType::ImageBuffer,
    MaterialType::VariableGroup,
    MaterialType::UniformBlock,
    MaterialType::UniformBuffer
  };
  return values;
}

inline const char * const *EnumNamesMaterialType() {
  static const char * const names[47] = {
    "Float",
    "Vec2",
    "Vec3",
    "Vec4",
    "Double",
    "DVec2",
    "DVec3",
    "DVec4",
    "Int",
    "IVec2",
    "IVec3",
    "IVec4",
    "UInt",
    "UVec2",
    "UVec3",
    "UVec4",
    "Bool",
    "BVec2",
    "BVec3",
    "BVec4",
    "Mat2",
    "Mat3",
    "Mat4",
    "Mat2x3",
    "Mat2x4",
    "Mat3x2",
    "Mat3x4",
    "Mat4x2",
    "Mat4x3",
    "DMat2",
    "DMat3",
    "DMat4",
    "DMat2x3",
    "DMat2x4",
    "DMat3x2",
    "DMat3x4",
    "DMat4x2",
    "DMat4x3",
    "Texture",
    "Image",
    "SubpassInput",
    "TextureBuffer",
    "ImageBuffer",
    "VariableGroup",
    "UniformBlock",
    "UniformBuffer",
    nullptr
  };
  return names;
}

inline const char *EnumNameMaterialType(MaterialType e) {
  if (::flatbuffers::IsOutRange(e, MaterialType::Float, MaterialType::UniformBuffer)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMaterialType()[index];
}

enum class MaterialBinding : uint8_t {
  Material = 0,
  Global = 1,
  Instance = 2,
  MIN = Material,
  MAX = Instance
};

inline const MaterialBinding (&EnumValuesMaterialBinding())[3] {
  static const MaterialBinding values[] = {
    MaterialBinding::Material,
    MaterialBinding::Global,
    MaterialBinding::Instance
  };
  return values;
}

inline const char * const *EnumNamesMaterialBinding() {
  static const char * const names[4] = {
    "Material",
    "Global",
    "Instance",
    nullptr
  };
  return names;
}

inline const char *EnumNameMaterialBinding(MaterialBinding e) {
  if (::flatbuffers::IsOutRange(e, MaterialBinding::Material, MaterialBinding::Instance)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMaterialBinding()[index];
}

enum class VertexElementFormat : uint8_t {
  Unset = 0,
  X8 = 1,
  X8Y8 = 2,
  X8Y8Z8 = 3,
  X8Y8Z8W8 = 4,
  W2X10Y10Z10 = 5,
  W2Z10Y10X10 = 6,
  X16 = 7,
  X16Y16 = 8,
  X16Y16Z16 = 9,
  X16Y16Z16W16 = 10,
  X32 = 11,
  X32Y32 = 12,
  X32Y32Z32 = 13,
  X32Y32Z32W32 = 14,
  X64 = 15,
  X64Y64 = 16,
  X64Y64Z64 = 17,
  X64Y64Z64W64 = 18,
  R8 = 19,
  R8G8 = 20,
  R8G8B8 = 21,
  R8G8B8A8 = 22,
  A2R10G10B10 = 23,
  A2B10G10R10 = 24,
  R16 = 25,
  R16G16 = 26,
  R16G16B16 = 27,
  R16G16B16A16 = 28,
  R32 = 29,
  R32G32 = 30,
  R32G32B32 = 31,
  R32G32B32A32 = 32,
  R64 = 33,
  R64G64 = 34,
  R64G64B64 = 35,
  R64G64B64A64 = 36,
  MIN = Unset,
  MAX = R64G64B64A64
};

inline const VertexElementFormat (&EnumValuesVertexElementFormat())[37] {
  static const VertexElementFormat values[] = {
    VertexElementFormat::Unset,
    VertexElementFormat::X8,
    VertexElementFormat::X8Y8,
    VertexElementFormat::X8Y8Z8,
    VertexElementFormat::X8Y8Z8W8,
    VertexElementFormat::W2X10Y10Z10,
    VertexElementFormat::W2Z10Y10X10,
    VertexElementFormat::X16,
    VertexElementFormat::X16Y16,
    VertexElementFormat::X16Y16Z16,
    VertexElementFormat::X16Y16Z16W16,
    VertexElementFormat::X32,
    VertexElementFormat::X32Y32,
    VertexElementFormat::X32Y32Z32,
    VertexElementFormat::X32Y32Z32W32,
    VertexElementFormat::X64,
    VertexElementFormat::X64Y64,
    VertexElementFormat::X64Y64Z64,
    VertexElementFormat::X64Y64Z64W64,
    VertexElementFormat::R8,
    VertexElementFormat::R8G8,
    VertexElementFormat::R8G8B8,
    VertexElementFormat::R8G8B8A8,
    VertexElementFormat::A2R10G10B10,
    VertexElementFormat::A2B10G10R10,
    VertexElementFormat::R16,
    VertexElementFormat::R16G16,
    VertexElementFormat::R16G16B16,
    VertexElementFormat::R16G16B16A16,
    VertexElementFormat::R32,
    VertexElementFormat::R32G32,
    VertexElementFormat::R32G32B32,
    VertexElementFormat::R32G32B32A32,
    VertexElementFormat::R64,
    VertexElementFormat::R64G64,
    VertexElementFormat::R64G64B64,
    VertexElementFormat::R64G64B64A64
  };
  return values;
}

inline const char * const *EnumNamesVertexElementFormat() {
  static const char * const names[38] = {
    "Unset",
    "X8",
    "X8Y8",
    "X8Y8Z8",
    "X8Y8Z8W8",
    "W2X10Y10Z10",
    "W2Z10Y10X10",
    "X16",
    "X16Y16",
    "X16Y16Z16",
    "X16Y16Z16W16",
    "X32",
    "X32Y32",
    "X32Y32Z32",
    "X32Y32Z32W32",
    "X64",
    "X64Y64",
    "X64Y64Z64",
    "X64Y64Z64W64",
    "R8",
    "R8G8",
    "R8G8B8",
    "R8G8B8A8",
    "A2R10G10B10",
    "A2B10G10R10",
    "R16",
    "R16G16",
    "R16G16B16",
    "R16G16B16A16",
    "R32",
    "R32G32",
    "R32G32B32",
    "R32G32B32A32",
    "R64",
    "R64G64",
    "R64G64B64",
    "R64G64B64A64",
    nullptr
  };
  return names;
}

inline const char *EnumNameVertexElementFormat(VertexElementFormat e) {
  if (::flatbuffers::IsOutRange(e, VertexElementFormat::Unset, VertexElementFormat::R64G64B64A64)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVertexElementFormat()[index];
}

enum class FormatDecoration : uint8_t {
  UNorm = 0,
  SNorm = 1,
  UScaled = 2,
  SScaled = 3,
  UInt = 4,
  SInt = 5,
  Float = 6,
  UFloat = 7,
  SRGB = 8,
  Unset = 9,
  MIN = UNorm,
  MAX = Unset
};

inline const FormatDecoration (&EnumValuesFormatDecoration())[10] {
  static const FormatDecoration values[] = {
    FormatDecoration::UNorm,
    FormatDecoration::SNorm,
    FormatDecoration::UScaled,
    FormatDecoration::SScaled,
    FormatDecoration::UInt,
    FormatDecoration::SInt,
    FormatDecoration::Float,
    FormatDecoration::UFloat,
    FormatDecoration::SRGB,
    FormatDecoration::Unset
  };
  return values;
}

inline const char * const *EnumNamesFormatDecoration() {
  static const char * const names[11] = {
    "UNorm",
    "SNorm",
    "UScaled",
    "SScaled",
    "UInt",
    "SInt",
    "Float",
    "UFloat",
    "SRGB",
    "Unset",
    nullptr
  };
  return names;
}

inline const char *EnumNameFormatDecoration(FormatDecoration e) {
  if (::flatbuffers::IsOutRange(e, FormatDecoration::UNorm, FormatDecoration::Unset)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFormatDecoration()[index];
}

enum class FileOrData : uint8_t {
  NONE = 0,
  FileReference = 1,
  RelativePathReference = 2,
  RawData = 3,
  MIN = NONE,
  MAX = RawData
};

inline const FileOrData (&EnumValuesFileOrData())[4] {
  static const FileOrData values[] = {
    FileOrData::NONE,
    FileOrData::FileReference,
    FileOrData::RelativePathReference,
    FileOrData::RawData
  };
  return values;
}

inline const char * const *EnumNamesFileOrData() {
  static const char * const names[5] = {
    "NONE",
    "FileReference",
    "RelativePathReference",
    "RawData",
    nullptr
  };
  return names;
}

inline const char *EnumNameFileOrData(FileOrData e) {
  if (::flatbuffers::IsOutRange(e, FileOrData::NONE, FileOrData::RawData)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFileOrData()[index];
}

template<typename T> struct FileOrDataTraits {
  static const FileOrData enum_value = FileOrData::NONE;
};

template<> struct FileOrDataTraits<DeepSeaScene::FileReference> {
  static const FileOrData enum_value = FileOrData::FileReference;
};

template<> struct FileOrDataTraits<DeepSeaScene::RelativePathReference> {
  static const FileOrData enum_value = FileOrData::RelativePathReference;
};

template<> struct FileOrDataTraits<DeepSeaScene::RawData> {
  static const FileOrData enum_value = FileOrData::RawData;
};

bool VerifyFileOrData(::flatbuffers::Verifier &verifier, const void *obj, FileOrData type);
bool VerifyFileOrDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<FileOrData> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector2f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vector2f()
      : x_(0),
        y_(0) {
  }
  Vector2f(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vector2f, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector3f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector3f()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vector3f(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vector3f, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector4f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vector4f()
      : x_(0),
        y_(0),
        z_(0),
        w_(0) {
  }
  Vector4f(float _x, float _y, float _z, float _w)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)),
        w_(::flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return ::flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vector4f, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Color3f FLATBUFFERS_FINAL_CLASS {
 private:
  float red_;
  float green_;
  float blue_;

 public:
  Color3f()
      : red_(0),
        green_(0),
        blue_(0) {
  }
  Color3f(float _red, float _green, float _blue)
      : red_(::flatbuffers::EndianScalar(_red)),
        green_(::flatbuffers::EndianScalar(_green)),
        blue_(::flatbuffers::EndianScalar(_blue)) {
  }
  float red() const {
    return ::flatbuffers::EndianScalar(red_);
  }
  float green() const {
    return ::flatbuffers::EndianScalar(green_);
  }
  float blue() const {
    return ::flatbuffers::EndianScalar(blue_);
  }
};
FLATBUFFERS_STRUCT_END(Color3f, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Color4f FLATBUFFERS_FINAL_CLASS {
 private:
  float red_;
  float green_;
  float blue_;
  float alpha_;

 public:
  Color4f()
      : red_(0),
        green_(0),
        blue_(0),
        alpha_(0) {
  }
  Color4f(float _red, float _green, float _blue, float _alpha)
      : red_(::flatbuffers::EndianScalar(_red)),
        green_(::flatbuffers::EndianScalar(_green)),
        blue_(::flatbuffers::EndianScalar(_blue)),
        alpha_(::flatbuffers::EndianScalar(_alpha)) {
  }
  float red() const {
    return ::flatbuffers::EndianScalar(red_);
  }
  float green() const {
    return ::flatbuffers::EndianScalar(green_);
  }
  float blue() const {
    return ::flatbuffers::EndianScalar(blue_);
  }
  float alpha() const {
    return ::flatbuffers::EndianScalar(alpha_);
  }
};
FLATBUFFERS_STRUCT_END(Color4f, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) AlignedBox3f FLATBUFFERS_FINAL_CLASS {
 private:
  DeepSeaScene::Vector3f min_;
  DeepSeaScene::Vector3f max_;

 public:
  AlignedBox3f()
      : min_(),
        max_() {
  }
  AlignedBox3f(const DeepSeaScene::Vector3f &_min, const DeepSeaScene::Vector3f &_max)
      : min_(_min),
        max_(_max) {
  }
  const DeepSeaScene::Vector3f &min() const {
    return min_;
  }
  const DeepSeaScene::Vector3f &max() const {
    return max_;
  }
};
FLATBUFFERS_STRUCT_END(AlignedBox3f, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Matrix33f FLATBUFFERS_FINAL_CLASS {
 private:
  DeepSeaScene::Vector3f column0_;
  DeepSeaScene::Vector3f column1_;
  DeepSeaScene::Vector3f column2_;

 public:
  Matrix33f()
      : column0_(),
        column1_(),
        column2_() {
  }
  Matrix33f(const DeepSeaScene::Vector3f &_column0, const DeepSeaScene::Vector3f &_column1, const DeepSeaScene::Vector3f &_column2)
      : column0_(_column0),
        column1_(_column1),
        column2_(_column2) {
  }
  const DeepSeaScene::Vector3f &column0() const {
    return column0_;
  }
  const DeepSeaScene::Vector3f &column1() const {
    return column1_;
  }
  const DeepSeaScene::Vector3f &column2() const {
    return column2_;
  }
};
FLATBUFFERS_STRUCT_END(Matrix33f, 36);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Matrix44f FLATBUFFERS_FINAL_CLASS {
 private:
  DeepSeaScene::Vector4f column0_;
  DeepSeaScene::Vector4f column1_;
  DeepSeaScene::Vector4f column2_;
  DeepSeaScene::Vector4f column3_;

 public:
  Matrix44f()
      : column0_(),
        column1_(),
        column2_(),
        column3_() {
  }
  Matrix44f(const DeepSeaScene::Vector4f &_column0, const DeepSeaScene::Vector4f &_column1, const DeepSeaScene::Vector4f &_column2, const DeepSeaScene::Vector4f &_column3)
      : column0_(_column0),
        column1_(_column1),
        column2_(_column2),
        column3_(_column3) {
  }
  const DeepSeaScene::Vector4f &column0() const {
    return column0_;
  }
  const DeepSeaScene::Vector4f &column1() const {
    return column1_;
  }
  const DeepSeaScene::Vector4f &column2() const {
    return column2_;
  }
  const DeepSeaScene::Vector4f &column3() const {
    return column3_;
  }
};
FLATBUFFERS_STRUCT_END(Matrix44f, 64);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) OrientedBox3f FLATBUFFERS_FINAL_CLASS {
 private:
  DeepSeaScene::Matrix33f orientation_;
  DeepSeaScene::Vector3f center_;
  DeepSeaScene::Vector3f halfExtents_;

 public:
  OrientedBox3f()
      : orientation_(),
        center_(),
        halfExtents_() {
  }
  OrientedBox3f(const DeepSeaScene::Matrix33f &_orientation, const DeepSeaScene::Vector3f &_center, const DeepSeaScene::Vector3f &_halfExtents)
      : orientation_(_orientation),
        center_(_center),
        halfExtents_(_halfExtents) {
  }
  const DeepSeaScene::Matrix33f &orientation() const {
    return orientation_;
  }
  const DeepSeaScene::Vector3f &center() const {
    return center_;
  }
  const DeepSeaScene::Vector3f &halfExtents() const {
    return halfExtents_;
  }
};
FLATBUFFERS_STRUCT_END(OrientedBox3f, 60);

struct ObjectData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ObjectDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA = 6
  };
  const ::flatbuffers::String *type() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct ObjectDataBuilder {
  typedef ObjectData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(::flatbuffers::Offset<::flatbuffers::String> type) {
    fbb_.AddOffset(ObjectData::VT_TYPE, type);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(ObjectData::VT_DATA, data);
  }
  explicit ObjectDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ObjectData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ObjectData>(end);
    fbb_.Required(o, ObjectData::VT_TYPE);
    fbb_.Required(o, ObjectData::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<ObjectData> CreateObjectData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> type = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  ObjectDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ObjectData> CreateObjectDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return DeepSeaScene::CreateObjectData(
      _fbb,
      type__,
      data__);
}

struct FileReference FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FileReferenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_PATH = 6
  };
  DeepSeaScene::FileResourceType type() const {
    return static_cast<DeepSeaScene::FileResourceType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
};

struct FileReferenceBuilder {
  typedef FileReference Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_type(DeepSeaScene::FileResourceType type) {
    fbb_.AddElement<uint8_t>(FileReference::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(FileReference::VT_PATH, path);
  }
  explicit FileReferenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FileReference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FileReference>(end);
    fbb_.Required(o, FileReference::VT_PATH);
    return o;
  }
};

inline ::flatbuffers::Offset<FileReference> CreateFileReference(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    DeepSeaScene::FileResourceType type = DeepSeaScene::FileResourceType::Embedded,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0) {
  FileReferenceBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FileReference> CreateFileReferenceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    DeepSeaScene::FileResourceType type = DeepSeaScene::FileResourceType::Embedded,
    const char *path = nullptr) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return DeepSeaScene::CreateFileReference(
      _fbb,
      type,
      path__);
}

struct RelativePathReference FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RelativePathReferenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PATH = 4
  };
  const ::flatbuffers::String *path() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PATH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
};

struct RelativePathReferenceBuilder {
  typedef RelativePathReference Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_path(::flatbuffers::Offset<::flatbuffers::String> path) {
    fbb_.AddOffset(RelativePathReference::VT_PATH, path);
  }
  explicit RelativePathReferenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RelativePathReference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RelativePathReference>(end);
    fbb_.Required(o, RelativePathReference::VT_PATH);
    return o;
  }
};

inline ::flatbuffers::Offset<RelativePathReference> CreateRelativePathReference(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> path = 0) {
  RelativePathReferenceBuilder builder_(_fbb);
  builder_.add_path(path);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RelativePathReference> CreateRelativePathReferenceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return DeepSeaScene::CreateRelativePathReference(
      _fbb,
      path__);
}

struct RawData FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RawDataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct RawDataBuilder {
  typedef RawData Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(RawData::VT_DATA, data);
  }
  explicit RawDataBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RawData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RawData>(end);
    fbb_.Required(o, RawData::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<RawData> CreateRawData(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  RawDataBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RawData> CreateRawDataDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return DeepSeaScene::CreateRawData(
      _fbb,
      data__);
}

struct VersionedShaderModule FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VersionedShaderModuleBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VERSION = 4,
    VT_DATA_TYPE = 6,
    VT_DATA = 8
  };
  const ::flatbuffers::String *version() const {
    return GetPointer<const ::flatbuffers::String *>(VT_VERSION);
  }
  DeepSeaScene::FileOrData data_type() const {
    return static_cast<DeepSeaScene::FileOrData>(GetField<uint8_t>(VT_DATA_TYPE, 0));
  }
  const void *data() const {
    return GetPointer<const void *>(VT_DATA);
  }
  template<typename T> const T *data_as() const;
  const DeepSeaScene::FileReference *data_as_FileReference() const {
    return data_type() == DeepSeaScene::FileOrData::FileReference ? static_cast<const DeepSeaScene::FileReference *>(data()) : nullptr;
  }
  const DeepSeaScene::RelativePathReference *data_as_RelativePathReference() const {
    return data_type() == DeepSeaScene::FileOrData::RelativePathReference ? static_cast<const DeepSeaScene::RelativePathReference *>(data()) : nullptr;
  }
  const DeepSeaScene::RawData *data_as_RawData() const {
    return data_type() == DeepSeaScene::FileOrData::RawData ? static_cast<const DeepSeaScene::RawData *>(data()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyField<uint8_t>(verifier, VT_DATA_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           VerifyFileOrData(verifier, data(), data_type()) &&
           verifier.EndTable();
  }
};

template<> inline const DeepSeaScene::FileReference *VersionedShaderModule::data_as<DeepSeaScene::FileReference>() const {
  return data_as_FileReference();
}

template<> inline const DeepSeaScene::RelativePathReference *VersionedShaderModule::data_as<DeepSeaScene::RelativePathReference>() const {
  return data_as_RelativePathReference();
}

template<> inline const DeepSeaScene::RawData *VersionedShaderModule::data_as<DeepSeaScene::RawData>() const {
  return data_as_RawData();
}

struct VersionedShaderModuleBuilder {
  typedef VersionedShaderModule Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_version(::flatbuffers::Offset<::flatbuffers::String> version) {
    fbb_.AddOffset(VersionedShaderModule::VT_VERSION, version);
  }
  void add_data_type(DeepSeaScene::FileOrData data_type) {
    fbb_.AddElement<uint8_t>(VersionedShaderModule::VT_DATA_TYPE, static_cast<uint8_t>(data_type), 0);
  }
  void add_data(::flatbuffers::Offset<void> data) {
    fbb_.AddOffset(VersionedShaderModule::VT_DATA, data);
  }
  explicit VersionedShaderModuleBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VersionedShaderModule> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VersionedShaderModule>(end);
    fbb_.Required(o, VersionedShaderModule::VT_VERSION);
    fbb_.Required(o, VersionedShaderModule::VT_DATA);
    return o;
  }
};

inline ::flatbuffers::Offset<VersionedShaderModule> CreateVersionedShaderModule(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> version = 0,
    DeepSeaScene::FileOrData data_type = DeepSeaScene::FileOrData::NONE,
    ::flatbuffers::Offset<void> data = 0) {
  VersionedShaderModuleBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_version(version);
  builder_.add_data_type(data_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VersionedShaderModule> CreateVersionedShaderModuleDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    DeepSeaScene::FileOrData data_type = DeepSeaScene::FileOrData::NONE,
    ::flatbuffers::Offset<void> data = 0) {
  auto version__ = version ? _fbb.CreateString(version) : 0;
  return DeepSeaScene::CreateVersionedShaderModule(
      _fbb,
      version__,
      data_type,
      data);
}

struct DynamicRenderStates FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DynamicRenderStatesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LINEWIDTH = 4,
    VT_DEPTHBIASCONSTANTFACTOR = 6,
    VT_DEPTHBIASCLAMP = 8,
    VT_DEPTHBIASSLOPEFACTOR = 10,
    VT_BLENDCONSTANTS = 12,
    VT_DEPTHBOUNDS = 14,
    VT_FRONTSTENCILCOMPAREMASK = 16,
    VT_BACKSTENCILCOMPAREMASK = 18,
    VT_FRONTSTENCILWRITEMASK = 20,
    VT_BACKSTENCILWRITEMASK = 22,
    VT_FRONTSTENCILREFERENCE = 24,
    VT_BACKSTENCILREFERENCE = 26
  };
  float lineWidth() const {
    return GetField<float>(VT_LINEWIDTH, 0.0f);
  }
  float depthBiasConstantFactor() const {
    return GetField<float>(VT_DEPTHBIASCONSTANTFACTOR, 0.0f);
  }
  float depthBiasClamp() const {
    return GetField<float>(VT_DEPTHBIASCLAMP, 0.0f);
  }
  float depthBiasSlopeFactor() const {
    return GetField<float>(VT_DEPTHBIASSLOPEFACTOR, 0.0f);
  }
  const DeepSeaScene::Color4f *blendConstants() const {
    return GetStruct<const DeepSeaScene::Color4f *>(VT_BLENDCONSTANTS);
  }
  const DeepSeaScene::Vector2f *depthBounds() const {
    return GetStruct<const DeepSeaScene::Vector2f *>(VT_DEPTHBOUNDS);
  }
  uint32_t frontStencilCompareMask() const {
    return GetField<uint32_t>(VT_FRONTSTENCILCOMPAREMASK, 0);
  }
  uint32_t backStencilCompareMask() const {
    return GetField<uint32_t>(VT_BACKSTENCILCOMPAREMASK, 0);
  }
  uint32_t frontStencilWriteMask() const {
    return GetField<uint32_t>(VT_FRONTSTENCILWRITEMASK, 0);
  }
  uint32_t backStencilWriteMask() const {
    return GetField<uint32_t>(VT_BACKSTENCILWRITEMASK, 0);
  }
  uint32_t frontStencilReference() const {
    return GetField<uint32_t>(VT_FRONTSTENCILREFERENCE, 0);
  }
  uint32_t backStencilReference() const {
    return GetField<uint32_t>(VT_BACKSTENCILREFERENCE, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_LINEWIDTH, 4) &&
           VerifyField<float>(verifier, VT_DEPTHBIASCONSTANTFACTOR, 4) &&
           VerifyField<float>(verifier, VT_DEPTHBIASCLAMP, 4) &&
           VerifyField<float>(verifier, VT_DEPTHBIASSLOPEFACTOR, 4) &&
           VerifyField<DeepSeaScene::Color4f>(verifier, VT_BLENDCONSTANTS, 4) &&
           VerifyField<DeepSeaScene::Vector2f>(verifier, VT_DEPTHBOUNDS, 4) &&
           VerifyField<uint32_t>(verifier, VT_FRONTSTENCILCOMPAREMASK, 4) &&
           VerifyField<uint32_t>(verifier, VT_BACKSTENCILCOMPAREMASK, 4) &&
           VerifyField<uint32_t>(verifier, VT_FRONTSTENCILWRITEMASK, 4) &&
           VerifyField<uint32_t>(verifier, VT_BACKSTENCILWRITEMASK, 4) &&
           VerifyField<uint32_t>(verifier, VT_FRONTSTENCILREFERENCE, 4) &&
           VerifyField<uint32_t>(verifier, VT_BACKSTENCILREFERENCE, 4) &&
           verifier.EndTable();
  }
};

struct DynamicRenderStatesBuilder {
  typedef DynamicRenderStates Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_lineWidth(float lineWidth) {
    fbb_.AddElement<float>(DynamicRenderStates::VT_LINEWIDTH, lineWidth, 0.0f);
  }
  void add_depthBiasConstantFactor(float depthBiasConstantFactor) {
    fbb_.AddElement<float>(DynamicRenderStates::VT_DEPTHBIASCONSTANTFACTOR, depthBiasConstantFactor, 0.0f);
  }
  void add_depthBiasClamp(float depthBiasClamp) {
    fbb_.AddElement<float>(DynamicRenderStates::VT_DEPTHBIASCLAMP, depthBiasClamp, 0.0f);
  }
  void add_depthBiasSlopeFactor(float depthBiasSlopeFactor) {
    fbb_.AddElement<float>(DynamicRenderStates::VT_DEPTHBIASSLOPEFACTOR, depthBiasSlopeFactor, 0.0f);
  }
  void add_blendConstants(const DeepSeaScene::Color4f *blendConstants) {
    fbb_.AddStruct(DynamicRenderStates::VT_BLENDCONSTANTS, blendConstants);
  }
  void add_depthBounds(const DeepSeaScene::Vector2f *depthBounds) {
    fbb_.AddStruct(DynamicRenderStates::VT_DEPTHBOUNDS, depthBounds);
  }
  void add_frontStencilCompareMask(uint32_t frontStencilCompareMask) {
    fbb_.AddElement<uint32_t>(DynamicRenderStates::VT_FRONTSTENCILCOMPAREMASK, frontStencilCompareMask, 0);
  }
  void add_backStencilCompareMask(uint32_t backStencilCompareMask) {
    fbb_.AddElement<uint32_t>(DynamicRenderStates::VT_BACKSTENCILCOMPAREMASK, backStencilCompareMask, 0);
  }
  void add_frontStencilWriteMask(uint32_t frontStencilWriteMask) {
    fbb_.AddElement<uint32_t>(DynamicRenderStates::VT_FRONTSTENCILWRITEMASK, frontStencilWriteMask, 0);
  }
  void add_backStencilWriteMask(uint32_t backStencilWriteMask) {
    fbb_.AddElement<uint32_t>(DynamicRenderStates::VT_BACKSTENCILWRITEMASK, backStencilWriteMask, 0);
  }
  void add_frontStencilReference(uint32_t frontStencilReference) {
    fbb_.AddElement<uint32_t>(DynamicRenderStates::VT_FRONTSTENCILREFERENCE, frontStencilReference, 0);
  }
  void add_backStencilReference(uint32_t backStencilReference) {
    fbb_.AddElement<uint32_t>(DynamicRenderStates::VT_BACKSTENCILREFERENCE, backStencilReference, 0);
  }
  explicit DynamicRenderStatesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DynamicRenderStates> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DynamicRenderStates>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DynamicRenderStates> CreateDynamicRenderStates(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    float lineWidth = 0.0f,
    float depthBiasConstantFactor = 0.0f,
    float depthBiasClamp = 0.0f,
    float depthBiasSlopeFactor = 0.0f,
    const DeepSeaScene::Color4f *blendConstants = nullptr,
    const DeepSeaScene::Vector2f *depthBounds = nullptr,
    uint32_t frontStencilCompareMask = 0,
    uint32_t backStencilCompareMask = 0,
    uint32_t frontStencilWriteMask = 0,
    uint32_t backStencilWriteMask = 0,
    uint32_t frontStencilReference = 0,
    uint32_t backStencilReference = 0) {
  DynamicRenderStatesBuilder builder_(_fbb);
  builder_.add_backStencilReference(backStencilReference);
  builder_.add_frontStencilReference(frontStencilReference);
  builder_.add_backStencilWriteMask(backStencilWriteMask);
  builder_.add_frontStencilWriteMask(frontStencilWriteMask);
  builder_.add_backStencilCompareMask(backStencilCompareMask);
  builder_.add_frontStencilCompareMask(frontStencilCompareMask);
  builder_.add_depthBounds(depthBounds);
  builder_.add_blendConstants(blendConstants);
  builder_.add_depthBiasSlopeFactor(depthBiasSlopeFactor);
  builder_.add_depthBiasClamp(depthBiasClamp);
  builder_.add_depthBiasConstantFactor(depthBiasConstantFactor);
  builder_.add_lineWidth(lineWidth);
  return builder_.Finish();
}

inline bool VerifyFileOrData(::flatbuffers::Verifier &verifier, const void *obj, FileOrData type) {
  switch (type) {
    case FileOrData::NONE: {
      return true;
    }
    case FileOrData::FileReference: {
      auto ptr = reinterpret_cast<const DeepSeaScene::FileReference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FileOrData::RelativePathReference: {
      auto ptr = reinterpret_cast<const DeepSeaScene::RelativePathReference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case FileOrData::RawData: {
      auto ptr = reinterpret_cast<const DeepSeaScene::RawData *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyFileOrDataVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<FileOrData> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyFileOrData(
        verifier,  values->Get(i), types->GetEnum<FileOrData>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace DeepSeaScene

#endif  // FLATBUFFERS_GENERATED_SCENECOMMON_DEEPSEASCENE_H_
