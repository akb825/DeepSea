// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCENECOMMON_DEEPSEASCENE_H_
#define FLATBUFFERS_GENERATED_SCENECOMMON_DEEPSEASCENE_H_

#include "flatbuffers/flatbuffers.h"

namespace DeepSeaScene {

struct ObjectData;

struct Vector2f;

struct Vector3f;

struct Vector4f;

struct Color4f;

struct AlignedBox3f;

struct Matrix33f;

struct Matrix44f;

struct OrientedBox3f;

struct FileReference;

enum class FileResourceType : uint8_t {
  Embedded = 0,
  Installed = 1,
  Dynamic = 2,
  External = 3,
  MIN = Embedded,
  MAX = External
};

inline const FileResourceType (&EnumValuesFileResourceType())[4] {
  static const FileResourceType values[] = {
    FileResourceType::Embedded,
    FileResourceType::Installed,
    FileResourceType::Dynamic,
    FileResourceType::External
  };
  return values;
}

inline const char * const *EnumNamesFileResourceType() {
  static const char * const names[] = {
    "Embedded",
    "Installed",
    "Dynamic",
    "External",
    nullptr
  };
  return names;
}

inline const char *EnumNameFileResourceType(FileResourceType e) {
  if (e < FileResourceType::Embedded || e > FileResourceType::External) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFileResourceType()[index];
}

enum class TextureFormat : uint8_t {
  R4G4 = 0,
  R4G4B4A4 = 1,
  B4G4R4A4 = 2,
  A4R4G4B4 = 3,
  R5G6B5 = 4,
  B5G6R5 = 5,
  R5G5B5A1 = 6,
  B5G5R5A1 = 7,
  A1R5G5B5 = 8,
  R8 = 9,
  R8G8 = 10,
  R8G8B8 = 11,
  B8G8R8 = 12,
  R8G8B8A8 = 13,
  B8G8R8A8 = 14,
  A8B8G8R8 = 15,
  A2R10G10B10 = 16,
  A2B10G10R10 = 17,
  R16 = 18,
  R16G16 = 19,
  R16G16B16 = 20,
  R16G16B16A16 = 21,
  R32 = 22,
  R32G32 = 23,
  R32G32B32 = 24,
  R32G32B32A32 = 25,
  R64 = 26,
  R64G64 = 27,
  R64G64B64 = 28,
  R64G64B64A64 = 29,
  B10G11R11_UFloat = 30,
  E5B9G9R9_UFloat = 31,
  D16 = 32,
  X8D24 = 33,
  D32_Float = 34,
  S8 = 35,
  D16S8 = 36,
  D24S8 = 37,
  D32S8_Float = 38,
  BC1_RGB = 39,
  BC1_RGBA = 40,
  BC2 = 41,
  BC3 = 42,
  BC4 = 43,
  BC5 = 44,
  BC6H = 45,
  BC7 = 46,
  ETC1 = 47,
  ETC2_R8G8B8 = 48,
  ETC2_R8G8B8A1 = 49,
  ETC2_R8G8B8A8 = 50,
  EAC_R11 = 51,
  EAC_R11G11 = 52,
  ASTC_4x4 = 53,
  ASTC_5x4 = 54,
  ASTC_5x5 = 55,
  ASTC_6x5 = 56,
  ASTC_6x6 = 57,
  ASTC_8x5 = 58,
  ASTC_8x6 = 59,
  ASTC_8x8 = 60,
  ASTC_10x5 = 61,
  ASTC_10x6 = 62,
  ASTC_10x8 = 63,
  ASTC_10x10 = 64,
  ASTC_12x10 = 65,
  ASTC_12x12 = 66,
  PVRTC1_RGB_2BPP = 67,
  PVRTC1_RGBA_2BPP = 68,
  PVRTC1_RGB_4BPP = 69,
  PVRTC1_RGBA_4BPP = 70,
  PVRTC2_RGBA_2BPP = 71,
  PVRTC2_RGBA_4BPP = 72,
  MIN = R4G4,
  MAX = PVRTC2_RGBA_4BPP
};

inline const TextureFormat (&EnumValuesTextureFormat())[73] {
  static const TextureFormat values[] = {
    TextureFormat::R4G4,
    TextureFormat::R4G4B4A4,
    TextureFormat::B4G4R4A4,
    TextureFormat::A4R4G4B4,
    TextureFormat::R5G6B5,
    TextureFormat::B5G6R5,
    TextureFormat::R5G5B5A1,
    TextureFormat::B5G5R5A1,
    TextureFormat::A1R5G5B5,
    TextureFormat::R8,
    TextureFormat::R8G8,
    TextureFormat::R8G8B8,
    TextureFormat::B8G8R8,
    TextureFormat::R8G8B8A8,
    TextureFormat::B8G8R8A8,
    TextureFormat::A8B8G8R8,
    TextureFormat::A2R10G10B10,
    TextureFormat::A2B10G10R10,
    TextureFormat::R16,
    TextureFormat::R16G16,
    TextureFormat::R16G16B16,
    TextureFormat::R16G16B16A16,
    TextureFormat::R32,
    TextureFormat::R32G32,
    TextureFormat::R32G32B32,
    TextureFormat::R32G32B32A32,
    TextureFormat::R64,
    TextureFormat::R64G64,
    TextureFormat::R64G64B64,
    TextureFormat::R64G64B64A64,
    TextureFormat::B10G11R11_UFloat,
    TextureFormat::E5B9G9R9_UFloat,
    TextureFormat::D16,
    TextureFormat::X8D24,
    TextureFormat::D32_Float,
    TextureFormat::S8,
    TextureFormat::D16S8,
    TextureFormat::D24S8,
    TextureFormat::D32S8_Float,
    TextureFormat::BC1_RGB,
    TextureFormat::BC1_RGBA,
    TextureFormat::BC2,
    TextureFormat::BC3,
    TextureFormat::BC4,
    TextureFormat::BC5,
    TextureFormat::BC6H,
    TextureFormat::BC7,
    TextureFormat::ETC1,
    TextureFormat::ETC2_R8G8B8,
    TextureFormat::ETC2_R8G8B8A1,
    TextureFormat::ETC2_R8G8B8A8,
    TextureFormat::EAC_R11,
    TextureFormat::EAC_R11G11,
    TextureFormat::ASTC_4x4,
    TextureFormat::ASTC_5x4,
    TextureFormat::ASTC_5x5,
    TextureFormat::ASTC_6x5,
    TextureFormat::ASTC_6x6,
    TextureFormat::ASTC_8x5,
    TextureFormat::ASTC_8x6,
    TextureFormat::ASTC_8x8,
    TextureFormat::ASTC_10x5,
    TextureFormat::ASTC_10x6,
    TextureFormat::ASTC_10x8,
    TextureFormat::ASTC_10x10,
    TextureFormat::ASTC_12x10,
    TextureFormat::ASTC_12x12,
    TextureFormat::PVRTC1_RGB_2BPP,
    TextureFormat::PVRTC1_RGBA_2BPP,
    TextureFormat::PVRTC1_RGB_4BPP,
    TextureFormat::PVRTC1_RGBA_4BPP,
    TextureFormat::PVRTC2_RGBA_2BPP,
    TextureFormat::PVRTC2_RGBA_4BPP
  };
  return values;
}

inline const char * const *EnumNamesTextureFormat() {
  static const char * const names[] = {
    "R4G4",
    "R4G4B4A4",
    "B4G4R4A4",
    "A4R4G4B4",
    "R5G6B5",
    "B5G6R5",
    "R5G5B5A1",
    "B5G5R5A1",
    "A1R5G5B5",
    "R8",
    "R8G8",
    "R8G8B8",
    "B8G8R8",
    "R8G8B8A8",
    "B8G8R8A8",
    "A8B8G8R8",
    "A2R10G10B10",
    "A2B10G10R10",
    "R16",
    "R16G16",
    "R16G16B16",
    "R16G16B16A16",
    "R32",
    "R32G32",
    "R32G32B32",
    "R32G32B32A32",
    "R64",
    "R64G64",
    "R64G64B64",
    "R64G64B64A64",
    "B10G11R11_UFloat",
    "E5B9G9R9_UFloat",
    "D16",
    "X8D24",
    "D32_Float",
    "S8",
    "D16S8",
    "D24S8",
    "D32S8_Float",
    "BC1_RGB",
    "BC1_RGBA",
    "BC2",
    "BC3",
    "BC4",
    "BC5",
    "BC6H",
    "BC7",
    "ETC1",
    "ETC2_R8G8B8",
    "ETC2_R8G8B8A1",
    "ETC2_R8G8B8A8",
    "EAC_R11",
    "EAC_R11G11",
    "ASTC_4x4",
    "ASTC_5x4",
    "ASTC_5x5",
    "ASTC_6x5",
    "ASTC_6x6",
    "ASTC_8x5",
    "ASTC_8x6",
    "ASTC_8x8",
    "ASTC_10x5",
    "ASTC_10x6",
    "ASTC_10x8",
    "ASTC_10x10",
    "ASTC_12x10",
    "ASTC_12x12",
    "PVRTC1_RGB_2BPP",
    "PVRTC1_RGBA_2BPP",
    "PVRTC1_RGB_4BPP",
    "PVRTC1_RGBA_4BPP",
    "PVRTC2_RGBA_2BPP",
    "PVRTC2_RGBA_4BPP",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureFormat(TextureFormat e) {
  if (e < TextureFormat::R4G4 || e > TextureFormat::PVRTC2_RGBA_4BPP) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureFormat()[index];
}

enum class TextureDim : uint8_t {
  Dim1D = 0,
  Dim2D = 1,
  Dim3D = 2,
  DimCube = 3,
  MIN = Dim1D,
  MAX = DimCube
};

inline const TextureDim (&EnumValuesTextureDim())[4] {
  static const TextureDim values[] = {
    TextureDim::Dim1D,
    TextureDim::Dim2D,
    TextureDim::Dim3D,
    TextureDim::DimCube
  };
  return values;
}

inline const char * const *EnumNamesTextureDim() {
  static const char * const names[] = {
    "Dim1D",
    "Dim2D",
    "Dim3D",
    "DimCube",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextureDim(TextureDim e) {
  if (e < TextureDim::Dim1D || e > TextureDim::DimCube) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextureDim()[index];
}

enum class CubeFace : uint8_t {
  PosX = 0,
  NegX = 1,
  PosY = 2,
  NegY = 3,
  PosZ = 4,
  NegZ = 5,
  MIN = PosX,
  MAX = NegZ
};

inline const CubeFace (&EnumValuesCubeFace())[6] {
  static const CubeFace values[] = {
    CubeFace::PosX,
    CubeFace::NegX,
    CubeFace::PosY,
    CubeFace::NegY,
    CubeFace::PosZ,
    CubeFace::NegZ
  };
  return values;
}

inline const char * const *EnumNamesCubeFace() {
  static const char * const names[] = {
    "PosX",
    "NegX",
    "PosY",
    "NegY",
    "PosZ",
    "NegZ",
    nullptr
  };
  return names;
}

inline const char *EnumNameCubeFace(CubeFace e) {
  if (e < CubeFace::PosX || e > CubeFace::NegZ) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCubeFace()[index];
}

enum class MaterialType : uint8_t {
  Float = 0,
  Vec2 = 1,
  Vec3 = 2,
  Vec4 = 3,
  Double = 4,
  DVec2 = 5,
  DVec3 = 6,
  DVec4 = 7,
  Int = 8,
  IVec2 = 9,
  IVec3 = 10,
  IVec4 = 11,
  UInt = 12,
  UVec2 = 13,
  UVec3 = 14,
  UVec4 = 15,
  Bool = 16,
  BVec2 = 17,
  BVec3 = 18,
  BVec4 = 19,
  Mat2 = 20,
  Mat3 = 21,
  Mat4 = 22,
  Mat2x3 = 23,
  Mat2x4 = 24,
  Mat3x2 = 25,
  Mat3x4 = 26,
  Mat4x2 = 27,
  Mat4x3 = 28,
  DMat2 = 29,
  DMat3 = 30,
  DMat4 = 31,
  DMat2x3 = 32,
  DMat2x4 = 33,
  DMat3x2 = 34,
  DMat3x4 = 35,
  DMat4x2 = 36,
  DMat4x3 = 37,
  Texture = 38,
  Image = 39,
  SubpassInput = 40,
  TextureBuffer = 41,
  ImageBuffer = 42,
  VariableGroup = 43,
  UniformBlock = 44,
  UniformBuffer = 45,
  MIN = Float,
  MAX = UniformBuffer
};

inline const MaterialType (&EnumValuesMaterialType())[46] {
  static const MaterialType values[] = {
    MaterialType::Float,
    MaterialType::Vec2,
    MaterialType::Vec3,
    MaterialType::Vec4,
    MaterialType::Double,
    MaterialType::DVec2,
    MaterialType::DVec3,
    MaterialType::DVec4,
    MaterialType::Int,
    MaterialType::IVec2,
    MaterialType::IVec3,
    MaterialType::IVec4,
    MaterialType::UInt,
    MaterialType::UVec2,
    MaterialType::UVec3,
    MaterialType::UVec4,
    MaterialType::Bool,
    MaterialType::BVec2,
    MaterialType::BVec3,
    MaterialType::BVec4,
    MaterialType::Mat2,
    MaterialType::Mat3,
    MaterialType::Mat4,
    MaterialType::Mat2x3,
    MaterialType::Mat2x4,
    MaterialType::Mat3x2,
    MaterialType::Mat3x4,
    MaterialType::Mat4x2,
    MaterialType::Mat4x3,
    MaterialType::DMat2,
    MaterialType::DMat3,
    MaterialType::DMat4,
    MaterialType::DMat2x3,
    MaterialType::DMat2x4,
    MaterialType::DMat3x2,
    MaterialType::DMat3x4,
    MaterialType::DMat4x2,
    MaterialType::DMat4x3,
    MaterialType::Texture,
    MaterialType::Image,
    MaterialType::SubpassInput,
    MaterialType::TextureBuffer,
    MaterialType::ImageBuffer,
    MaterialType::VariableGroup,
    MaterialType::UniformBlock,
    MaterialType::UniformBuffer
  };
  return values;
}

inline const char * const *EnumNamesMaterialType() {
  static const char * const names[] = {
    "Float",
    "Vec2",
    "Vec3",
    "Vec4",
    "Double",
    "DVec2",
    "DVec3",
    "DVec4",
    "Int",
    "IVec2",
    "IVec3",
    "IVec4",
    "UInt",
    "UVec2",
    "UVec3",
    "UVec4",
    "Bool",
    "BVec2",
    "BVec3",
    "BVec4",
    "Mat2",
    "Mat3",
    "Mat4",
    "Mat2x3",
    "Mat2x4",
    "Mat3x2",
    "Mat3x4",
    "Mat4x2",
    "Mat4x3",
    "DMat2",
    "DMat3",
    "DMat4",
    "DMat2x3",
    "DMat2x4",
    "DMat3x2",
    "DMat3x4",
    "DMat4x2",
    "DMat4x3",
    "Texture",
    "Image",
    "SubpassInput",
    "TextureBuffer",
    "ImageBuffer",
    "VariableGroup",
    "UniformBlock",
    "UniformBuffer",
    nullptr
  };
  return names;
}

inline const char *EnumNameMaterialType(MaterialType e) {
  if (e < MaterialType::Float || e > MaterialType::UniformBuffer) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMaterialType()[index];
}

enum class VertexElementFormat : uint8_t {
  Unset = 0,
  X8 = 1,
  X8Y8 = 2,
  X8Y8Z8 = 3,
  X8Y8Z8W8 = 4,
  W2X10Y10Z10 = 5,
  W2Z10Y10X10 = 6,
  X16 = 7,
  X16Y16 = 8,
  X16Y16Z16 = 9,
  X16Y16Z16W16 = 10,
  X32 = 11,
  X32Y32 = 12,
  X32Y32Z32 = 13,
  X32Y32Z32W32 = 14,
  X64 = 15,
  X64Y64 = 16,
  X64Y64Z64 = 17,
  X64Y64Z64W64 = 18,
  MIN = Unset,
  MAX = X64Y64Z64W64
};

inline const VertexElementFormat (&EnumValuesVertexElementFormat())[19] {
  static const VertexElementFormat values[] = {
    VertexElementFormat::Unset,
    VertexElementFormat::X8,
    VertexElementFormat::X8Y8,
    VertexElementFormat::X8Y8Z8,
    VertexElementFormat::X8Y8Z8W8,
    VertexElementFormat::W2X10Y10Z10,
    VertexElementFormat::W2Z10Y10X10,
    VertexElementFormat::X16,
    VertexElementFormat::X16Y16,
    VertexElementFormat::X16Y16Z16,
    VertexElementFormat::X16Y16Z16W16,
    VertexElementFormat::X32,
    VertexElementFormat::X32Y32,
    VertexElementFormat::X32Y32Z32,
    VertexElementFormat::X32Y32Z32W32,
    VertexElementFormat::X64,
    VertexElementFormat::X64Y64,
    VertexElementFormat::X64Y64Z64,
    VertexElementFormat::X64Y64Z64W64
  };
  return values;
}

inline const char * const *EnumNamesVertexElementFormat() {
  static const char * const names[] = {
    "Unset",
    "X8",
    "X8Y8",
    "X8Y8Z8",
    "X8Y8Z8W8",
    "W2X10Y10Z10",
    "W2Z10Y10X10",
    "X16",
    "X16Y16",
    "X16Y16Z16",
    "X16Y16Z16W16",
    "X32",
    "X32Y32",
    "X32Y32Z32",
    "X32Y32Z32W32",
    "X64",
    "X64Y64",
    "X64Y64Z64",
    "X64Y64Z64W64",
    nullptr
  };
  return names;
}

inline const char *EnumNameVertexElementFormat(VertexElementFormat e) {
  if (e < VertexElementFormat::Unset || e > VertexElementFormat::X64Y64Z64W64) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVertexElementFormat()[index];
}

enum class FormatDecoration : uint8_t {
  UNorm = 0,
  SNorm = 1,
  UScaled = 2,
  SScaled = 3,
  UInt = 4,
  SInt = 5,
  Float = 6,
  UFloat = 7,
  SRGB = 8,
  MIN = UNorm,
  MAX = SRGB
};

inline const FormatDecoration (&EnumValuesFormatDecoration())[9] {
  static const FormatDecoration values[] = {
    FormatDecoration::UNorm,
    FormatDecoration::SNorm,
    FormatDecoration::UScaled,
    FormatDecoration::SScaled,
    FormatDecoration::UInt,
    FormatDecoration::SInt,
    FormatDecoration::Float,
    FormatDecoration::UFloat,
    FormatDecoration::SRGB
  };
  return values;
}

inline const char * const *EnumNamesFormatDecoration() {
  static const char * const names[] = {
    "UNorm",
    "SNorm",
    "UScaled",
    "SScaled",
    "UInt",
    "SInt",
    "Float",
    "UFloat",
    "SRGB",
    nullptr
  };
  return names;
}

inline const char *EnumNameFormatDecoration(FormatDecoration e) {
  if (e < FormatDecoration::UNorm || e > FormatDecoration::SRGB) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFormatDecoration()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector2f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vector2f() {
    memset(static_cast<void *>(this), 0, sizeof(Vector2f));
  }
  Vector2f(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vector2f, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector3f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector3f() {
    memset(static_cast<void *>(this), 0, sizeof(Vector3f));
  }
  Vector3f(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vector3f, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector4f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vector4f() {
    memset(static_cast<void *>(this), 0, sizeof(Vector4f));
  }
  Vector4f(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
};
FLATBUFFERS_STRUCT_END(Vector4f, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Color4f FLATBUFFERS_FINAL_CLASS {
 private:
  float red_;
  float green_;
  float blue_;
  float alpha_;

 public:
  Color4f() {
    memset(static_cast<void *>(this), 0, sizeof(Color4f));
  }
  Color4f(float _red, float _green, float _blue, float _alpha)
      : red_(flatbuffers::EndianScalar(_red)),
        green_(flatbuffers::EndianScalar(_green)),
        blue_(flatbuffers::EndianScalar(_blue)),
        alpha_(flatbuffers::EndianScalar(_alpha)) {
  }
  float red() const {
    return flatbuffers::EndianScalar(red_);
  }
  float green() const {
    return flatbuffers::EndianScalar(green_);
  }
  float blue() const {
    return flatbuffers::EndianScalar(blue_);
  }
  float alpha() const {
    return flatbuffers::EndianScalar(alpha_);
  }
};
FLATBUFFERS_STRUCT_END(Color4f, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) AlignedBox3f FLATBUFFERS_FINAL_CLASS {
 private:
  Vector3f min_;
  Vector3f max_;

 public:
  AlignedBox3f() {
    memset(static_cast<void *>(this), 0, sizeof(AlignedBox3f));
  }
  AlignedBox3f(const Vector3f &_min, const Vector3f &_max)
      : min_(_min),
        max_(_max) {
  }
  const Vector3f &min() const {
    return min_;
  }
  const Vector3f &max() const {
    return max_;
  }
};
FLATBUFFERS_STRUCT_END(AlignedBox3f, 24);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Matrix33f FLATBUFFERS_FINAL_CLASS {
 private:
  Vector3f column0_;
  Vector3f column1_;
  Vector3f column2_;

 public:
  Matrix33f() {
    memset(static_cast<void *>(this), 0, sizeof(Matrix33f));
  }
  Matrix33f(const Vector3f &_column0, const Vector3f &_column1, const Vector3f &_column2)
      : column0_(_column0),
        column1_(_column1),
        column2_(_column2) {
  }
  const Vector3f &column0() const {
    return column0_;
  }
  const Vector3f &column1() const {
    return column1_;
  }
  const Vector3f &column2() const {
    return column2_;
  }
};
FLATBUFFERS_STRUCT_END(Matrix33f, 36);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Matrix44f FLATBUFFERS_FINAL_CLASS {
 private:
  Vector4f column0_;
  Vector4f column1_;
  Vector4f column2_;
  Vector4f column3_;

 public:
  Matrix44f() {
    memset(static_cast<void *>(this), 0, sizeof(Matrix44f));
  }
  Matrix44f(const Vector4f &_column0, const Vector4f &_column1, const Vector4f &_column2, const Vector4f &_column3)
      : column0_(_column0),
        column1_(_column1),
        column2_(_column2),
        column3_(_column3) {
  }
  const Vector4f &column0() const {
    return column0_;
  }
  const Vector4f &column1() const {
    return column1_;
  }
  const Vector4f &column2() const {
    return column2_;
  }
  const Vector4f &column3() const {
    return column3_;
  }
};
FLATBUFFERS_STRUCT_END(Matrix44f, 64);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) OrientedBox3f FLATBUFFERS_FINAL_CLASS {
 private:
  Matrix33f orientation_;
  Vector3f center_;
  Vector3f halfExtents_;

 public:
  OrientedBox3f() {
    memset(static_cast<void *>(this), 0, sizeof(OrientedBox3f));
  }
  OrientedBox3f(const Matrix33f &_orientation, const Vector3f &_center, const Vector3f &_halfExtents)
      : orientation_(_orientation),
        center_(_center),
        halfExtents_(_halfExtents) {
  }
  const Matrix33f &orientation() const {
    return orientation_;
  }
  const Vector3f &center() const {
    return center_;
  }
  const Vector3f &halfExtents() const {
    return halfExtents_;
  }
};
FLATBUFFERS_STRUCT_END(OrientedBox3f, 60);

struct ObjectData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct ObjectDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(ObjectData::VT_TYPE, type);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(ObjectData::VT_DATA, data);
  }
  explicit ObjectDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ObjectDataBuilder &operator=(const ObjectDataBuilder &);
  flatbuffers::Offset<ObjectData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectData>(end);
    fbb_.Required(o, ObjectData::VT_TYPE);
    fbb_.Required(o, ObjectData::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<ObjectData> CreateObjectData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  ObjectDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<ObjectData> CreateObjectDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return DeepSeaScene::CreateObjectData(
      _fbb,
      type__,
      data__);
}

struct FileReference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_PATH = 6
  };
  FileResourceType type() const {
    return static_cast<FileResourceType>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const flatbuffers::String *path() const {
    return GetPointer<const flatbuffers::String *>(VT_PATH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffsetRequired(verifier, VT_PATH) &&
           verifier.VerifyString(path()) &&
           verifier.EndTable();
  }
};

struct FileReferenceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(FileResourceType type) {
    fbb_.AddElement<uint8_t>(FileReference::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_path(flatbuffers::Offset<flatbuffers::String> path) {
    fbb_.AddOffset(FileReference::VT_PATH, path);
  }
  explicit FileReferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FileReferenceBuilder &operator=(const FileReferenceBuilder &);
  flatbuffers::Offset<FileReference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileReference>(end);
    fbb_.Required(o, FileReference::VT_PATH);
    return o;
  }
};

inline flatbuffers::Offset<FileReference> CreateFileReference(
    flatbuffers::FlatBufferBuilder &_fbb,
    FileResourceType type = FileResourceType::Embedded,
    flatbuffers::Offset<flatbuffers::String> path = 0) {
  FileReferenceBuilder builder_(_fbb);
  builder_.add_path(path);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileReference> CreateFileReferenceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    FileResourceType type = FileResourceType::Embedded,
    const char *path = nullptr) {
  auto path__ = path ? _fbb.CreateString(path) : 0;
  return DeepSeaScene::CreateFileReference(
      _fbb,
      type,
      path__);
}

}  // namespace DeepSeaScene

#endif  // FLATBUFFERS_GENERATED_SCENECOMMON_DEEPSEASCENE_H_
