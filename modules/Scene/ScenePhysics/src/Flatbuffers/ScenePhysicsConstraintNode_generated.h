// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCENEPHYSICSCONSTRAINTNODE_DEEPSEASCENEPHYSICS_H_
#define FLATBUFFERS_GENERATED_SCENEPHYSICSCONSTRAINTNODE_DEEPSEASCENEPHYSICS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

namespace DeepSeaScenePhysics {

struct InstanceReference;
struct InstanceReferenceBuilder;

struct ActorResourceReference;
struct ActorResourceReferenceBuilder;

struct ConstraintNodeReference;
struct ConstraintNodeReferenceBuilder;

struct ConstraintResourceReference;
struct ConstraintResourceReferenceBuilder;

struct ConstraintNode;
struct ConstraintNodeBuilder;

enum class ActorReference : uint8_t {
  NONE = 0,
  InstanceReference = 1,
  ActorResourceReference = 2,
  MIN = NONE,
  MAX = ActorResourceReference
};

inline const ActorReference (&EnumValuesActorReference())[3] {
  static const ActorReference values[] = {
    ActorReference::NONE,
    ActorReference::InstanceReference,
    ActorReference::ActorResourceReference
  };
  return values;
}

inline const char * const *EnumNamesActorReference() {
  static const char * const names[4] = {
    "NONE",
    "InstanceReference",
    "ActorResourceReference",
    nullptr
  };
  return names;
}

inline const char *EnumNameActorReference(ActorReference e) {
  if (::flatbuffers::IsOutRange(e, ActorReference::NONE, ActorReference::ActorResourceReference)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActorReference()[index];
}

template<typename T> struct ActorReferenceTraits {
  static const ActorReference enum_value = ActorReference::NONE;
};

template<> struct ActorReferenceTraits<DeepSeaScenePhysics::InstanceReference> {
  static const ActorReference enum_value = ActorReference::InstanceReference;
};

template<> struct ActorReferenceTraits<DeepSeaScenePhysics::ActorResourceReference> {
  static const ActorReference enum_value = ActorReference::ActorResourceReference;
};

template <bool B = false>
bool VerifyActorReference(::flatbuffers::VerifierTemplate<B> &verifier, const void *obj, ActorReference type);
template <bool B = false>
bool VerifyActorReferenceVector(::flatbuffers::VerifierTemplate<B> &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ActorReference> *types);

enum class ConstraintReference : uint8_t {
  NONE = 0,
  InstanceReference = 1,
  ConstraintNodeReference = 2,
  ConstraintResourceReference = 3,
  MIN = NONE,
  MAX = ConstraintResourceReference
};

inline const ConstraintReference (&EnumValuesConstraintReference())[4] {
  static const ConstraintReference values[] = {
    ConstraintReference::NONE,
    ConstraintReference::InstanceReference,
    ConstraintReference::ConstraintNodeReference,
    ConstraintReference::ConstraintResourceReference
  };
  return values;
}

inline const char * const *EnumNamesConstraintReference() {
  static const char * const names[5] = {
    "NONE",
    "InstanceReference",
    "ConstraintNodeReference",
    "ConstraintResourceReference",
    nullptr
  };
  return names;
}

inline const char *EnumNameConstraintReference(ConstraintReference e) {
  if (::flatbuffers::IsOutRange(e, ConstraintReference::NONE, ConstraintReference::ConstraintResourceReference)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesConstraintReference()[index];
}

template<typename T> struct ConstraintReferenceTraits {
  static const ConstraintReference enum_value = ConstraintReference::NONE;
};

template<> struct ConstraintReferenceTraits<DeepSeaScenePhysics::InstanceReference> {
  static const ConstraintReference enum_value = ConstraintReference::InstanceReference;
};

template<> struct ConstraintReferenceTraits<DeepSeaScenePhysics::ConstraintNodeReference> {
  static const ConstraintReference enum_value = ConstraintReference::ConstraintNodeReference;
};

template<> struct ConstraintReferenceTraits<DeepSeaScenePhysics::ConstraintResourceReference> {
  static const ConstraintReference enum_value = ConstraintReference::ConstraintResourceReference;
};

template <bool B = false>
bool VerifyConstraintReference(::flatbuffers::VerifierTemplate<B> &verifier, const void *obj, ConstraintReference type);
template <bool B = false>
bool VerifyConstraintReferenceVector(::flatbuffers::VerifierTemplate<B> &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ConstraintReference> *types);

struct InstanceReference FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef InstanceReferenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROOTNODE = 4,
    VT_RIGIDBODYGROUPNODE = 6,
    VT_INSTANCE = 8
  };
  const ::flatbuffers::String *rootNode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ROOTNODE);
  }
  const ::flatbuffers::String *rigidBodyGroupNode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_RIGIDBODYGROUPNODE);
  }
  const ::flatbuffers::String *instance() const {
    return GetPointer<const ::flatbuffers::String *>(VT_INSTANCE);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOTNODE) &&
           verifier.VerifyString(rootNode()) &&
           VerifyOffsetRequired(verifier, VT_RIGIDBODYGROUPNODE) &&
           verifier.VerifyString(rigidBodyGroupNode()) &&
           VerifyOffsetRequired(verifier, VT_INSTANCE) &&
           verifier.VerifyString(instance()) &&
           verifier.EndTable();
  }
};

struct InstanceReferenceBuilder {
  typedef InstanceReference Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rootNode(::flatbuffers::Offset<::flatbuffers::String> rootNode) {
    fbb_.AddOffset(InstanceReference::VT_ROOTNODE, rootNode);
  }
  void add_rigidBodyGroupNode(::flatbuffers::Offset<::flatbuffers::String> rigidBodyGroupNode) {
    fbb_.AddOffset(InstanceReference::VT_RIGIDBODYGROUPNODE, rigidBodyGroupNode);
  }
  void add_instance(::flatbuffers::Offset<::flatbuffers::String> instance) {
    fbb_.AddOffset(InstanceReference::VT_INSTANCE, instance);
  }
  explicit InstanceReferenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<InstanceReference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<InstanceReference>(end);
    fbb_.Required(o, InstanceReference::VT_RIGIDBODYGROUPNODE);
    fbb_.Required(o, InstanceReference::VT_INSTANCE);
    return o;
  }
};

inline ::flatbuffers::Offset<InstanceReference> CreateInstanceReference(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> rootNode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> rigidBodyGroupNode = 0,
    ::flatbuffers::Offset<::flatbuffers::String> instance = 0) {
  InstanceReferenceBuilder builder_(_fbb);
  builder_.add_instance(instance);
  builder_.add_rigidBodyGroupNode(rigidBodyGroupNode);
  builder_.add_rootNode(rootNode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<InstanceReference> CreateInstanceReferenceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *rootNode = nullptr,
    const char *rigidBodyGroupNode = nullptr,
    const char *instance = nullptr) {
  auto rootNode__ = rootNode ? _fbb.CreateString(rootNode) : 0;
  auto rigidBodyGroupNode__ = rigidBodyGroupNode ? _fbb.CreateString(rigidBodyGroupNode) : 0;
  auto instance__ = instance ? _fbb.CreateString(instance) : 0;
  return DeepSeaScenePhysics::CreateInstanceReference(
      _fbb,
      rootNode__,
      rigidBodyGroupNode__,
      instance__);
}

struct ActorResourceReference FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ActorResourceReferenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTOR = 4
  };
  const ::flatbuffers::String *actor() const {
    return GetPointer<const ::flatbuffers::String *>(VT_ACTOR);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ACTOR) &&
           verifier.VerifyString(actor()) &&
           verifier.EndTable();
  }
};

struct ActorResourceReferenceBuilder {
  typedef ActorResourceReference Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_actor(::flatbuffers::Offset<::flatbuffers::String> actor) {
    fbb_.AddOffset(ActorResourceReference::VT_ACTOR, actor);
  }
  explicit ActorResourceReferenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ActorResourceReference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ActorResourceReference>(end);
    fbb_.Required(o, ActorResourceReference::VT_ACTOR);
    return o;
  }
};

inline ::flatbuffers::Offset<ActorResourceReference> CreateActorResourceReference(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> actor = 0) {
  ActorResourceReferenceBuilder builder_(_fbb);
  builder_.add_actor(actor);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ActorResourceReference> CreateActorResourceReferenceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *actor = nullptr) {
  auto actor__ = actor ? _fbb.CreateString(actor) : 0;
  return DeepSeaScenePhysics::CreateActorResourceReference(
      _fbb,
      actor__);
}

struct ConstraintNodeReference FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConstraintNodeReferenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSTRAINTNODE = 4
  };
  const ::flatbuffers::String *constraintNode() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONSTRAINTNODE);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CONSTRAINTNODE) &&
           verifier.VerifyString(constraintNode()) &&
           verifier.EndTable();
  }
};

struct ConstraintNodeReferenceBuilder {
  typedef ConstraintNodeReference Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_constraintNode(::flatbuffers::Offset<::flatbuffers::String> constraintNode) {
    fbb_.AddOffset(ConstraintNodeReference::VT_CONSTRAINTNODE, constraintNode);
  }
  explicit ConstraintNodeReferenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConstraintNodeReference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConstraintNodeReference>(end);
    fbb_.Required(o, ConstraintNodeReference::VT_CONSTRAINTNODE);
    return o;
  }
};

inline ::flatbuffers::Offset<ConstraintNodeReference> CreateConstraintNodeReference(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> constraintNode = 0) {
  ConstraintNodeReferenceBuilder builder_(_fbb);
  builder_.add_constraintNode(constraintNode);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConstraintNodeReference> CreateConstraintNodeReferenceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *constraintNode = nullptr) {
  auto constraintNode__ = constraintNode ? _fbb.CreateString(constraintNode) : 0;
  return DeepSeaScenePhysics::CreateConstraintNodeReference(
      _fbb,
      constraintNode__);
}

struct ConstraintResourceReference FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConstraintResourceReferenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSTRAINT = 4
  };
  const ::flatbuffers::String *constraint() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONSTRAINT);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CONSTRAINT) &&
           verifier.VerifyString(constraint()) &&
           verifier.EndTable();
  }
};

struct ConstraintResourceReferenceBuilder {
  typedef ConstraintResourceReference Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_constraint(::flatbuffers::Offset<::flatbuffers::String> constraint) {
    fbb_.AddOffset(ConstraintResourceReference::VT_CONSTRAINT, constraint);
  }
  explicit ConstraintResourceReferenceBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConstraintResourceReference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConstraintResourceReference>(end);
    fbb_.Required(o, ConstraintResourceReference::VT_CONSTRAINT);
    return o;
  }
};

inline ::flatbuffers::Offset<ConstraintResourceReference> CreateConstraintResourceReference(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> constraint = 0) {
  ConstraintResourceReferenceBuilder builder_(_fbb);
  builder_.add_constraint(constraint);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConstraintResourceReference> CreateConstraintResourceReferenceDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *constraint = nullptr) {
  auto constraint__ = constraint ? _fbb.CreateString(constraint) : 0;
  return DeepSeaScenePhysics::CreateConstraintResourceReference(
      _fbb,
      constraint__);
}

struct ConstraintNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ConstraintNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONSTRAINT = 4,
    VT_FIRSTACTOR_TYPE = 6,
    VT_FIRSTACTOR = 8,
    VT_FIRSTCONNECTEDCONSTRAINT_TYPE = 10,
    VT_FIRSTCONNECTEDCONSTRAINT = 12,
    VT_SECONDACTOR_TYPE = 14,
    VT_SECONDACTOR = 16,
    VT_SECONDCONNECTEDCONSTRAINT_TYPE = 18,
    VT_SECONDCONNECTEDCONSTRAINT = 20,
    VT_ITEMLISTS = 22
  };
  const ::flatbuffers::String *constraint() const {
    return GetPointer<const ::flatbuffers::String *>(VT_CONSTRAINT);
  }
  DeepSeaScenePhysics::ActorReference firstActor_type() const {
    return static_cast<DeepSeaScenePhysics::ActorReference>(GetField<uint8_t>(VT_FIRSTACTOR_TYPE, 0));
  }
  const void *firstActor() const {
    return GetPointer<const void *>(VT_FIRSTACTOR);
  }
  template<typename T> const T *firstActor_as() const;
  const DeepSeaScenePhysics::InstanceReference *firstActor_as_InstanceReference() const {
    return firstActor_type() == DeepSeaScenePhysics::ActorReference::InstanceReference ? static_cast<const DeepSeaScenePhysics::InstanceReference *>(firstActor()) : nullptr;
  }
  const DeepSeaScenePhysics::ActorResourceReference *firstActor_as_ActorResourceReference() const {
    return firstActor_type() == DeepSeaScenePhysics::ActorReference::ActorResourceReference ? static_cast<const DeepSeaScenePhysics::ActorResourceReference *>(firstActor()) : nullptr;
  }
  DeepSeaScenePhysics::ConstraintReference firstConnectedConstraint_type() const {
    return static_cast<DeepSeaScenePhysics::ConstraintReference>(GetField<uint8_t>(VT_FIRSTCONNECTEDCONSTRAINT_TYPE, 0));
  }
  const void *firstConnectedConstraint() const {
    return GetPointer<const void *>(VT_FIRSTCONNECTEDCONSTRAINT);
  }
  template<typename T> const T *firstConnectedConstraint_as() const;
  const DeepSeaScenePhysics::InstanceReference *firstConnectedConstraint_as_InstanceReference() const {
    return firstConnectedConstraint_type() == DeepSeaScenePhysics::ConstraintReference::InstanceReference ? static_cast<const DeepSeaScenePhysics::InstanceReference *>(firstConnectedConstraint()) : nullptr;
  }
  const DeepSeaScenePhysics::ConstraintNodeReference *firstConnectedConstraint_as_ConstraintNodeReference() const {
    return firstConnectedConstraint_type() == DeepSeaScenePhysics::ConstraintReference::ConstraintNodeReference ? static_cast<const DeepSeaScenePhysics::ConstraintNodeReference *>(firstConnectedConstraint()) : nullptr;
  }
  const DeepSeaScenePhysics::ConstraintResourceReference *firstConnectedConstraint_as_ConstraintResourceReference() const {
    return firstConnectedConstraint_type() == DeepSeaScenePhysics::ConstraintReference::ConstraintResourceReference ? static_cast<const DeepSeaScenePhysics::ConstraintResourceReference *>(firstConnectedConstraint()) : nullptr;
  }
  DeepSeaScenePhysics::ActorReference secondActor_type() const {
    return static_cast<DeepSeaScenePhysics::ActorReference>(GetField<uint8_t>(VT_SECONDACTOR_TYPE, 0));
  }
  const void *secondActor() const {
    return GetPointer<const void *>(VT_SECONDACTOR);
  }
  template<typename T> const T *secondActor_as() const;
  const DeepSeaScenePhysics::InstanceReference *secondActor_as_InstanceReference() const {
    return secondActor_type() == DeepSeaScenePhysics::ActorReference::InstanceReference ? static_cast<const DeepSeaScenePhysics::InstanceReference *>(secondActor()) : nullptr;
  }
  const DeepSeaScenePhysics::ActorResourceReference *secondActor_as_ActorResourceReference() const {
    return secondActor_type() == DeepSeaScenePhysics::ActorReference::ActorResourceReference ? static_cast<const DeepSeaScenePhysics::ActorResourceReference *>(secondActor()) : nullptr;
  }
  DeepSeaScenePhysics::ConstraintReference secondConnectedConstraint_type() const {
    return static_cast<DeepSeaScenePhysics::ConstraintReference>(GetField<uint8_t>(VT_SECONDCONNECTEDCONSTRAINT_TYPE, 0));
  }
  const void *secondConnectedConstraint() const {
    return GetPointer<const void *>(VT_SECONDCONNECTEDCONSTRAINT);
  }
  template<typename T> const T *secondConnectedConstraint_as() const;
  const DeepSeaScenePhysics::InstanceReference *secondConnectedConstraint_as_InstanceReference() const {
    return secondConnectedConstraint_type() == DeepSeaScenePhysics::ConstraintReference::InstanceReference ? static_cast<const DeepSeaScenePhysics::InstanceReference *>(secondConnectedConstraint()) : nullptr;
  }
  const DeepSeaScenePhysics::ConstraintNodeReference *secondConnectedConstraint_as_ConstraintNodeReference() const {
    return secondConnectedConstraint_type() == DeepSeaScenePhysics::ConstraintReference::ConstraintNodeReference ? static_cast<const DeepSeaScenePhysics::ConstraintNodeReference *>(secondConnectedConstraint()) : nullptr;
  }
  const DeepSeaScenePhysics::ConstraintResourceReference *secondConnectedConstraint_as_ConstraintResourceReference() const {
    return secondConnectedConstraint_type() == DeepSeaScenePhysics::ConstraintReference::ConstraintResourceReference ? static_cast<const DeepSeaScenePhysics::ConstraintResourceReference *>(secondConnectedConstraint()) : nullptr;
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *itemLists() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>> *>(VT_ITEMLISTS);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_CONSTRAINT) &&
           verifier.VerifyString(constraint()) &&
           VerifyField<uint8_t>(verifier, VT_FIRSTACTOR_TYPE, 1) &&
           VerifyOffset(verifier, VT_FIRSTACTOR) &&
           VerifyActorReference(verifier, firstActor(), firstActor_type()) &&
           VerifyField<uint8_t>(verifier, VT_FIRSTCONNECTEDCONSTRAINT_TYPE, 1) &&
           VerifyOffset(verifier, VT_FIRSTCONNECTEDCONSTRAINT) &&
           VerifyConstraintReference(verifier, firstConnectedConstraint(), firstConnectedConstraint_type()) &&
           VerifyField<uint8_t>(verifier, VT_SECONDACTOR_TYPE, 1) &&
           VerifyOffset(verifier, VT_SECONDACTOR) &&
           VerifyActorReference(verifier, secondActor(), secondActor_type()) &&
           VerifyField<uint8_t>(verifier, VT_SECONDCONNECTEDCONSTRAINT_TYPE, 1) &&
           VerifyOffset(verifier, VT_SECONDCONNECTEDCONSTRAINT) &&
           VerifyConstraintReference(verifier, secondConnectedConstraint(), secondConnectedConstraint_type()) &&
           VerifyOffset(verifier, VT_ITEMLISTS) &&
           verifier.VerifyVector(itemLists()) &&
           verifier.VerifyVectorOfStrings(itemLists()) &&
           verifier.EndTable();
  }
};

template<> inline const DeepSeaScenePhysics::InstanceReference *ConstraintNode::firstActor_as<DeepSeaScenePhysics::InstanceReference>() const {
  return firstActor_as_InstanceReference();
}

template<> inline const DeepSeaScenePhysics::ActorResourceReference *ConstraintNode::firstActor_as<DeepSeaScenePhysics::ActorResourceReference>() const {
  return firstActor_as_ActorResourceReference();
}

template<> inline const DeepSeaScenePhysics::InstanceReference *ConstraintNode::firstConnectedConstraint_as<DeepSeaScenePhysics::InstanceReference>() const {
  return firstConnectedConstraint_as_InstanceReference();
}

template<> inline const DeepSeaScenePhysics::ConstraintNodeReference *ConstraintNode::firstConnectedConstraint_as<DeepSeaScenePhysics::ConstraintNodeReference>() const {
  return firstConnectedConstraint_as_ConstraintNodeReference();
}

template<> inline const DeepSeaScenePhysics::ConstraintResourceReference *ConstraintNode::firstConnectedConstraint_as<DeepSeaScenePhysics::ConstraintResourceReference>() const {
  return firstConnectedConstraint_as_ConstraintResourceReference();
}

template<> inline const DeepSeaScenePhysics::InstanceReference *ConstraintNode::secondActor_as<DeepSeaScenePhysics::InstanceReference>() const {
  return secondActor_as_InstanceReference();
}

template<> inline const DeepSeaScenePhysics::ActorResourceReference *ConstraintNode::secondActor_as<DeepSeaScenePhysics::ActorResourceReference>() const {
  return secondActor_as_ActorResourceReference();
}

template<> inline const DeepSeaScenePhysics::InstanceReference *ConstraintNode::secondConnectedConstraint_as<DeepSeaScenePhysics::InstanceReference>() const {
  return secondConnectedConstraint_as_InstanceReference();
}

template<> inline const DeepSeaScenePhysics::ConstraintNodeReference *ConstraintNode::secondConnectedConstraint_as<DeepSeaScenePhysics::ConstraintNodeReference>() const {
  return secondConnectedConstraint_as_ConstraintNodeReference();
}

template<> inline const DeepSeaScenePhysics::ConstraintResourceReference *ConstraintNode::secondConnectedConstraint_as<DeepSeaScenePhysics::ConstraintResourceReference>() const {
  return secondConnectedConstraint_as_ConstraintResourceReference();
}

struct ConstraintNodeBuilder {
  typedef ConstraintNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_constraint(::flatbuffers::Offset<::flatbuffers::String> constraint) {
    fbb_.AddOffset(ConstraintNode::VT_CONSTRAINT, constraint);
  }
  void add_firstActor_type(DeepSeaScenePhysics::ActorReference firstActor_type) {
    fbb_.AddElement<uint8_t>(ConstraintNode::VT_FIRSTACTOR_TYPE, static_cast<uint8_t>(firstActor_type), 0);
  }
  void add_firstActor(::flatbuffers::Offset<void> firstActor) {
    fbb_.AddOffset(ConstraintNode::VT_FIRSTACTOR, firstActor);
  }
  void add_firstConnectedConstraint_type(DeepSeaScenePhysics::ConstraintReference firstConnectedConstraint_type) {
    fbb_.AddElement<uint8_t>(ConstraintNode::VT_FIRSTCONNECTEDCONSTRAINT_TYPE, static_cast<uint8_t>(firstConnectedConstraint_type), 0);
  }
  void add_firstConnectedConstraint(::flatbuffers::Offset<void> firstConnectedConstraint) {
    fbb_.AddOffset(ConstraintNode::VT_FIRSTCONNECTEDCONSTRAINT, firstConnectedConstraint);
  }
  void add_secondActor_type(DeepSeaScenePhysics::ActorReference secondActor_type) {
    fbb_.AddElement<uint8_t>(ConstraintNode::VT_SECONDACTOR_TYPE, static_cast<uint8_t>(secondActor_type), 0);
  }
  void add_secondActor(::flatbuffers::Offset<void> secondActor) {
    fbb_.AddOffset(ConstraintNode::VT_SECONDACTOR, secondActor);
  }
  void add_secondConnectedConstraint_type(DeepSeaScenePhysics::ConstraintReference secondConnectedConstraint_type) {
    fbb_.AddElement<uint8_t>(ConstraintNode::VT_SECONDCONNECTEDCONSTRAINT_TYPE, static_cast<uint8_t>(secondConnectedConstraint_type), 0);
  }
  void add_secondConnectedConstraint(::flatbuffers::Offset<void> secondConnectedConstraint) {
    fbb_.AddOffset(ConstraintNode::VT_SECONDCONNECTEDCONSTRAINT, secondConnectedConstraint);
  }
  void add_itemLists(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> itemLists) {
    fbb_.AddOffset(ConstraintNode::VT_ITEMLISTS, itemLists);
  }
  explicit ConstraintNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ConstraintNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ConstraintNode>(end);
    fbb_.Required(o, ConstraintNode::VT_CONSTRAINT);
    return o;
  }
};

inline ::flatbuffers::Offset<ConstraintNode> CreateConstraintNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> constraint = 0,
    DeepSeaScenePhysics::ActorReference firstActor_type = DeepSeaScenePhysics::ActorReference::NONE,
    ::flatbuffers::Offset<void> firstActor = 0,
    DeepSeaScenePhysics::ConstraintReference firstConnectedConstraint_type = DeepSeaScenePhysics::ConstraintReference::NONE,
    ::flatbuffers::Offset<void> firstConnectedConstraint = 0,
    DeepSeaScenePhysics::ActorReference secondActor_type = DeepSeaScenePhysics::ActorReference::NONE,
    ::flatbuffers::Offset<void> secondActor = 0,
    DeepSeaScenePhysics::ConstraintReference secondConnectedConstraint_type = DeepSeaScenePhysics::ConstraintReference::NONE,
    ::flatbuffers::Offset<void> secondConnectedConstraint = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<::flatbuffers::String>>> itemLists = 0) {
  ConstraintNodeBuilder builder_(_fbb);
  builder_.add_itemLists(itemLists);
  builder_.add_secondConnectedConstraint(secondConnectedConstraint);
  builder_.add_secondActor(secondActor);
  builder_.add_firstConnectedConstraint(firstConnectedConstraint);
  builder_.add_firstActor(firstActor);
  builder_.add_constraint(constraint);
  builder_.add_secondConnectedConstraint_type(secondConnectedConstraint_type);
  builder_.add_secondActor_type(secondActor_type);
  builder_.add_firstConnectedConstraint_type(firstConnectedConstraint_type);
  builder_.add_firstActor_type(firstActor_type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ConstraintNode> CreateConstraintNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *constraint = nullptr,
    DeepSeaScenePhysics::ActorReference firstActor_type = DeepSeaScenePhysics::ActorReference::NONE,
    ::flatbuffers::Offset<void> firstActor = 0,
    DeepSeaScenePhysics::ConstraintReference firstConnectedConstraint_type = DeepSeaScenePhysics::ConstraintReference::NONE,
    ::flatbuffers::Offset<void> firstConnectedConstraint = 0,
    DeepSeaScenePhysics::ActorReference secondActor_type = DeepSeaScenePhysics::ActorReference::NONE,
    ::flatbuffers::Offset<void> secondActor = 0,
    DeepSeaScenePhysics::ConstraintReference secondConnectedConstraint_type = DeepSeaScenePhysics::ConstraintReference::NONE,
    ::flatbuffers::Offset<void> secondConnectedConstraint = 0,
    const std::vector<::flatbuffers::Offset<::flatbuffers::String>> *itemLists = nullptr) {
  auto constraint__ = constraint ? _fbb.CreateString(constraint) : 0;
  auto itemLists__ = itemLists ? _fbb.CreateVector<::flatbuffers::Offset<::flatbuffers::String>>(*itemLists) : 0;
  return DeepSeaScenePhysics::CreateConstraintNode(
      _fbb,
      constraint__,
      firstActor_type,
      firstActor,
      firstConnectedConstraint_type,
      firstConnectedConstraint,
      secondActor_type,
      secondActor,
      secondConnectedConstraint_type,
      secondConnectedConstraint,
      itemLists__);
}

template <bool B>
inline bool VerifyActorReference(::flatbuffers::VerifierTemplate<B> &verifier, const void *obj, ActorReference type) {
  switch (type) {
    case ActorReference::NONE: {
      return true;
    }
    case ActorReference::InstanceReference: {
      auto ptr = reinterpret_cast<const DeepSeaScenePhysics::InstanceReference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ActorReference::ActorResourceReference: {
      auto ptr = reinterpret_cast<const DeepSeaScenePhysics::ActorResourceReference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

template <bool B>
inline bool VerifyActorReferenceVector(::flatbuffers::VerifierTemplate<B> &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ActorReference> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyActorReference(
        verifier,  values->Get(i), types->GetEnum<ActorReference>(i))) {
      return false;
    }
  }
  return true;
}

template <bool B>
inline bool VerifyConstraintReference(::flatbuffers::VerifierTemplate<B> &verifier, const void *obj, ConstraintReference type) {
  switch (type) {
    case ConstraintReference::NONE: {
      return true;
    }
    case ConstraintReference::InstanceReference: {
      auto ptr = reinterpret_cast<const DeepSeaScenePhysics::InstanceReference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ConstraintReference::ConstraintNodeReference: {
      auto ptr = reinterpret_cast<const DeepSeaScenePhysics::ConstraintNodeReference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ConstraintReference::ConstraintResourceReference: {
      auto ptr = reinterpret_cast<const DeepSeaScenePhysics::ConstraintResourceReference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

template <bool B>
inline bool VerifyConstraintReferenceVector(::flatbuffers::VerifierTemplate<B> &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<ConstraintReference> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyConstraintReference(
        verifier,  values->Get(i), types->GetEnum<ConstraintReference>(i))) {
      return false;
    }
  }
  return true;
}

inline const DeepSeaScenePhysics::ConstraintNode *GetConstraintNode(const void *buf) {
  return ::flatbuffers::GetRoot<DeepSeaScenePhysics::ConstraintNode>(buf);
}

inline const DeepSeaScenePhysics::ConstraintNode *GetSizePrefixedConstraintNode(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<DeepSeaScenePhysics::ConstraintNode>(buf);
}

template <bool B = false>
inline bool VerifyConstraintNodeBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifyBuffer<DeepSeaScenePhysics::ConstraintNode>(nullptr);
}

template <bool B = false>
inline bool VerifySizePrefixedConstraintNodeBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifySizePrefixedBuffer<DeepSeaScenePhysics::ConstraintNode>(nullptr);
}

inline void FinishConstraintNodeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DeepSeaScenePhysics::ConstraintNode> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedConstraintNodeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DeepSeaScenePhysics::ConstraintNode> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace DeepSeaScenePhysics

#endif  // FLATBUFFERS_GENERATED_SCENEPHYSICSCONSTRAINTNODE_DEEPSEASCENEPHYSICS_H_
