// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCENE_DEEPSEASCENE_H_
#define FLATBUFFERS_GENERATED_SCENE_DEEPSEASCENE_H_

#include "flatbuffers/flatbuffers.h"

#include "DeepSea/Scene/Flatbuffers/SceneCommon_generated.h"

namespace DeepSeaScene {

struct SceneItemList;

struct SceneItemLists;

struct ClearColorFloat;

struct ClearColorInt;

struct ClearColorUInt;

struct ClearDepthStencil;

struct Attachment;

struct AttachmentRef;

struct RenderSubpass;

struct SubpassDependency;

struct RenderPass;

struct ScenePipelineItem;

struct GlobalData;

struct Scene;

enum class ClearValue : uint8_t {
  NONE = 0,
  ClearColorFloat = 1,
  ClearColorInt = 2,
  ClearColorUInt = 3,
  ClearDepthStencil = 4,
  MIN = NONE,
  MAX = ClearDepthStencil
};

inline const ClearValue (&EnumValuesClearValue())[5] {
  static const ClearValue values[] = {
    ClearValue::NONE,
    ClearValue::ClearColorFloat,
    ClearValue::ClearColorInt,
    ClearValue::ClearColorUInt,
    ClearValue::ClearDepthStencil
  };
  return values;
}

inline const char * const *EnumNamesClearValue() {
  static const char * const names[] = {
    "NONE",
    "ClearColorFloat",
    "ClearColorInt",
    "ClearColorUInt",
    "ClearDepthStencil",
    nullptr
  };
  return names;
}

inline const char *EnumNameClearValue(ClearValue e) {
  if (e < ClearValue::NONE || e > ClearValue::ClearDepthStencil) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesClearValue()[index];
}

template<typename T> struct ClearValueTraits {
  static const ClearValue enum_value = ClearValue::NONE;
};

template<> struct ClearValueTraits<ClearColorFloat> {
  static const ClearValue enum_value = ClearValue::ClearColorFloat;
};

template<> struct ClearValueTraits<ClearColorInt> {
  static const ClearValue enum_value = ClearValue::ClearColorInt;
};

template<> struct ClearValueTraits<ClearColorUInt> {
  static const ClearValue enum_value = ClearValue::ClearColorUInt;
};

template<> struct ClearValueTraits<ClearDepthStencil> {
  static const ClearValue enum_value = ClearValue::ClearDepthStencil;
};

bool VerifyClearValue(flatbuffers::Verifier &verifier, const void *obj, ClearValue type);
bool VerifyClearValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum class ScenePipelineItemUnion : uint8_t {
  NONE = 0,
  RenderPass = 1,
  SceneItemLists = 2,
  MIN = NONE,
  MAX = SceneItemLists
};

inline const ScenePipelineItemUnion (&EnumValuesScenePipelineItemUnion())[3] {
  static const ScenePipelineItemUnion values[] = {
    ScenePipelineItemUnion::NONE,
    ScenePipelineItemUnion::RenderPass,
    ScenePipelineItemUnion::SceneItemLists
  };
  return values;
}

inline const char * const *EnumNamesScenePipelineItemUnion() {
  static const char * const names[] = {
    "NONE",
    "RenderPass",
    "SceneItemLists",
    nullptr
  };
  return names;
}

inline const char *EnumNameScenePipelineItemUnion(ScenePipelineItemUnion e) {
  if (e < ScenePipelineItemUnion::NONE || e > ScenePipelineItemUnion::SceneItemLists) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesScenePipelineItemUnion()[index];
}

template<typename T> struct ScenePipelineItemUnionTraits {
  static const ScenePipelineItemUnion enum_value = ScenePipelineItemUnion::NONE;
};

template<> struct ScenePipelineItemUnionTraits<RenderPass> {
  static const ScenePipelineItemUnion enum_value = ScenePipelineItemUnion::RenderPass;
};

template<> struct ScenePipelineItemUnionTraits<SceneItemLists> {
  static const ScenePipelineItemUnion enum_value = ScenePipelineItemUnion::SceneItemLists;
};

bool VerifyScenePipelineItemUnion(flatbuffers::Verifier &verifier, const void *obj, ScenePipelineItemUnion type);
bool VerifyScenePipelineItemUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) AttachmentRef FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t index_;
  uint8_t resolve_;
  int8_t padding0__;  int16_t padding1__;

 public:
  AttachmentRef() {
    memset(static_cast<void *>(this), 0, sizeof(AttachmentRef));
  }
  AttachmentRef(uint32_t _index, bool _resolve)
      : index_(flatbuffers::EndianScalar(_index)),
        resolve_(flatbuffers::EndianScalar(static_cast<uint8_t>(_resolve))),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;    (void)padding1__;
  }
  uint32_t index() const {
    return flatbuffers::EndianScalar(index_);
  }
  bool resolve() const {
    return flatbuffers::EndianScalar(resolve_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(AttachmentRef, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SubpassDependency FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t srcSubpass_;
  uint32_t srcStages_;
  uint32_t srcAccess_;
  uint32_t dstSubpass_;
  uint32_t dstStages_;
  uint32_t dstAccess_;
  uint8_t regionDependency_;
  int8_t padding0__;  int16_t padding1__;

 public:
  SubpassDependency() {
    memset(static_cast<void *>(this), 0, sizeof(SubpassDependency));
  }
  SubpassDependency(uint32_t _srcSubpass, uint32_t _srcStages, uint32_t _srcAccess, uint32_t _dstSubpass, uint32_t _dstStages, uint32_t _dstAccess, bool _regionDependency)
      : srcSubpass_(flatbuffers::EndianScalar(_srcSubpass)),
        srcStages_(flatbuffers::EndianScalar(_srcStages)),
        srcAccess_(flatbuffers::EndianScalar(_srcAccess)),
        dstSubpass_(flatbuffers::EndianScalar(_dstSubpass)),
        dstStages_(flatbuffers::EndianScalar(_dstStages)),
        dstAccess_(flatbuffers::EndianScalar(_dstAccess)),
        regionDependency_(flatbuffers::EndianScalar(static_cast<uint8_t>(_regionDependency))),
        padding0__(0),
        padding1__(0) {
    (void)padding0__;    (void)padding1__;
  }
  uint32_t srcSubpass() const {
    return flatbuffers::EndianScalar(srcSubpass_);
  }
  uint32_t srcStages() const {
    return flatbuffers::EndianScalar(srcStages_);
  }
  uint32_t srcAccess() const {
    return flatbuffers::EndianScalar(srcAccess_);
  }
  uint32_t dstSubpass() const {
    return flatbuffers::EndianScalar(dstSubpass_);
  }
  uint32_t dstStages() const {
    return flatbuffers::EndianScalar(dstStages_);
  }
  uint32_t dstAccess() const {
    return flatbuffers::EndianScalar(dstAccess_);
  }
  bool regionDependency() const {
    return flatbuffers::EndianScalar(regionDependency_) != 0;
  }
};
FLATBUFFERS_STRUCT_END(SubpassDependency, 28);

struct SceneItemList FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_NAME = 6,
    VT_DATA = 8
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct SceneItemListBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(SceneItemList::VT_TYPE, type);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SceneItemList::VT_NAME, name);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(SceneItemList::VT_DATA, data);
  }
  explicit SceneItemListBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SceneItemListBuilder &operator=(const SceneItemListBuilder &);
  flatbuffers::Offset<SceneItemList> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SceneItemList>(end);
    fbb_.Required(o, SceneItemList::VT_TYPE);
    fbb_.Required(o, SceneItemList::VT_NAME);
    fbb_.Required(o, SceneItemList::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<SceneItemList> CreateSceneItemList(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  SceneItemListBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<SceneItemList> CreateSceneItemListDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *name = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return DeepSeaScene::CreateSceneItemList(
      _fbb,
      type__,
      name__,
      data__);
}

struct SceneItemLists FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEMLISTS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<SceneItemList>> *itemLists() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SceneItemList>> *>(VT_ITEMLISTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ITEMLISTS) &&
           verifier.VerifyVector(itemLists()) &&
           verifier.VerifyVectorOfTables(itemLists()) &&
           verifier.EndTable();
  }
};

struct SceneItemListsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_itemLists(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SceneItemList>>> itemLists) {
    fbb_.AddOffset(SceneItemLists::VT_ITEMLISTS, itemLists);
  }
  explicit SceneItemListsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SceneItemListsBuilder &operator=(const SceneItemListsBuilder &);
  flatbuffers::Offset<SceneItemLists> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SceneItemLists>(end);
    fbb_.Required(o, SceneItemLists::VT_ITEMLISTS);
    return o;
  }
};

inline flatbuffers::Offset<SceneItemLists> CreateSceneItemLists(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SceneItemList>>> itemLists = 0) {
  SceneItemListsBuilder builder_(_fbb);
  builder_.add_itemLists(itemLists);
  return builder_.Finish();
}

inline flatbuffers::Offset<SceneItemLists> CreateSceneItemListsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SceneItemList>> *itemLists = nullptr) {
  auto itemLists__ = itemLists ? _fbb.CreateVector<flatbuffers::Offset<SceneItemList>>(*itemLists) : 0;
  return DeepSeaScene::CreateSceneItemLists(
      _fbb,
      itemLists__);
}

struct ClearColorFloat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RED = 4,
    VT_GREEN = 6,
    VT_BLUE = 8,
    VT_ALPHA = 10
  };
  float red() const {
    return GetField<float>(VT_RED, 0.0f);
  }
  float green() const {
    return GetField<float>(VT_GREEN, 0.0f);
  }
  float blue() const {
    return GetField<float>(VT_BLUE, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RED) &&
           VerifyField<float>(verifier, VT_GREEN) &&
           VerifyField<float>(verifier, VT_BLUE) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
};

struct ClearColorFloatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_red(float red) {
    fbb_.AddElement<float>(ClearColorFloat::VT_RED, red, 0.0f);
  }
  void add_green(float green) {
    fbb_.AddElement<float>(ClearColorFloat::VT_GREEN, green, 0.0f);
  }
  void add_blue(float blue) {
    fbb_.AddElement<float>(ClearColorFloat::VT_BLUE, blue, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(ClearColorFloat::VT_ALPHA, alpha, 0.0f);
  }
  explicit ClearColorFloatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClearColorFloatBuilder &operator=(const ClearColorFloatBuilder &);
  flatbuffers::Offset<ClearColorFloat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClearColorFloat>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClearColorFloat> CreateClearColorFloat(
    flatbuffers::FlatBufferBuilder &_fbb,
    float red = 0.0f,
    float green = 0.0f,
    float blue = 0.0f,
    float alpha = 0.0f) {
  ClearColorFloatBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_blue(blue);
  builder_.add_green(green);
  builder_.add_red(red);
  return builder_.Finish();
}

struct ClearColorInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RED = 4,
    VT_GREEN = 6,
    VT_BLUE = 8,
    VT_ALPHA = 10
  };
  int32_t red() const {
    return GetField<int32_t>(VT_RED, 0);
  }
  int32_t green() const {
    return GetField<int32_t>(VT_GREEN, 0);
  }
  int32_t blue() const {
    return GetField<int32_t>(VT_BLUE, 0);
  }
  int32_t alpha() const {
    return GetField<int32_t>(VT_ALPHA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RED) &&
           VerifyField<int32_t>(verifier, VT_GREEN) &&
           VerifyField<int32_t>(verifier, VT_BLUE) &&
           VerifyField<int32_t>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
};

struct ClearColorIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_red(int32_t red) {
    fbb_.AddElement<int32_t>(ClearColorInt::VT_RED, red, 0);
  }
  void add_green(int32_t green) {
    fbb_.AddElement<int32_t>(ClearColorInt::VT_GREEN, green, 0);
  }
  void add_blue(int32_t blue) {
    fbb_.AddElement<int32_t>(ClearColorInt::VT_BLUE, blue, 0);
  }
  void add_alpha(int32_t alpha) {
    fbb_.AddElement<int32_t>(ClearColorInt::VT_ALPHA, alpha, 0);
  }
  explicit ClearColorIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClearColorIntBuilder &operator=(const ClearColorIntBuilder &);
  flatbuffers::Offset<ClearColorInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClearColorInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClearColorInt> CreateClearColorInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t red = 0,
    int32_t green = 0,
    int32_t blue = 0,
    int32_t alpha = 0) {
  ClearColorIntBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_blue(blue);
  builder_.add_green(green);
  builder_.add_red(red);
  return builder_.Finish();
}

struct ClearColorUInt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RED = 4,
    VT_GREEN = 6,
    VT_BLUE = 8,
    VT_ALPHA = 10
  };
  uint32_t red() const {
    return GetField<uint32_t>(VT_RED, 0);
  }
  uint32_t green() const {
    return GetField<uint32_t>(VT_GREEN, 0);
  }
  uint32_t blue() const {
    return GetField<uint32_t>(VT_BLUE, 0);
  }
  uint32_t alpha() const {
    return GetField<uint32_t>(VT_ALPHA, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_RED) &&
           VerifyField<uint32_t>(verifier, VT_GREEN) &&
           VerifyField<uint32_t>(verifier, VT_BLUE) &&
           VerifyField<uint32_t>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
};

struct ClearColorUIntBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_red(uint32_t red) {
    fbb_.AddElement<uint32_t>(ClearColorUInt::VT_RED, red, 0);
  }
  void add_green(uint32_t green) {
    fbb_.AddElement<uint32_t>(ClearColorUInt::VT_GREEN, green, 0);
  }
  void add_blue(uint32_t blue) {
    fbb_.AddElement<uint32_t>(ClearColorUInt::VT_BLUE, blue, 0);
  }
  void add_alpha(uint32_t alpha) {
    fbb_.AddElement<uint32_t>(ClearColorUInt::VT_ALPHA, alpha, 0);
  }
  explicit ClearColorUIntBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClearColorUIntBuilder &operator=(const ClearColorUIntBuilder &);
  flatbuffers::Offset<ClearColorUInt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClearColorUInt>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClearColorUInt> CreateClearColorUInt(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t red = 0,
    uint32_t green = 0,
    uint32_t blue = 0,
    uint32_t alpha = 0) {
  ClearColorUIntBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_blue(blue);
  builder_.add_green(green);
  builder_.add_red(red);
  return builder_.Finish();
}

struct ClearDepthStencil FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEPTH = 4,
    VT_STENCIL = 6
  };
  float depth() const {
    return GetField<float>(VT_DEPTH, 0.0f);
  }
  uint32_t stencil() const {
    return GetField<uint32_t>(VT_STENCIL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_DEPTH) &&
           VerifyField<uint32_t>(verifier, VT_STENCIL) &&
           verifier.EndTable();
  }
};

struct ClearDepthStencilBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_depth(float depth) {
    fbb_.AddElement<float>(ClearDepthStencil::VT_DEPTH, depth, 0.0f);
  }
  void add_stencil(uint32_t stencil) {
    fbb_.AddElement<uint32_t>(ClearDepthStencil::VT_STENCIL, stencil, 0);
  }
  explicit ClearDepthStencilBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClearDepthStencilBuilder &operator=(const ClearDepthStencilBuilder &);
  flatbuffers::Offset<ClearDepthStencil> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClearDepthStencil>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClearDepthStencil> CreateClearDepthStencil(
    flatbuffers::FlatBufferBuilder &_fbb,
    float depth = 0.0f,
    uint32_t stencil = 0) {
  ClearDepthStencilBuilder builder_(_fbb);
  builder_.add_stencil(stencil);
  builder_.add_depth(depth);
  return builder_.Finish();
}

struct Attachment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USAGE = 4,
    VT_FORMAT = 6,
    VT_DECORATION = 8,
    VT_SAMPLES = 10,
    VT_CLEARVALUE_TYPE = 12,
    VT_CLEARVALUE = 14
  };
  uint32_t usage() const {
    return GetField<uint32_t>(VT_USAGE, 0);
  }
  TextureFormat format() const {
    return static_cast<TextureFormat>(GetField<uint8_t>(VT_FORMAT, 0));
  }
  FormatDecoration decoration() const {
    return static_cast<FormatDecoration>(GetField<uint8_t>(VT_DECORATION, 0));
  }
  uint32_t samples() const {
    return GetField<uint32_t>(VT_SAMPLES, 0);
  }
  ClearValue clearValue_type() const {
    return static_cast<ClearValue>(GetField<uint8_t>(VT_CLEARVALUE_TYPE, 0));
  }
  const void *clearValue() const {
    return GetPointer<const void *>(VT_CLEARVALUE);
  }
  template<typename T> const T *clearValue_as() const;
  const ClearColorFloat *clearValue_as_ClearColorFloat() const {
    return clearValue_type() == ClearValue::ClearColorFloat ? static_cast<const ClearColorFloat *>(clearValue()) : nullptr;
  }
  const ClearColorInt *clearValue_as_ClearColorInt() const {
    return clearValue_type() == ClearValue::ClearColorInt ? static_cast<const ClearColorInt *>(clearValue()) : nullptr;
  }
  const ClearColorUInt *clearValue_as_ClearColorUInt() const {
    return clearValue_type() == ClearValue::ClearColorUInt ? static_cast<const ClearColorUInt *>(clearValue()) : nullptr;
  }
  const ClearDepthStencil *clearValue_as_ClearDepthStencil() const {
    return clearValue_type() == ClearValue::ClearDepthStencil ? static_cast<const ClearDepthStencil *>(clearValue()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_USAGE) &&
           VerifyField<uint8_t>(verifier, VT_FORMAT) &&
           VerifyField<uint8_t>(verifier, VT_DECORATION) &&
           VerifyField<uint32_t>(verifier, VT_SAMPLES) &&
           VerifyField<uint8_t>(verifier, VT_CLEARVALUE_TYPE) &&
           VerifyOffset(verifier, VT_CLEARVALUE) &&
           VerifyClearValue(verifier, clearValue(), clearValue_type()) &&
           verifier.EndTable();
  }
};

template<> inline const ClearColorFloat *Attachment::clearValue_as<ClearColorFloat>() const {
  return clearValue_as_ClearColorFloat();
}

template<> inline const ClearColorInt *Attachment::clearValue_as<ClearColorInt>() const {
  return clearValue_as_ClearColorInt();
}

template<> inline const ClearColorUInt *Attachment::clearValue_as<ClearColorUInt>() const {
  return clearValue_as_ClearColorUInt();
}

template<> inline const ClearDepthStencil *Attachment::clearValue_as<ClearDepthStencil>() const {
  return clearValue_as_ClearDepthStencil();
}

struct AttachmentBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_usage(uint32_t usage) {
    fbb_.AddElement<uint32_t>(Attachment::VT_USAGE, usage, 0);
  }
  void add_format(TextureFormat format) {
    fbb_.AddElement<uint8_t>(Attachment::VT_FORMAT, static_cast<uint8_t>(format), 0);
  }
  void add_decoration(FormatDecoration decoration) {
    fbb_.AddElement<uint8_t>(Attachment::VT_DECORATION, static_cast<uint8_t>(decoration), 0);
  }
  void add_samples(uint32_t samples) {
    fbb_.AddElement<uint32_t>(Attachment::VT_SAMPLES, samples, 0);
  }
  void add_clearValue_type(ClearValue clearValue_type) {
    fbb_.AddElement<uint8_t>(Attachment::VT_CLEARVALUE_TYPE, static_cast<uint8_t>(clearValue_type), 0);
  }
  void add_clearValue(flatbuffers::Offset<void> clearValue) {
    fbb_.AddOffset(Attachment::VT_CLEARVALUE, clearValue);
  }
  explicit AttachmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AttachmentBuilder &operator=(const AttachmentBuilder &);
  flatbuffers::Offset<Attachment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Attachment>(end);
    return o;
  }
};

inline flatbuffers::Offset<Attachment> CreateAttachment(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t usage = 0,
    TextureFormat format = TextureFormat::R4G4,
    FormatDecoration decoration = FormatDecoration::UNorm,
    uint32_t samples = 0,
    ClearValue clearValue_type = ClearValue::NONE,
    flatbuffers::Offset<void> clearValue = 0) {
  AttachmentBuilder builder_(_fbb);
  builder_.add_clearValue(clearValue);
  builder_.add_samples(samples);
  builder_.add_usage(usage);
  builder_.add_clearValue_type(clearValue_type);
  builder_.add_decoration(decoration);
  builder_.add_format(format);
  return builder_.Finish();
}

struct RenderSubpass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INPUTATTACHMENTS = 6,
    VT_COLORATTACHMENTS = 8,
    VT_DEPTHSTENCILATTACHMENT = 10,
    VT_DRAWLISTS = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint32_t> *inputAttachments() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTATTACHMENTS);
  }
  const flatbuffers::Vector<const AttachmentRef *> *colorAttachments() const {
    return GetPointer<const flatbuffers::Vector<const AttachmentRef *> *>(VT_COLORATTACHMENTS);
  }
  const flatbuffers::Vector<const AttachmentRef *> *depthStencilAttachment() const {
    return GetPointer<const flatbuffers::Vector<const AttachmentRef *> *>(VT_DEPTHSTENCILATTACHMENT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SceneItemList>> *drawLists() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SceneItemList>> *>(VT_DRAWLISTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTATTACHMENTS) &&
           verifier.VerifyVector(inputAttachments()) &&
           VerifyOffset(verifier, VT_COLORATTACHMENTS) &&
           verifier.VerifyVector(colorAttachments()) &&
           VerifyOffset(verifier, VT_DEPTHSTENCILATTACHMENT) &&
           verifier.VerifyVector(depthStencilAttachment()) &&
           VerifyOffset(verifier, VT_DRAWLISTS) &&
           verifier.VerifyVector(drawLists()) &&
           verifier.VerifyVectorOfTables(drawLists()) &&
           verifier.EndTable();
  }
};

struct RenderSubpassBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RenderSubpass::VT_NAME, name);
  }
  void add_inputAttachments(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputAttachments) {
    fbb_.AddOffset(RenderSubpass::VT_INPUTATTACHMENTS, inputAttachments);
  }
  void add_colorAttachments(flatbuffers::Offset<flatbuffers::Vector<const AttachmentRef *>> colorAttachments) {
    fbb_.AddOffset(RenderSubpass::VT_COLORATTACHMENTS, colorAttachments);
  }
  void add_depthStencilAttachment(flatbuffers::Offset<flatbuffers::Vector<const AttachmentRef *>> depthStencilAttachment) {
    fbb_.AddOffset(RenderSubpass::VT_DEPTHSTENCILATTACHMENT, depthStencilAttachment);
  }
  void add_drawLists(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SceneItemList>>> drawLists) {
    fbb_.AddOffset(RenderSubpass::VT_DRAWLISTS, drawLists);
  }
  explicit RenderSubpassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RenderSubpassBuilder &operator=(const RenderSubpassBuilder &);
  flatbuffers::Offset<RenderSubpass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RenderSubpass>(end);
    fbb_.Required(o, RenderSubpass::VT_NAME);
    return o;
  }
};

inline flatbuffers::Offset<RenderSubpass> CreateRenderSubpass(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputAttachments = 0,
    flatbuffers::Offset<flatbuffers::Vector<const AttachmentRef *>> colorAttachments = 0,
    flatbuffers::Offset<flatbuffers::Vector<const AttachmentRef *>> depthStencilAttachment = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SceneItemList>>> drawLists = 0) {
  RenderSubpassBuilder builder_(_fbb);
  builder_.add_drawLists(drawLists);
  builder_.add_depthStencilAttachment(depthStencilAttachment);
  builder_.add_colorAttachments(colorAttachments);
  builder_.add_inputAttachments(inputAttachments);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<RenderSubpass> CreateRenderSubpassDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint32_t> *inputAttachments = nullptr,
    const std::vector<AttachmentRef> *colorAttachments = nullptr,
    const std::vector<AttachmentRef> *depthStencilAttachment = nullptr,
    const std::vector<flatbuffers::Offset<SceneItemList>> *drawLists = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputAttachments__ = inputAttachments ? _fbb.CreateVector<uint32_t>(*inputAttachments) : 0;
  auto colorAttachments__ = colorAttachments ? _fbb.CreateVectorOfStructs<AttachmentRef>(*colorAttachments) : 0;
  auto depthStencilAttachment__ = depthStencilAttachment ? _fbb.CreateVectorOfStructs<AttachmentRef>(*depthStencilAttachment) : 0;
  auto drawLists__ = drawLists ? _fbb.CreateVector<flatbuffers::Offset<SceneItemList>>(*drawLists) : 0;
  return DeepSeaScene::CreateRenderSubpass(
      _fbb,
      name__,
      inputAttachments__,
      colorAttachments__,
      depthStencilAttachment__,
      drawLists__);
}

struct RenderPass FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_FRAMEBUFFER = 6,
    VT_ATTACHMENTS = 8,
    VT_SUBPASSES = 10,
    VT_DEPENDENCIES = 12,
    VT_DEFAULTDEPENDENCIES = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *framebuffer() const {
    return GetPointer<const flatbuffers::String *>(VT_FRAMEBUFFER);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Attachment>> *attachments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Attachment>> *>(VT_ATTACHMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RenderSubpass>> *subpasses() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RenderSubpass>> *>(VT_SUBPASSES);
  }
  const flatbuffers::Vector<const SubpassDependency *> *dependencies() const {
    return GetPointer<const flatbuffers::Vector<const SubpassDependency *> *>(VT_DEPENDENCIES);
  }
  bool defaultDependencies() const {
    return GetField<uint8_t>(VT_DEFAULTDEPENDENCIES, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_FRAMEBUFFER) &&
           verifier.VerifyString(framebuffer()) &&
           VerifyOffset(verifier, VT_ATTACHMENTS) &&
           verifier.VerifyVector(attachments()) &&
           verifier.VerifyVectorOfTables(attachments()) &&
           VerifyOffsetRequired(verifier, VT_SUBPASSES) &&
           verifier.VerifyVector(subpasses()) &&
           verifier.VerifyVectorOfTables(subpasses()) &&
           VerifyOffset(verifier, VT_DEPENDENCIES) &&
           verifier.VerifyVector(dependencies()) &&
           VerifyField<uint8_t>(verifier, VT_DEFAULTDEPENDENCIES) &&
           verifier.EndTable();
  }
};

struct RenderPassBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RenderPass::VT_NAME, name);
  }
  void add_framebuffer(flatbuffers::Offset<flatbuffers::String> framebuffer) {
    fbb_.AddOffset(RenderPass::VT_FRAMEBUFFER, framebuffer);
  }
  void add_attachments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Attachment>>> attachments) {
    fbb_.AddOffset(RenderPass::VT_ATTACHMENTS, attachments);
  }
  void add_subpasses(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RenderSubpass>>> subpasses) {
    fbb_.AddOffset(RenderPass::VT_SUBPASSES, subpasses);
  }
  void add_dependencies(flatbuffers::Offset<flatbuffers::Vector<const SubpassDependency *>> dependencies) {
    fbb_.AddOffset(RenderPass::VT_DEPENDENCIES, dependencies);
  }
  void add_defaultDependencies(bool defaultDependencies) {
    fbb_.AddElement<uint8_t>(RenderPass::VT_DEFAULTDEPENDENCIES, static_cast<uint8_t>(defaultDependencies), 0);
  }
  explicit RenderPassBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RenderPassBuilder &operator=(const RenderPassBuilder &);
  flatbuffers::Offset<RenderPass> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RenderPass>(end);
    fbb_.Required(o, RenderPass::VT_NAME);
    fbb_.Required(o, RenderPass::VT_FRAMEBUFFER);
    fbb_.Required(o, RenderPass::VT_SUBPASSES);
    return o;
  }
};

inline flatbuffers::Offset<RenderPass> CreateRenderPass(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> framebuffer = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Attachment>>> attachments = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RenderSubpass>>> subpasses = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SubpassDependency *>> dependencies = 0,
    bool defaultDependencies = false) {
  RenderPassBuilder builder_(_fbb);
  builder_.add_dependencies(dependencies);
  builder_.add_subpasses(subpasses);
  builder_.add_attachments(attachments);
  builder_.add_framebuffer(framebuffer);
  builder_.add_name(name);
  builder_.add_defaultDependencies(defaultDependencies);
  return builder_.Finish();
}

inline flatbuffers::Offset<RenderPass> CreateRenderPassDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *framebuffer = nullptr,
    const std::vector<flatbuffers::Offset<Attachment>> *attachments = nullptr,
    const std::vector<flatbuffers::Offset<RenderSubpass>> *subpasses = nullptr,
    const std::vector<SubpassDependency> *dependencies = nullptr,
    bool defaultDependencies = false) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto framebuffer__ = framebuffer ? _fbb.CreateString(framebuffer) : 0;
  auto attachments__ = attachments ? _fbb.CreateVector<flatbuffers::Offset<Attachment>>(*attachments) : 0;
  auto subpasses__ = subpasses ? _fbb.CreateVector<flatbuffers::Offset<RenderSubpass>>(*subpasses) : 0;
  auto dependencies__ = dependencies ? _fbb.CreateVectorOfStructs<SubpassDependency>(*dependencies) : 0;
  return DeepSeaScene::CreateRenderPass(
      _fbb,
      name__,
      framebuffer__,
      attachments__,
      subpasses__,
      dependencies__,
      defaultDependencies);
}

struct ScenePipelineItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ITEM_TYPE = 4,
    VT_ITEM = 6
  };
  ScenePipelineItemUnion item_type() const {
    return static_cast<ScenePipelineItemUnion>(GetField<uint8_t>(VT_ITEM_TYPE, 0));
  }
  const void *item() const {
    return GetPointer<const void *>(VT_ITEM);
  }
  template<typename T> const T *item_as() const;
  const RenderPass *item_as_RenderPass() const {
    return item_type() == ScenePipelineItemUnion::RenderPass ? static_cast<const RenderPass *>(item()) : nullptr;
  }
  const SceneItemLists *item_as_SceneItemLists() const {
    return item_type() == ScenePipelineItemUnion::SceneItemLists ? static_cast<const SceneItemLists *>(item()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ITEM_TYPE) &&
           VerifyOffset(verifier, VT_ITEM) &&
           VerifyScenePipelineItemUnion(verifier, item(), item_type()) &&
           verifier.EndTable();
  }
};

template<> inline const RenderPass *ScenePipelineItem::item_as<RenderPass>() const {
  return item_as_RenderPass();
}

template<> inline const SceneItemLists *ScenePipelineItem::item_as<SceneItemLists>() const {
  return item_as_SceneItemLists();
}

struct ScenePipelineItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_item_type(ScenePipelineItemUnion item_type) {
    fbb_.AddElement<uint8_t>(ScenePipelineItem::VT_ITEM_TYPE, static_cast<uint8_t>(item_type), 0);
  }
  void add_item(flatbuffers::Offset<void> item) {
    fbb_.AddOffset(ScenePipelineItem::VT_ITEM, item);
  }
  explicit ScenePipelineItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScenePipelineItemBuilder &operator=(const ScenePipelineItemBuilder &);
  flatbuffers::Offset<ScenePipelineItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScenePipelineItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScenePipelineItem> CreateScenePipelineItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    ScenePipelineItemUnion item_type = ScenePipelineItemUnion::NONE,
    flatbuffers::Offset<void> item = 0) {
  ScenePipelineItemBuilder builder_(_fbb);
  builder_.add_item(item);
  builder_.add_item_type(item_type);
  return builder_.Finish();
}

struct GlobalData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffsetRequired(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct GlobalDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(GlobalData::VT_TYPE, type);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(GlobalData::VT_DATA, data);
  }
  explicit GlobalDataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GlobalDataBuilder &operator=(const GlobalDataBuilder &);
  flatbuffers::Offset<GlobalData> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GlobalData>(end);
    fbb_.Required(o, GlobalData::VT_TYPE);
    fbb_.Required(o, GlobalData::VT_DATA);
    return o;
  }
};

inline flatbuffers::Offset<GlobalData> CreateGlobalData(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  GlobalDataBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GlobalData> CreateGlobalDataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return DeepSeaScene::CreateGlobalData(
      _fbb,
      type__,
      data__);
}

struct Scene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAREDITEMS = 4,
    VT_PIPELINE = 6,
    VT_GLOBALDATA = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<SceneItemLists>> *sharedItems() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SceneItemLists>> *>(VT_SHAREDITEMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<ScenePipelineItem>> *pipeline() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ScenePipelineItem>> *>(VT_PIPELINE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<GlobalData>> *globalData() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<GlobalData>> *>(VT_GLOBALDATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAREDITEMS) &&
           verifier.VerifyVector(sharedItems()) &&
           verifier.VerifyVectorOfTables(sharedItems()) &&
           VerifyOffsetRequired(verifier, VT_PIPELINE) &&
           verifier.VerifyVector(pipeline()) &&
           verifier.VerifyVectorOfTables(pipeline()) &&
           VerifyOffset(verifier, VT_GLOBALDATA) &&
           verifier.VerifyVector(globalData()) &&
           verifier.VerifyVectorOfTables(globalData()) &&
           verifier.EndTable();
  }
};

struct SceneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sharedItems(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SceneItemLists>>> sharedItems) {
    fbb_.AddOffset(Scene::VT_SHAREDITEMS, sharedItems);
  }
  void add_pipeline(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ScenePipelineItem>>> pipeline) {
    fbb_.AddOffset(Scene::VT_PIPELINE, pipeline);
  }
  void add_globalData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GlobalData>>> globalData) {
    fbb_.AddOffset(Scene::VT_GLOBALDATA, globalData);
  }
  explicit SceneBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SceneBuilder &operator=(const SceneBuilder &);
  flatbuffers::Offset<Scene> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scene>(end);
    fbb_.Required(o, Scene::VT_PIPELINE);
    return o;
  }
};

inline flatbuffers::Offset<Scene> CreateScene(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SceneItemLists>>> sharedItems = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ScenePipelineItem>>> pipeline = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<GlobalData>>> globalData = 0) {
  SceneBuilder builder_(_fbb);
  builder_.add_globalData(globalData);
  builder_.add_pipeline(pipeline);
  builder_.add_sharedItems(sharedItems);
  return builder_.Finish();
}

inline flatbuffers::Offset<Scene> CreateSceneDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<SceneItemLists>> *sharedItems = nullptr,
    const std::vector<flatbuffers::Offset<ScenePipelineItem>> *pipeline = nullptr,
    const std::vector<flatbuffers::Offset<GlobalData>> *globalData = nullptr) {
  auto sharedItems__ = sharedItems ? _fbb.CreateVector<flatbuffers::Offset<SceneItemLists>>(*sharedItems) : 0;
  auto pipeline__ = pipeline ? _fbb.CreateVector<flatbuffers::Offset<ScenePipelineItem>>(*pipeline) : 0;
  auto globalData__ = globalData ? _fbb.CreateVector<flatbuffers::Offset<GlobalData>>(*globalData) : 0;
  return DeepSeaScene::CreateScene(
      _fbb,
      sharedItems__,
      pipeline__,
      globalData__);
}

inline bool VerifyClearValue(flatbuffers::Verifier &verifier, const void *obj, ClearValue type) {
  switch (type) {
    case ClearValue::NONE: {
      return true;
    }
    case ClearValue::ClearColorFloat: {
      auto ptr = reinterpret_cast<const ClearColorFloat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClearValue::ClearColorInt: {
      auto ptr = reinterpret_cast<const ClearColorInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClearValue::ClearColorUInt: {
      auto ptr = reinterpret_cast<const ClearColorUInt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ClearValue::ClearDepthStencil: {
      auto ptr = reinterpret_cast<const ClearDepthStencil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyClearValueVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyClearValue(
        verifier,  values->Get(i), types->GetEnum<ClearValue>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyScenePipelineItemUnion(flatbuffers::Verifier &verifier, const void *obj, ScenePipelineItemUnion type) {
  switch (type) {
    case ScenePipelineItemUnion::NONE: {
      return true;
    }
    case ScenePipelineItemUnion::RenderPass: {
      auto ptr = reinterpret_cast<const RenderPass *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case ScenePipelineItemUnion::SceneItemLists: {
      auto ptr = reinterpret_cast<const SceneItemLists *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyScenePipelineItemUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyScenePipelineItemUnion(
        verifier,  values->Get(i), types->GetEnum<ScenePipelineItemUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline const DeepSeaScene::Scene *GetScene(const void *buf) {
  return flatbuffers::GetRoot<DeepSeaScene::Scene>(buf);
}

inline const DeepSeaScene::Scene *GetSizePrefixedScene(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<DeepSeaScene::Scene>(buf);
}

inline bool VerifySceneBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DeepSeaScene::Scene>(nullptr);
}

inline bool VerifySizePrefixedSceneBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DeepSeaScene::Scene>(nullptr);
}

inline void FinishSceneBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DeepSeaScene::Scene> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSceneBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DeepSeaScene::Scene> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace DeepSeaScene

#endif  // FLATBUFFERS_GENERATED_SCENE_DEEPSEASCENE_H_
