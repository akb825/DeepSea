// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_ANIMATIONTREE_DEEPSEAANIMATION_H_
#define FLATBUFFERS_GENERATED_ANIMATIONTREE_DEEPSEAANIMATION_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

#include "AnimationCommon_generated.h"

namespace DeepSeaAnimation {

struct AnimationNode;
struct AnimationNodeBuilder;

struct AnimationJointNode;
struct AnimationJointNodeBuilder;

struct AnimationTree;
struct AnimationTreeBuilder;

struct AnimationNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnimationNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SCALE = 6,
    VT_ROTATION = 8,
    VT_TRANSLATION = 10,
    VT_CHILDREN = 12
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const DeepSeaAnimation::Vector3f *scale() const {
    return GetStruct<const DeepSeaAnimation::Vector3f *>(VT_SCALE);
  }
  const DeepSeaAnimation::Quaternion4f *rotation() const {
    return GetStruct<const DeepSeaAnimation::Quaternion4f *>(VT_ROTATION);
  }
  const DeepSeaAnimation::Vector3f *translation() const {
    return GetStruct<const DeepSeaAnimation::Vector3f *>(VT_TRANSLATION);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationNode>> *children() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationNode>> *>(VT_CHILDREN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<DeepSeaAnimation::Vector3f>(verifier, VT_SCALE, 4) &&
           VerifyField<DeepSeaAnimation::Quaternion4f>(verifier, VT_ROTATION, 4) &&
           VerifyField<DeepSeaAnimation::Vector3f>(verifier, VT_TRANSLATION, 4) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           verifier.EndTable();
  }
};

struct AnimationNodeBuilder {
  typedef AnimationNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AnimationNode::VT_NAME, name);
  }
  void add_scale(const DeepSeaAnimation::Vector3f *scale) {
    fbb_.AddStruct(AnimationNode::VT_SCALE, scale);
  }
  void add_rotation(const DeepSeaAnimation::Quaternion4f *rotation) {
    fbb_.AddStruct(AnimationNode::VT_ROTATION, rotation);
  }
  void add_translation(const DeepSeaAnimation::Vector3f *translation) {
    fbb_.AddStruct(AnimationNode::VT_TRANSLATION, translation);
  }
  void add_children(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationNode>>> children) {
    fbb_.AddOffset(AnimationNode::VT_CHILDREN, children);
  }
  explicit AnimationNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnimationNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnimationNode>(end);
    fbb_.Required(o, AnimationNode::VT_NAME);
    return o;
  }
};

inline ::flatbuffers::Offset<AnimationNode> CreateAnimationNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    const DeepSeaAnimation::Vector3f *scale = nullptr,
    const DeepSeaAnimation::Quaternion4f *rotation = nullptr,
    const DeepSeaAnimation::Vector3f *translation = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationNode>>> children = 0) {
  AnimationNodeBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_translation(translation);
  builder_.add_rotation(rotation);
  builder_.add_scale(scale);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AnimationNode> CreateAnimationNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const DeepSeaAnimation::Vector3f *scale = nullptr,
    const DeepSeaAnimation::Quaternion4f *rotation = nullptr,
    const DeepSeaAnimation::Vector3f *translation = nullptr,
    const std::vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationNode>> *children = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto children__ = children ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaAnimation::AnimationNode>>(*children) : 0;
  return DeepSeaAnimation::CreateAnimationNode(
      _fbb,
      name__,
      scale,
      rotation,
      translation,
      children__);
}

struct AnimationJointNode FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnimationJointNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SCALE = 6,
    VT_ROTATION = 8,
    VT_TRANSLATION = 10,
    VT_TOLOCALSPACE = 12,
    VT_CHILDREN = 14
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const DeepSeaAnimation::Vector3f *scale() const {
    return GetStruct<const DeepSeaAnimation::Vector3f *>(VT_SCALE);
  }
  const DeepSeaAnimation::Quaternion4f *rotation() const {
    return GetStruct<const DeepSeaAnimation::Quaternion4f *>(VT_ROTATION);
  }
  const DeepSeaAnimation::Vector3f *translation() const {
    return GetStruct<const DeepSeaAnimation::Vector3f *>(VT_TRANSLATION);
  }
  const DeepSeaAnimation::Matrix44f *toLocalSpace() const {
    return GetStruct<const DeepSeaAnimation::Matrix44f *>(VT_TOLOCALSPACE);
  }
  const ::flatbuffers::Vector<uint32_t> *children() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_CHILDREN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<DeepSeaAnimation::Vector3f>(verifier, VT_SCALE, 4) &&
           VerifyField<DeepSeaAnimation::Quaternion4f>(verifier, VT_ROTATION, 4) &&
           VerifyField<DeepSeaAnimation::Vector3f>(verifier, VT_TRANSLATION, 4) &&
           VerifyFieldRequired<DeepSeaAnimation::Matrix44f>(verifier, VT_TOLOCALSPACE, 4) &&
           VerifyOffset(verifier, VT_CHILDREN) &&
           verifier.VerifyVector(children()) &&
           verifier.EndTable();
  }
};

struct AnimationJointNodeBuilder {
  typedef AnimationJointNode Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(AnimationJointNode::VT_NAME, name);
  }
  void add_scale(const DeepSeaAnimation::Vector3f *scale) {
    fbb_.AddStruct(AnimationJointNode::VT_SCALE, scale);
  }
  void add_rotation(const DeepSeaAnimation::Quaternion4f *rotation) {
    fbb_.AddStruct(AnimationJointNode::VT_ROTATION, rotation);
  }
  void add_translation(const DeepSeaAnimation::Vector3f *translation) {
    fbb_.AddStruct(AnimationJointNode::VT_TRANSLATION, translation);
  }
  void add_toLocalSpace(const DeepSeaAnimation::Matrix44f *toLocalSpace) {
    fbb_.AddStruct(AnimationJointNode::VT_TOLOCALSPACE, toLocalSpace);
  }
  void add_children(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> children) {
    fbb_.AddOffset(AnimationJointNode::VT_CHILDREN, children);
  }
  explicit AnimationJointNodeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnimationJointNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnimationJointNode>(end);
    fbb_.Required(o, AnimationJointNode::VT_NAME);
    fbb_.Required(o, AnimationJointNode::VT_TOLOCALSPACE);
    return o;
  }
};

inline ::flatbuffers::Offset<AnimationJointNode> CreateAnimationJointNode(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    const DeepSeaAnimation::Vector3f *scale = nullptr,
    const DeepSeaAnimation::Quaternion4f *rotation = nullptr,
    const DeepSeaAnimation::Vector3f *translation = nullptr,
    const DeepSeaAnimation::Matrix44f *toLocalSpace = nullptr,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> children = 0) {
  AnimationJointNodeBuilder builder_(_fbb);
  builder_.add_children(children);
  builder_.add_toLocalSpace(toLocalSpace);
  builder_.add_translation(translation);
  builder_.add_rotation(rotation);
  builder_.add_scale(scale);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AnimationJointNode> CreateAnimationJointNodeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const DeepSeaAnimation::Vector3f *scale = nullptr,
    const DeepSeaAnimation::Quaternion4f *rotation = nullptr,
    const DeepSeaAnimation::Vector3f *translation = nullptr,
    const DeepSeaAnimation::Matrix44f *toLocalSpace = nullptr,
    const std::vector<uint32_t> *children = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto children__ = children ? _fbb.CreateVector<uint32_t>(*children) : 0;
  return DeepSeaAnimation::CreateAnimationJointNode(
      _fbb,
      name__,
      scale,
      rotation,
      translation,
      toLocalSpace,
      children__);
}

struct AnimationTree FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnimationTreeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ROOTNODES = 4,
    VT_JOINTNODES = 6
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationNode>> *rootNodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationNode>> *>(VT_ROOTNODES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationJointNode>> *jointNodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationJointNode>> *>(VT_JOINTNODES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ROOTNODES) &&
           verifier.VerifyVector(rootNodes()) &&
           verifier.VerifyVectorOfTables(rootNodes()) &&
           VerifyOffset(verifier, VT_JOINTNODES) &&
           verifier.VerifyVector(jointNodes()) &&
           verifier.VerifyVectorOfTables(jointNodes()) &&
           verifier.EndTable();
  }
};

struct AnimationTreeBuilder {
  typedef AnimationTree Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_rootNodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationNode>>> rootNodes) {
    fbb_.AddOffset(AnimationTree::VT_ROOTNODES, rootNodes);
  }
  void add_jointNodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationJointNode>>> jointNodes) {
    fbb_.AddOffset(AnimationTree::VT_JOINTNODES, jointNodes);
  }
  explicit AnimationTreeBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnimationTree> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnimationTree>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AnimationTree> CreateAnimationTree(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationNode>>> rootNodes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationJointNode>>> jointNodes = 0) {
  AnimationTreeBuilder builder_(_fbb);
  builder_.add_jointNodes(jointNodes);
  builder_.add_rootNodes(rootNodes);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AnimationTree> CreateAnimationTreeDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationNode>> *rootNodes = nullptr,
    const std::vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationJointNode>> *jointNodes = nullptr) {
  auto rootNodes__ = rootNodes ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaAnimation::AnimationNode>>(*rootNodes) : 0;
  auto jointNodes__ = jointNodes ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaAnimation::AnimationJointNode>>(*jointNodes) : 0;
  return DeepSeaAnimation::CreateAnimationTree(
      _fbb,
      rootNodes__,
      jointNodes__);
}

inline const DeepSeaAnimation::AnimationTree *GetAnimationTree(const void *buf) {
  return ::flatbuffers::GetRoot<DeepSeaAnimation::AnimationTree>(buf);
}

inline const DeepSeaAnimation::AnimationTree *GetSizePrefixedAnimationTree(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<DeepSeaAnimation::AnimationTree>(buf);
}

inline bool VerifyAnimationTreeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DeepSeaAnimation::AnimationTree>(nullptr);
}

inline bool VerifySizePrefixedAnimationTreeBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DeepSeaAnimation::AnimationTree>(nullptr);
}

inline void FinishAnimationTreeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DeepSeaAnimation::AnimationTree> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedAnimationTreeBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DeepSeaAnimation::AnimationTree> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace DeepSeaAnimation

#endif  // FLATBUFFERS_GENERATED_ANIMATIONTREE_DEEPSEAANIMATION_H_
