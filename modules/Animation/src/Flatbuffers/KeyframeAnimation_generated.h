// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_KEYFRAMEANIMATION_DEEPSEAANIMATION_H_
#define FLATBUFFERS_GENERATED_KEYFRAMEANIMATION_DEEPSEAANIMATION_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 3,
             "Non-compatible flatbuffers version included");

#include "AnimationCommon_generated.h"

namespace DeepSeaAnimation {

struct KeyframeAnimationChannel;
struct KeyframeAnimationChannelBuilder;

struct AnimationKeyframes;
struct AnimationKeyframesBuilder;

struct KeyframeAnimation;
struct KeyframeAnimationBuilder;

enum class AnimationInterpolation : uint8_t {
  Step = 0,
  Linear = 1,
  Cubic = 2,
  MIN = Step,
  MAX = Cubic
};

inline const AnimationInterpolation (&EnumValuesAnimationInterpolation())[3] {
  static const AnimationInterpolation values[] = {
    AnimationInterpolation::Step,
    AnimationInterpolation::Linear,
    AnimationInterpolation::Cubic
  };
  return values;
}

inline const char * const *EnumNamesAnimationInterpolation() {
  static const char * const names[4] = {
    "Step",
    "Linear",
    "Cubic",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnimationInterpolation(AnimationInterpolation e) {
  if (::flatbuffers::IsOutRange(e, AnimationInterpolation::Step, AnimationInterpolation::Cubic)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAnimationInterpolation()[index];
}

struct KeyframeAnimationChannel FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyframeAnimationChannelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODE = 4,
    VT_COMPONENT = 6,
    VT_INTERPOLATION = 8,
    VT_VALUES = 10
  };
  const ::flatbuffers::String *node() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NODE);
  }
  DeepSeaAnimation::AnimationComponent component() const {
    return static_cast<DeepSeaAnimation::AnimationComponent>(GetField<uint8_t>(VT_COMPONENT, 0));
  }
  DeepSeaAnimation::AnimationInterpolation interpolation() const {
    return static_cast<DeepSeaAnimation::AnimationInterpolation>(GetField<uint8_t>(VT_INTERPOLATION, 0));
  }
  const ::flatbuffers::Vector<const DeepSeaAnimation::Vector4f *> *values() const {
    return GetPointer<const ::flatbuffers::Vector<const DeepSeaAnimation::Vector4f *> *>(VT_VALUES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NODE) &&
           verifier.VerifyString(node()) &&
           VerifyField<uint8_t>(verifier, VT_COMPONENT, 1) &&
           VerifyField<uint8_t>(verifier, VT_INTERPOLATION, 1) &&
           VerifyOffsetRequired(verifier, VT_VALUES) &&
           verifier.VerifyVector(values()) &&
           verifier.EndTable();
  }
};

struct KeyframeAnimationChannelBuilder {
  typedef KeyframeAnimationChannel Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_node(::flatbuffers::Offset<::flatbuffers::String> node) {
    fbb_.AddOffset(KeyframeAnimationChannel::VT_NODE, node);
  }
  void add_component(DeepSeaAnimation::AnimationComponent component) {
    fbb_.AddElement<uint8_t>(KeyframeAnimationChannel::VT_COMPONENT, static_cast<uint8_t>(component), 0);
  }
  void add_interpolation(DeepSeaAnimation::AnimationInterpolation interpolation) {
    fbb_.AddElement<uint8_t>(KeyframeAnimationChannel::VT_INTERPOLATION, static_cast<uint8_t>(interpolation), 0);
  }
  void add_values(::flatbuffers::Offset<::flatbuffers::Vector<const DeepSeaAnimation::Vector4f *>> values) {
    fbb_.AddOffset(KeyframeAnimationChannel::VT_VALUES, values);
  }
  explicit KeyframeAnimationChannelBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyframeAnimationChannel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyframeAnimationChannel>(end);
    fbb_.Required(o, KeyframeAnimationChannel::VT_NODE);
    fbb_.Required(o, KeyframeAnimationChannel::VT_VALUES);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyframeAnimationChannel> CreateKeyframeAnimationChannel(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> node = 0,
    DeepSeaAnimation::AnimationComponent component = DeepSeaAnimation::AnimationComponent::Translation,
    DeepSeaAnimation::AnimationInterpolation interpolation = DeepSeaAnimation::AnimationInterpolation::Step,
    ::flatbuffers::Offset<::flatbuffers::Vector<const DeepSeaAnimation::Vector4f *>> values = 0) {
  KeyframeAnimationChannelBuilder builder_(_fbb);
  builder_.add_values(values);
  builder_.add_node(node);
  builder_.add_interpolation(interpolation);
  builder_.add_component(component);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KeyframeAnimationChannel> CreateKeyframeAnimationChannelDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *node = nullptr,
    DeepSeaAnimation::AnimationComponent component = DeepSeaAnimation::AnimationComponent::Translation,
    DeepSeaAnimation::AnimationInterpolation interpolation = DeepSeaAnimation::AnimationInterpolation::Step,
    const std::vector<DeepSeaAnimation::Vector4f> *values = nullptr) {
  auto node__ = node ? _fbb.CreateString(node) : 0;
  auto values__ = values ? _fbb.CreateVectorOfStructs<DeepSeaAnimation::Vector4f>(*values) : 0;
  return DeepSeaAnimation::CreateKeyframeAnimationChannel(
      _fbb,
      node__,
      component,
      interpolation,
      values__);
}

struct AnimationKeyframes FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AnimationKeyframesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYFRAMETIMES = 4,
    VT_CHANNELS = 6
  };
  const ::flatbuffers::Vector<float> *keyframeTimes() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_KEYFRAMETIMES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::KeyframeAnimationChannel>> *channels() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::KeyframeAnimationChannel>> *>(VT_CHANNELS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEYFRAMETIMES) &&
           verifier.VerifyVector(keyframeTimes()) &&
           VerifyOffsetRequired(verifier, VT_CHANNELS) &&
           verifier.VerifyVector(channels()) &&
           verifier.VerifyVectorOfTables(channels()) &&
           verifier.EndTable();
  }
};

struct AnimationKeyframesBuilder {
  typedef AnimationKeyframes Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_keyframeTimes(::flatbuffers::Offset<::flatbuffers::Vector<float>> keyframeTimes) {
    fbb_.AddOffset(AnimationKeyframes::VT_KEYFRAMETIMES, keyframeTimes);
  }
  void add_channels(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::KeyframeAnimationChannel>>> channels) {
    fbb_.AddOffset(AnimationKeyframes::VT_CHANNELS, channels);
  }
  explicit AnimationKeyframesBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AnimationKeyframes> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AnimationKeyframes>(end);
    fbb_.Required(o, AnimationKeyframes::VT_KEYFRAMETIMES);
    fbb_.Required(o, AnimationKeyframes::VT_CHANNELS);
    return o;
  }
};

inline ::flatbuffers::Offset<AnimationKeyframes> CreateAnimationKeyframes(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> keyframeTimes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::KeyframeAnimationChannel>>> channels = 0) {
  AnimationKeyframesBuilder builder_(_fbb);
  builder_.add_channels(channels);
  builder_.add_keyframeTimes(keyframeTimes);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<AnimationKeyframes> CreateAnimationKeyframesDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *keyframeTimes = nullptr,
    const std::vector<::flatbuffers::Offset<DeepSeaAnimation::KeyframeAnimationChannel>> *channels = nullptr) {
  auto keyframeTimes__ = keyframeTimes ? _fbb.CreateVector<float>(*keyframeTimes) : 0;
  auto channels__ = channels ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaAnimation::KeyframeAnimationChannel>>(*channels) : 0;
  return DeepSeaAnimation::CreateAnimationKeyframes(
      _fbb,
      keyframeTimes__,
      channels__);
}

struct KeyframeAnimation FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyframeAnimationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEYFRAMES = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationKeyframes>> *keyframes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationKeyframes>> *>(VT_KEYFRAMES);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEYFRAMES) &&
           verifier.VerifyVector(keyframes()) &&
           verifier.VerifyVectorOfTables(keyframes()) &&
           verifier.EndTable();
  }
};

struct KeyframeAnimationBuilder {
  typedef KeyframeAnimation Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_keyframes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationKeyframes>>> keyframes) {
    fbb_.AddOffset(KeyframeAnimation::VT_KEYFRAMES, keyframes);
  }
  explicit KeyframeAnimationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyframeAnimation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyframeAnimation>(end);
    fbb_.Required(o, KeyframeAnimation::VT_KEYFRAMES);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyframeAnimation> CreateKeyframeAnimation(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationKeyframes>>> keyframes = 0) {
  KeyframeAnimationBuilder builder_(_fbb);
  builder_.add_keyframes(keyframes);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<KeyframeAnimation> CreateKeyframeAnimationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<DeepSeaAnimation::AnimationKeyframes>> *keyframes = nullptr) {
  auto keyframes__ = keyframes ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaAnimation::AnimationKeyframes>>(*keyframes) : 0;
  return DeepSeaAnimation::CreateKeyframeAnimation(
      _fbb,
      keyframes__);
}

inline const DeepSeaAnimation::KeyframeAnimation *GetKeyframeAnimation(const void *buf) {
  return ::flatbuffers::GetRoot<DeepSeaAnimation::KeyframeAnimation>(buf);
}

inline const DeepSeaAnimation::KeyframeAnimation *GetSizePrefixedKeyframeAnimation(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<DeepSeaAnimation::KeyframeAnimation>(buf);
}

inline bool VerifyKeyframeAnimationBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DeepSeaAnimation::KeyframeAnimation>(nullptr);
}

inline bool VerifySizePrefixedKeyframeAnimationBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DeepSeaAnimation::KeyframeAnimation>(nullptr);
}

inline void FinishKeyframeAnimationBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DeepSeaAnimation::KeyframeAnimation> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedKeyframeAnimationBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DeepSeaAnimation::KeyframeAnimation> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace DeepSeaAnimation

#endif  // FLATBUFFERS_GENERATED_KEYFRAMEANIMATION_DEEPSEAANIMATION_H_
