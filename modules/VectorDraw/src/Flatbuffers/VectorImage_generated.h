// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VECTORIMAGE_DEEPSEAVECTORDRAW_H_
#define FLATBUFFERS_GENERATED_VECTORIMAGE_DEEPSEAVECTORDRAW_H_

#include "flatbuffers/flatbuffers.h"

namespace DeepSeaVectorDraw {

struct Color;

struct Vector2f;

struct Vector3f;

struct Matrix33f;

struct DashArray;

struct GradientStop;

struct ColorMaterial;

struct LinearGradient;

struct RadialGradient;

struct StartPathCommand;

struct MoveCommand;

struct LineCommand;

struct BezierCommand;

struct QuadraticCommand;

struct ArcCommand;

struct ClosePathCommand;

struct EllipseCommand;

struct RectangleCommand;

struct StrokePathCommand;

struct FillPathCommand;

struct TextCommand;

struct TextRangeCommand;

struct ImageCommand;

struct VectorCommand;

struct VectorImage;

enum class GradientEdge : uint8_t {
  Clamp = 0,
  Repeat = 1,
  Mirror = 2,
  MIN = Clamp,
  MAX = Mirror
};

inline const GradientEdge (&EnumValuesGradientEdge())[3] {
  static const GradientEdge values[] = {
    GradientEdge::Clamp,
    GradientEdge::Repeat,
    GradientEdge::Mirror
  };
  return values;
}

inline const char * const *EnumNamesGradientEdge() {
  static const char * const names[] = {
    "Clamp",
    "Repeat",
    "Mirror",
    nullptr
  };
  return names;
}

inline const char *EnumNameGradientEdge(GradientEdge e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesGradientEdge()[index];
}

enum class MaterialSpace : uint8_t {
  Local = 0,
  Bounds = 1,
  MIN = Local,
  MAX = Bounds
};

inline const MaterialSpace (&EnumValuesMaterialSpace())[2] {
  static const MaterialSpace values[] = {
    MaterialSpace::Local,
    MaterialSpace::Bounds
  };
  return values;
}

inline const char * const *EnumNamesMaterialSpace() {
  static const char * const names[] = {
    "Local",
    "Bounds",
    nullptr
  };
  return names;
}

inline const char *EnumNameMaterialSpace(MaterialSpace e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMaterialSpace()[index];
}

enum class LineJoin : uint8_t {
  Miter = 0,
  Bevel = 1,
  Round = 2,
  MIN = Miter,
  MAX = Round
};

inline const LineJoin (&EnumValuesLineJoin())[3] {
  static const LineJoin values[] = {
    LineJoin::Miter,
    LineJoin::Bevel,
    LineJoin::Round
  };
  return values;
}

inline const char * const *EnumNamesLineJoin() {
  static const char * const names[] = {
    "Miter",
    "Bevel",
    "Round",
    nullptr
  };
  return names;
}

inline const char *EnumNameLineJoin(LineJoin e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLineJoin()[index];
}

enum class LineCap : uint8_t {
  Butt = 0,
  Round = 1,
  Square = 2,
  MIN = Butt,
  MAX = Square
};

inline const LineCap (&EnumValuesLineCap())[3] {
  static const LineCap values[] = {
    LineCap::Butt,
    LineCap::Round,
    LineCap::Square
  };
  return values;
}

inline const char * const *EnumNamesLineCap() {
  static const char * const names[] = {
    "Butt",
    "Round",
    "Square",
    nullptr
  };
  return names;
}

inline const char *EnumNameLineCap(LineCap e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLineCap()[index];
}

enum class FillRule : uint8_t {
  EvenOdd = 0,
  NonZero = 1,
  MIN = EvenOdd,
  MAX = NonZero
};

inline const FillRule (&EnumValuesFillRule())[2] {
  static const FillRule values[] = {
    FillRule::EvenOdd,
    FillRule::NonZero
  };
  return values;
}

inline const char * const *EnumNamesFillRule() {
  static const char * const names[] = {
    "EvenOdd",
    "NonZero",
    nullptr
  };
  return names;
}

inline const char *EnumNameFillRule(FillRule e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesFillRule()[index];
}

enum class TextPosition : uint8_t {
  Offset = 0,
  Absolute = 1,
  MIN = Offset,
  MAX = Absolute
};

inline const TextPosition (&EnumValuesTextPosition())[2] {
  static const TextPosition values[] = {
    TextPosition::Offset,
    TextPosition::Absolute
  };
  return values;
}

inline const char * const *EnumNamesTextPosition() {
  static const char * const names[] = {
    "Offset",
    "Absolute",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextPosition(TextPosition e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTextPosition()[index];
}

enum class TextAlign : uint8_t {
  Start = 0,
  End = 1,
  Left = 2,
  Right = 3,
  Center = 4,
  MIN = Start,
  MAX = Center
};

inline const TextAlign (&EnumValuesTextAlign())[5] {
  static const TextAlign values[] = {
    TextAlign::Start,
    TextAlign::End,
    TextAlign::Left,
    TextAlign::Right,
    TextAlign::Center
  };
  return values;
}

inline const char * const *EnumNamesTextAlign() {
  static const char * const names[] = {
    "Start",
    "End",
    "Left",
    "Right",
    "Center",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextAlign(TextAlign e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTextAlign()[index];
}

enum class VectorCommandUnion : uint8_t {
  NONE = 0,
  StartPathCommand = 1,
  MoveCommand = 2,
  LineCommand = 3,
  BezierCommand = 4,
  QuadraticCommand = 5,
  ArcCommand = 6,
  ClosePathCommand = 7,
  EllipseCommand = 8,
  RectangleCommand = 9,
  StrokePathCommand = 10,
  FillPathCommand = 11,
  TextCommand = 12,
  TextRangeCommand = 13,
  ImageCommand = 14,
  MIN = NONE,
  MAX = ImageCommand
};

inline const VectorCommandUnion (&EnumValuesVectorCommandUnion())[15] {
  static const VectorCommandUnion values[] = {
    VectorCommandUnion::NONE,
    VectorCommandUnion::StartPathCommand,
    VectorCommandUnion::MoveCommand,
    VectorCommandUnion::LineCommand,
    VectorCommandUnion::BezierCommand,
    VectorCommandUnion::QuadraticCommand,
    VectorCommandUnion::ArcCommand,
    VectorCommandUnion::ClosePathCommand,
    VectorCommandUnion::EllipseCommand,
    VectorCommandUnion::RectangleCommand,
    VectorCommandUnion::StrokePathCommand,
    VectorCommandUnion::FillPathCommand,
    VectorCommandUnion::TextCommand,
    VectorCommandUnion::TextRangeCommand,
    VectorCommandUnion::ImageCommand
  };
  return values;
}

inline const char * const *EnumNamesVectorCommandUnion() {
  static const char * const names[] = {
    "NONE",
    "StartPathCommand",
    "MoveCommand",
    "LineCommand",
    "BezierCommand",
    "QuadraticCommand",
    "ArcCommand",
    "ClosePathCommand",
    "EllipseCommand",
    "RectangleCommand",
    "StrokePathCommand",
    "FillPathCommand",
    "TextCommand",
    "TextRangeCommand",
    "ImageCommand",
    nullptr
  };
  return names;
}

inline const char *EnumNameVectorCommandUnion(VectorCommandUnion e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesVectorCommandUnion()[index];
}

template<typename T> struct VectorCommandUnionTraits {
  static const VectorCommandUnion enum_value = VectorCommandUnion::NONE;
};

template<> struct VectorCommandUnionTraits<StartPathCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::StartPathCommand;
};

template<> struct VectorCommandUnionTraits<MoveCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::MoveCommand;
};

template<> struct VectorCommandUnionTraits<LineCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::LineCommand;
};

template<> struct VectorCommandUnionTraits<BezierCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::BezierCommand;
};

template<> struct VectorCommandUnionTraits<QuadraticCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::QuadraticCommand;
};

template<> struct VectorCommandUnionTraits<ArcCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::ArcCommand;
};

template<> struct VectorCommandUnionTraits<ClosePathCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::ClosePathCommand;
};

template<> struct VectorCommandUnionTraits<EllipseCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::EllipseCommand;
};

template<> struct VectorCommandUnionTraits<RectangleCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::RectangleCommand;
};

template<> struct VectorCommandUnionTraits<StrokePathCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::StrokePathCommand;
};

template<> struct VectorCommandUnionTraits<FillPathCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::FillPathCommand;
};

template<> struct VectorCommandUnionTraits<TextCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::TextCommand;
};

template<> struct VectorCommandUnionTraits<TextRangeCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::TextRangeCommand;
};

template<> struct VectorCommandUnionTraits<ImageCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::ImageCommand;
};

bool VerifyVectorCommandUnion(flatbuffers::Verifier &verifier, const void *obj, VectorCommandUnion type);
bool VerifyVectorCommandUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Color FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;
  uint8_t a_;

 public:
  Color() {
    memset(this, 0, sizeof(Color));
  }
  Color(uint8_t _r, uint8_t _g, uint8_t _b, uint8_t _a)
      : r_(flatbuffers::EndianScalar(_r)),
        g_(flatbuffers::EndianScalar(_g)),
        b_(flatbuffers::EndianScalar(_b)),
        a_(flatbuffers::EndianScalar(_a)) {
  }
  uint8_t r() const {
    return flatbuffers::EndianScalar(r_);
  }
  uint8_t g() const {
    return flatbuffers::EndianScalar(g_);
  }
  uint8_t b() const {
    return flatbuffers::EndianScalar(b_);
  }
  uint8_t a() const {
    return flatbuffers::EndianScalar(a_);
  }
};
FLATBUFFERS_STRUCT_END(Color, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector2f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vector2f() {
    memset(this, 0, sizeof(Vector2f));
  }
  Vector2f(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vector2f, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector3f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector3f() {
    memset(this, 0, sizeof(Vector3f));
  }
  Vector3f(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vector3f, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Matrix33f FLATBUFFERS_FINAL_CLASS {
 private:
  Vector3f column0_;
  Vector3f column1_;
  Vector3f column2_;

 public:
  Matrix33f() {
    memset(this, 0, sizeof(Matrix33f));
  }
  Matrix33f(const Vector3f &_column0, const Vector3f &_column1, const Vector3f &_column2)
      : column0_(_column0),
        column1_(_column1),
        column2_(_column2) {
  }
  const Vector3f &column0() const {
    return column0_;
  }
  const Vector3f &column1() const {
    return column1_;
  }
  const Vector3f &column2() const {
    return column2_;
  }
};
FLATBUFFERS_STRUCT_END(Matrix33f, 36);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) DashArray FLATBUFFERS_FINAL_CLASS {
 private:
  float solid0_;
  float gap0_;
  float solid1_;
  float gap1_;

 public:
  DashArray() {
    memset(this, 0, sizeof(DashArray));
  }
  DashArray(float _solid0, float _gap0, float _solid1, float _gap1)
      : solid0_(flatbuffers::EndianScalar(_solid0)),
        gap0_(flatbuffers::EndianScalar(_gap0)),
        solid1_(flatbuffers::EndianScalar(_solid1)),
        gap1_(flatbuffers::EndianScalar(_gap1)) {
  }
  float solid0() const {
    return flatbuffers::EndianScalar(solid0_);
  }
  float gap0() const {
    return flatbuffers::EndianScalar(gap0_);
  }
  float solid1() const {
    return flatbuffers::EndianScalar(solid1_);
  }
  float gap1() const {
    return flatbuffers::EndianScalar(gap1_);
  }
};
FLATBUFFERS_STRUCT_END(DashArray, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) GradientStop FLATBUFFERS_FINAL_CLASS {
 private:
  float position_;
  Color color_;

 public:
  GradientStop() {
    memset(this, 0, sizeof(GradientStop));
  }
  GradientStop(float _position, const Color &_color)
      : position_(flatbuffers::EndianScalar(_position)),
        color_(_color) {
  }
  float position() const {
    return flatbuffers::EndianScalar(position_);
  }
  const Color &color() const {
    return color_;
  }
};
FLATBUFFERS_STRUCT_END(GradientStop, 8);

struct ColorMaterial FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_COLOR = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const Color *color() const {
    return GetStruct<const Color *>(VT_COLOR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyFieldRequired<Color>(verifier, VT_COLOR) &&
           verifier.EndTable();
  }
};

struct ColorMaterialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(ColorMaterial::VT_NAME, name);
  }
  void add_color(const Color *color) {
    fbb_.AddStruct(ColorMaterial::VT_COLOR, color);
  }
  explicit ColorMaterialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ColorMaterialBuilder &operator=(const ColorMaterialBuilder &);
  flatbuffers::Offset<ColorMaterial> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ColorMaterial>(end);
    fbb_.Required(o, ColorMaterial::VT_NAME);
    fbb_.Required(o, ColorMaterial::VT_COLOR);
    return o;
  }
};

inline flatbuffers::Offset<ColorMaterial> CreateColorMaterial(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    const Color *color = 0) {
  ColorMaterialBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<ColorMaterial> CreateColorMaterialDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const Color *color = 0) {
  return DeepSeaVectorDraw::CreateColorMaterial(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      color);
}

struct LinearGradient FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_GRADIENT = 6,
    VT_START = 8,
    VT_END = 10,
    VT_EDGE = 12,
    VT_COORDINATESPACE = 14,
    VT_TRANSFORM = 16
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<const GradientStop *> *gradient() const {
    return GetPointer<const flatbuffers::Vector<const GradientStop *> *>(VT_GRADIENT);
  }
  const Vector2f *start() const {
    return GetStruct<const Vector2f *>(VT_START);
  }
  const Vector2f *end() const {
    return GetStruct<const Vector2f *>(VT_END);
  }
  GradientEdge edge() const {
    return static_cast<GradientEdge>(GetField<uint8_t>(VT_EDGE, 0));
  }
  MaterialSpace coordinateSpace() const {
    return static_cast<MaterialSpace>(GetField<uint8_t>(VT_COORDINATESPACE, 0));
  }
  const Matrix33f *transform() const {
    return GetStruct<const Matrix33f *>(VT_TRANSFORM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_GRADIENT) &&
           verifier.VerifyVector(gradient()) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_START) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_END) &&
           VerifyField<uint8_t>(verifier, VT_EDGE) &&
           VerifyField<uint8_t>(verifier, VT_COORDINATESPACE) &&
           VerifyFieldRequired<Matrix33f>(verifier, VT_TRANSFORM) &&
           verifier.EndTable();
  }
};

struct LinearGradientBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(LinearGradient::VT_NAME, name);
  }
  void add_gradient(flatbuffers::Offset<flatbuffers::Vector<const GradientStop *>> gradient) {
    fbb_.AddOffset(LinearGradient::VT_GRADIENT, gradient);
  }
  void add_start(const Vector2f *start) {
    fbb_.AddStruct(LinearGradient::VT_START, start);
  }
  void add_end(const Vector2f *end) {
    fbb_.AddStruct(LinearGradient::VT_END, end);
  }
  void add_edge(GradientEdge edge) {
    fbb_.AddElement<uint8_t>(LinearGradient::VT_EDGE, static_cast<uint8_t>(edge), 0);
  }
  void add_coordinateSpace(MaterialSpace coordinateSpace) {
    fbb_.AddElement<uint8_t>(LinearGradient::VT_COORDINATESPACE, static_cast<uint8_t>(coordinateSpace), 0);
  }
  void add_transform(const Matrix33f *transform) {
    fbb_.AddStruct(LinearGradient::VT_TRANSFORM, transform);
  }
  explicit LinearGradientBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LinearGradientBuilder &operator=(const LinearGradientBuilder &);
  flatbuffers::Offset<LinearGradient> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LinearGradient>(end);
    fbb_.Required(o, LinearGradient::VT_NAME);
    fbb_.Required(o, LinearGradient::VT_GRADIENT);
    fbb_.Required(o, LinearGradient::VT_START);
    fbb_.Required(o, LinearGradient::VT_END);
    fbb_.Required(o, LinearGradient::VT_TRANSFORM);
    return o;
  }
};

inline flatbuffers::Offset<LinearGradient> CreateLinearGradient(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GradientStop *>> gradient = 0,
    const Vector2f *start = 0,
    const Vector2f *end = 0,
    GradientEdge edge = GradientEdge::Clamp,
    MaterialSpace coordinateSpace = MaterialSpace::Local,
    const Matrix33f *transform = 0) {
  LinearGradientBuilder builder_(_fbb);
  builder_.add_transform(transform);
  builder_.add_end(end);
  builder_.add_start(start);
  builder_.add_gradient(gradient);
  builder_.add_name(name);
  builder_.add_coordinateSpace(coordinateSpace);
  builder_.add_edge(edge);
  return builder_.Finish();
}

inline flatbuffers::Offset<LinearGradient> CreateLinearGradientDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<GradientStop> *gradient = nullptr,
    const Vector2f *start = 0,
    const Vector2f *end = 0,
    GradientEdge edge = GradientEdge::Clamp,
    MaterialSpace coordinateSpace = MaterialSpace::Local,
    const Matrix33f *transform = 0) {
  return DeepSeaVectorDraw::CreateLinearGradient(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      gradient ? _fbb.CreateVectorOfStructs<GradientStop>(*gradient) : 0,
      start,
      end,
      edge,
      coordinateSpace,
      transform);
}

struct RadialGradient FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_GRADIENT = 6,
    VT_CENTER = 8,
    VT_RADIUS = 10,
    VT_FOCUS = 12,
    VT_FOCUSRADIUS = 14,
    VT_EDGE = 16,
    VT_COORDINATESPACE = 18,
    VT_TRANSFORM = 20
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<const GradientStop *> *gradient() const {
    return GetPointer<const flatbuffers::Vector<const GradientStop *> *>(VT_GRADIENT);
  }
  const Vector2f *center() const {
    return GetStruct<const Vector2f *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  const Vector2f *focus() const {
    return GetStruct<const Vector2f *>(VT_FOCUS);
  }
  float focusRadius() const {
    return GetField<float>(VT_FOCUSRADIUS, 0.0f);
  }
  GradientEdge edge() const {
    return static_cast<GradientEdge>(GetField<uint8_t>(VT_EDGE, 0));
  }
  MaterialSpace coordinateSpace() const {
    return static_cast<MaterialSpace>(GetField<uint8_t>(VT_COORDINATESPACE, 0));
  }
  const Matrix33f *transform() const {
    return GetStruct<const Matrix33f *>(VT_TRANSFORM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_GRADIENT) &&
           verifier.VerifyVector(gradient()) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_CENTER) &&
           VerifyField<float>(verifier, VT_RADIUS) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_FOCUS) &&
           VerifyField<float>(verifier, VT_FOCUSRADIUS) &&
           VerifyField<uint8_t>(verifier, VT_EDGE) &&
           VerifyField<uint8_t>(verifier, VT_COORDINATESPACE) &&
           VerifyFieldRequired<Matrix33f>(verifier, VT_TRANSFORM) &&
           verifier.EndTable();
  }
};

struct RadialGradientBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(RadialGradient::VT_NAME, name);
  }
  void add_gradient(flatbuffers::Offset<flatbuffers::Vector<const GradientStop *>> gradient) {
    fbb_.AddOffset(RadialGradient::VT_GRADIENT, gradient);
  }
  void add_center(const Vector2f *center) {
    fbb_.AddStruct(RadialGradient::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(RadialGradient::VT_RADIUS, radius, 0.0f);
  }
  void add_focus(const Vector2f *focus) {
    fbb_.AddStruct(RadialGradient::VT_FOCUS, focus);
  }
  void add_focusRadius(float focusRadius) {
    fbb_.AddElement<float>(RadialGradient::VT_FOCUSRADIUS, focusRadius, 0.0f);
  }
  void add_edge(GradientEdge edge) {
    fbb_.AddElement<uint8_t>(RadialGradient::VT_EDGE, static_cast<uint8_t>(edge), 0);
  }
  void add_coordinateSpace(MaterialSpace coordinateSpace) {
    fbb_.AddElement<uint8_t>(RadialGradient::VT_COORDINATESPACE, static_cast<uint8_t>(coordinateSpace), 0);
  }
  void add_transform(const Matrix33f *transform) {
    fbb_.AddStruct(RadialGradient::VT_TRANSFORM, transform);
  }
  explicit RadialGradientBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RadialGradientBuilder &operator=(const RadialGradientBuilder &);
  flatbuffers::Offset<RadialGradient> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RadialGradient>(end);
    fbb_.Required(o, RadialGradient::VT_NAME);
    fbb_.Required(o, RadialGradient::VT_GRADIENT);
    fbb_.Required(o, RadialGradient::VT_CENTER);
    fbb_.Required(o, RadialGradient::VT_FOCUS);
    fbb_.Required(o, RadialGradient::VT_TRANSFORM);
    return o;
  }
};

inline flatbuffers::Offset<RadialGradient> CreateRadialGradient(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<const GradientStop *>> gradient = 0,
    const Vector2f *center = 0,
    float radius = 0.0f,
    const Vector2f *focus = 0,
    float focusRadius = 0.0f,
    GradientEdge edge = GradientEdge::Clamp,
    MaterialSpace coordinateSpace = MaterialSpace::Local,
    const Matrix33f *transform = 0) {
  RadialGradientBuilder builder_(_fbb);
  builder_.add_transform(transform);
  builder_.add_focusRadius(focusRadius);
  builder_.add_focus(focus);
  builder_.add_radius(radius);
  builder_.add_center(center);
  builder_.add_gradient(gradient);
  builder_.add_name(name);
  builder_.add_coordinateSpace(coordinateSpace);
  builder_.add_edge(edge);
  return builder_.Finish();
}

inline flatbuffers::Offset<RadialGradient> CreateRadialGradientDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<GradientStop> *gradient = nullptr,
    const Vector2f *center = 0,
    float radius = 0.0f,
    const Vector2f *focus = 0,
    float focusRadius = 0.0f,
    GradientEdge edge = GradientEdge::Clamp,
    MaterialSpace coordinateSpace = MaterialSpace::Local,
    const Matrix33f *transform = 0) {
  return DeepSeaVectorDraw::CreateRadialGradient(
      _fbb,
      name ? _fbb.CreateString(name) : 0,
      gradient ? _fbb.CreateVectorOfStructs<GradientStop>(*gradient) : 0,
      center,
      radius,
      focus,
      focusRadius,
      edge,
      coordinateSpace,
      transform);
}

struct StartPathCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TRANSFORM = 4,
    VT_SIMPLE = 6
  };
  const Matrix33f *transform() const {
    return GetStruct<const Matrix33f *>(VT_TRANSFORM);
  }
  bool simple() const {
    return GetField<uint8_t>(VT_SIMPLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<Matrix33f>(verifier, VT_TRANSFORM) &&
           VerifyField<uint8_t>(verifier, VT_SIMPLE) &&
           verifier.EndTable();
  }
};

struct StartPathCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transform(const Matrix33f *transform) {
    fbb_.AddStruct(StartPathCommand::VT_TRANSFORM, transform);
  }
  void add_simple(bool simple) {
    fbb_.AddElement<uint8_t>(StartPathCommand::VT_SIMPLE, static_cast<uint8_t>(simple), 0);
  }
  explicit StartPathCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StartPathCommandBuilder &operator=(const StartPathCommandBuilder &);
  flatbuffers::Offset<StartPathCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StartPathCommand>(end);
    fbb_.Required(o, StartPathCommand::VT_TRANSFORM);
    return o;
  }
};

inline flatbuffers::Offset<StartPathCommand> CreateStartPathCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Matrix33f *transform = 0,
    bool simple = false) {
  StartPathCommandBuilder builder_(_fbb);
  builder_.add_transform(transform);
  builder_.add_simple(simple);
  return builder_.Finish();
}

struct MoveCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POSITION = 4
  };
  const Vector2f *position() const {
    return GetStruct<const Vector2f *>(VT_POSITION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_POSITION) &&
           verifier.EndTable();
  }
};

struct MoveCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_position(const Vector2f *position) {
    fbb_.AddStruct(MoveCommand::VT_POSITION, position);
  }
  explicit MoveCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveCommandBuilder &operator=(const MoveCommandBuilder &);
  flatbuffers::Offset<MoveCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveCommand>(end);
    fbb_.Required(o, MoveCommand::VT_POSITION);
    return o;
  }
};

inline flatbuffers::Offset<MoveCommand> CreateMoveCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vector2f *position = 0) {
  MoveCommandBuilder builder_(_fbb);
  builder_.add_position(position);
  return builder_.Finish();
}

struct LineCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_END = 4
  };
  const Vector2f *end() const {
    return GetStruct<const Vector2f *>(VT_END);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_END) &&
           verifier.EndTable();
  }
};

struct LineCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_end(const Vector2f *end) {
    fbb_.AddStruct(LineCommand::VT_END, end);
  }
  explicit LineCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LineCommandBuilder &operator=(const LineCommandBuilder &);
  flatbuffers::Offset<LineCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LineCommand>(end);
    fbb_.Required(o, LineCommand::VT_END);
    return o;
  }
};

inline flatbuffers::Offset<LineCommand> CreateLineCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vector2f *end = 0) {
  LineCommandBuilder builder_(_fbb);
  builder_.add_end(end);
  return builder_.Finish();
}

struct BezierCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROL1 = 4,
    VT_CONTROL2 = 6,
    VT_END = 8
  };
  const Vector2f *control1() const {
    return GetStruct<const Vector2f *>(VT_CONTROL1);
  }
  const Vector2f *control2() const {
    return GetStruct<const Vector2f *>(VT_CONTROL2);
  }
  const Vector2f *end() const {
    return GetStruct<const Vector2f *>(VT_END);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_CONTROL1) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_CONTROL2) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_END) &&
           verifier.EndTable();
  }
};

struct BezierCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_control1(const Vector2f *control1) {
    fbb_.AddStruct(BezierCommand::VT_CONTROL1, control1);
  }
  void add_control2(const Vector2f *control2) {
    fbb_.AddStruct(BezierCommand::VT_CONTROL2, control2);
  }
  void add_end(const Vector2f *end) {
    fbb_.AddStruct(BezierCommand::VT_END, end);
  }
  explicit BezierCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BezierCommandBuilder &operator=(const BezierCommandBuilder &);
  flatbuffers::Offset<BezierCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BezierCommand>(end);
    fbb_.Required(o, BezierCommand::VT_CONTROL1);
    fbb_.Required(o, BezierCommand::VT_CONTROL2);
    fbb_.Required(o, BezierCommand::VT_END);
    return o;
  }
};

inline flatbuffers::Offset<BezierCommand> CreateBezierCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vector2f *control1 = 0,
    const Vector2f *control2 = 0,
    const Vector2f *end = 0) {
  BezierCommandBuilder builder_(_fbb);
  builder_.add_end(end);
  builder_.add_control2(control2);
  builder_.add_control1(control1);
  return builder_.Finish();
}

struct QuadraticCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTROL = 4,
    VT_END = 6
  };
  const Vector2f *control() const {
    return GetStruct<const Vector2f *>(VT_CONTROL);
  }
  const Vector2f *end() const {
    return GetStruct<const Vector2f *>(VT_END);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_CONTROL) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_END) &&
           verifier.EndTable();
  }
};

struct QuadraticCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_control(const Vector2f *control) {
    fbb_.AddStruct(QuadraticCommand::VT_CONTROL, control);
  }
  void add_end(const Vector2f *end) {
    fbb_.AddStruct(QuadraticCommand::VT_END, end);
  }
  explicit QuadraticCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuadraticCommandBuilder &operator=(const QuadraticCommandBuilder &);
  flatbuffers::Offset<QuadraticCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuadraticCommand>(end);
    fbb_.Required(o, QuadraticCommand::VT_CONTROL);
    fbb_.Required(o, QuadraticCommand::VT_END);
    return o;
  }
};

inline flatbuffers::Offset<QuadraticCommand> CreateQuadraticCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vector2f *control = 0,
    const Vector2f *end = 0) {
  QuadraticCommandBuilder builder_(_fbb);
  builder_.add_end(end);
  builder_.add_control(control);
  return builder_.Finish();
}

struct ArcCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RADIUS = 4,
    VT_ROTATION = 6,
    VT_LARGEARC = 8,
    VT_CLOCKWISE = 10,
    VT_END = 12
  };
  const Vector2f *radius() const {
    return GetStruct<const Vector2f *>(VT_RADIUS);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool largeArc() const {
    return GetField<uint8_t>(VT_LARGEARC, 0) != 0;
  }
  bool clockwise() const {
    return GetField<uint8_t>(VT_CLOCKWISE, 0) != 0;
  }
  const Vector2f *end() const {
    return GetStruct<const Vector2f *>(VT_END);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_RADIUS) &&
           VerifyField<float>(verifier, VT_ROTATION) &&
           VerifyField<uint8_t>(verifier, VT_LARGEARC) &&
           VerifyField<uint8_t>(verifier, VT_CLOCKWISE) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_END) &&
           verifier.EndTable();
  }
};

struct ArcCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_radius(const Vector2f *radius) {
    fbb_.AddStruct(ArcCommand::VT_RADIUS, radius);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(ArcCommand::VT_ROTATION, rotation, 0.0f);
  }
  void add_largeArc(bool largeArc) {
    fbb_.AddElement<uint8_t>(ArcCommand::VT_LARGEARC, static_cast<uint8_t>(largeArc), 0);
  }
  void add_clockwise(bool clockwise) {
    fbb_.AddElement<uint8_t>(ArcCommand::VT_CLOCKWISE, static_cast<uint8_t>(clockwise), 0);
  }
  void add_end(const Vector2f *end) {
    fbb_.AddStruct(ArcCommand::VT_END, end);
  }
  explicit ArcCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArcCommandBuilder &operator=(const ArcCommandBuilder &);
  flatbuffers::Offset<ArcCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArcCommand>(end);
    fbb_.Required(o, ArcCommand::VT_RADIUS);
    fbb_.Required(o, ArcCommand::VT_END);
    return o;
  }
};

inline flatbuffers::Offset<ArcCommand> CreateArcCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vector2f *radius = 0,
    float rotation = 0.0f,
    bool largeArc = false,
    bool clockwise = false,
    const Vector2f *end = 0) {
  ArcCommandBuilder builder_(_fbb);
  builder_.add_end(end);
  builder_.add_rotation(rotation);
  builder_.add_radius(radius);
  builder_.add_clockwise(clockwise);
  builder_.add_largeArc(largeArc);
  return builder_.Finish();
}

struct ClosePathCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ClosePathCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ClosePathCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClosePathCommandBuilder &operator=(const ClosePathCommandBuilder &);
  flatbuffers::Offset<ClosePathCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ClosePathCommand>(end);
    return o;
  }
};

inline flatbuffers::Offset<ClosePathCommand> CreateClosePathCommand(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ClosePathCommandBuilder builder_(_fbb);
  return builder_.Finish();
}

struct EllipseCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CENTER = 4,
    VT_RADIUS = 6
  };
  const Vector2f *center() const {
    return GetStruct<const Vector2f *>(VT_CENTER);
  }
  const Vector2f *radius() const {
    return GetStruct<const Vector2f *>(VT_RADIUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_CENTER) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_RADIUS) &&
           verifier.EndTable();
  }
};

struct EllipseCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_center(const Vector2f *center) {
    fbb_.AddStruct(EllipseCommand::VT_CENTER, center);
  }
  void add_radius(const Vector2f *radius) {
    fbb_.AddStruct(EllipseCommand::VT_RADIUS, radius);
  }
  explicit EllipseCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EllipseCommandBuilder &operator=(const EllipseCommandBuilder &);
  flatbuffers::Offset<EllipseCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EllipseCommand>(end);
    fbb_.Required(o, EllipseCommand::VT_CENTER);
    fbb_.Required(o, EllipseCommand::VT_RADIUS);
    return o;
  }
};

inline flatbuffers::Offset<EllipseCommand> CreateEllipseCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vector2f *center = 0,
    const Vector2f *radius = 0) {
  EllipseCommandBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_center(center);
  return builder_.Finish();
}

struct RectangleCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_UPPERLEFT = 4,
    VT_LOWERRIGHT = 6,
    VT_CORNERRADIUS = 8
  };
  const Vector2f *upperLeft() const {
    return GetStruct<const Vector2f *>(VT_UPPERLEFT);
  }
  const Vector2f *lowerRight() const {
    return GetStruct<const Vector2f *>(VT_LOWERRIGHT);
  }
  const Vector2f *cornerRadius() const {
    return GetStruct<const Vector2f *>(VT_CORNERRADIUS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_UPPERLEFT) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_LOWERRIGHT) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_CORNERRADIUS) &&
           verifier.EndTable();
  }
};

struct RectangleCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_upperLeft(const Vector2f *upperLeft) {
    fbb_.AddStruct(RectangleCommand::VT_UPPERLEFT, upperLeft);
  }
  void add_lowerRight(const Vector2f *lowerRight) {
    fbb_.AddStruct(RectangleCommand::VT_LOWERRIGHT, lowerRight);
  }
  void add_cornerRadius(const Vector2f *cornerRadius) {
    fbb_.AddStruct(RectangleCommand::VT_CORNERRADIUS, cornerRadius);
  }
  explicit RectangleCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RectangleCommandBuilder &operator=(const RectangleCommandBuilder &);
  flatbuffers::Offset<RectangleCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RectangleCommand>(end);
    fbb_.Required(o, RectangleCommand::VT_UPPERLEFT);
    fbb_.Required(o, RectangleCommand::VT_LOWERRIGHT);
    fbb_.Required(o, RectangleCommand::VT_CORNERRADIUS);
    return o;
  }
};

inline flatbuffers::Offset<RectangleCommand> CreateRectangleCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Vector2f *upperLeft = 0,
    const Vector2f *lowerRight = 0,
    const Vector2f *cornerRadius = 0) {
  RectangleCommandBuilder builder_(_fbb);
  builder_.add_cornerRadius(cornerRadius);
  builder_.add_lowerRight(lowerRight);
  builder_.add_upperLeft(upperLeft);
  return builder_.Finish();
}

struct StrokePathCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MATERIAL = 4,
    VT_OPACITY = 6,
    VT_JOINTYPE = 8,
    VT_CAPTYPE = 10,
    VT_WIDTH = 12,
    VT_MITERLIMIT = 14,
    VT_DASHARRAY = 16
  };
  const flatbuffers::String *material() const {
    return GetPointer<const flatbuffers::String *>(VT_MATERIAL);
  }
  float opacity() const {
    return GetField<float>(VT_OPACITY, 0.0f);
  }
  LineJoin joinType() const {
    return static_cast<LineJoin>(GetField<uint8_t>(VT_JOINTYPE, 0));
  }
  LineCap capType() const {
    return static_cast<LineCap>(GetField<uint8_t>(VT_CAPTYPE, 0));
  }
  float width() const {
    return GetField<float>(VT_WIDTH, 0.0f);
  }
  float miterLimit() const {
    return GetField<float>(VT_MITERLIMIT, 0.0f);
  }
  const DashArray *dashArray() const {
    return GetStruct<const DashArray *>(VT_DASHARRAY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MATERIAL) &&
           verifier.VerifyString(material()) &&
           VerifyField<float>(verifier, VT_OPACITY) &&
           VerifyField<uint8_t>(verifier, VT_JOINTYPE) &&
           VerifyField<uint8_t>(verifier, VT_CAPTYPE) &&
           VerifyField<float>(verifier, VT_WIDTH) &&
           VerifyField<float>(verifier, VT_MITERLIMIT) &&
           VerifyFieldRequired<DashArray>(verifier, VT_DASHARRAY) &&
           verifier.EndTable();
  }
};

struct StrokePathCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_material(flatbuffers::Offset<flatbuffers::String> material) {
    fbb_.AddOffset(StrokePathCommand::VT_MATERIAL, material);
  }
  void add_opacity(float opacity) {
    fbb_.AddElement<float>(StrokePathCommand::VT_OPACITY, opacity, 0.0f);
  }
  void add_joinType(LineJoin joinType) {
    fbb_.AddElement<uint8_t>(StrokePathCommand::VT_JOINTYPE, static_cast<uint8_t>(joinType), 0);
  }
  void add_capType(LineCap capType) {
    fbb_.AddElement<uint8_t>(StrokePathCommand::VT_CAPTYPE, static_cast<uint8_t>(capType), 0);
  }
  void add_width(float width) {
    fbb_.AddElement<float>(StrokePathCommand::VT_WIDTH, width, 0.0f);
  }
  void add_miterLimit(float miterLimit) {
    fbb_.AddElement<float>(StrokePathCommand::VT_MITERLIMIT, miterLimit, 0.0f);
  }
  void add_dashArray(const DashArray *dashArray) {
    fbb_.AddStruct(StrokePathCommand::VT_DASHARRAY, dashArray);
  }
  explicit StrokePathCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StrokePathCommandBuilder &operator=(const StrokePathCommandBuilder &);
  flatbuffers::Offset<StrokePathCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StrokePathCommand>(end);
    fbb_.Required(o, StrokePathCommand::VT_MATERIAL);
    fbb_.Required(o, StrokePathCommand::VT_DASHARRAY);
    return o;
  }
};

inline flatbuffers::Offset<StrokePathCommand> CreateStrokePathCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> material = 0,
    float opacity = 0.0f,
    LineJoin joinType = LineJoin::Miter,
    LineCap capType = LineCap::Butt,
    float width = 0.0f,
    float miterLimit = 0.0f,
    const DashArray *dashArray = 0) {
  StrokePathCommandBuilder builder_(_fbb);
  builder_.add_dashArray(dashArray);
  builder_.add_miterLimit(miterLimit);
  builder_.add_width(width);
  builder_.add_opacity(opacity);
  builder_.add_material(material);
  builder_.add_capType(capType);
  builder_.add_joinType(joinType);
  return builder_.Finish();
}

inline flatbuffers::Offset<StrokePathCommand> CreateStrokePathCommandDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *material = nullptr,
    float opacity = 0.0f,
    LineJoin joinType = LineJoin::Miter,
    LineCap capType = LineCap::Butt,
    float width = 0.0f,
    float miterLimit = 0.0f,
    const DashArray *dashArray = 0) {
  return DeepSeaVectorDraw::CreateStrokePathCommand(
      _fbb,
      material ? _fbb.CreateString(material) : 0,
      opacity,
      joinType,
      capType,
      width,
      miterLimit,
      dashArray);
}

struct FillPathCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MATERIAL = 4,
    VT_OPACITY = 6,
    VT_FILLRULE = 8
  };
  const flatbuffers::String *material() const {
    return GetPointer<const flatbuffers::String *>(VT_MATERIAL);
  }
  float opacity() const {
    return GetField<float>(VT_OPACITY, 0.0f);
  }
  FillRule fillRule() const {
    return static_cast<FillRule>(GetField<uint8_t>(VT_FILLRULE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MATERIAL) &&
           verifier.VerifyString(material()) &&
           VerifyField<float>(verifier, VT_OPACITY) &&
           VerifyField<uint8_t>(verifier, VT_FILLRULE) &&
           verifier.EndTable();
  }
};

struct FillPathCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_material(flatbuffers::Offset<flatbuffers::String> material) {
    fbb_.AddOffset(FillPathCommand::VT_MATERIAL, material);
  }
  void add_opacity(float opacity) {
    fbb_.AddElement<float>(FillPathCommand::VT_OPACITY, opacity, 0.0f);
  }
  void add_fillRule(FillRule fillRule) {
    fbb_.AddElement<uint8_t>(FillPathCommand::VT_FILLRULE, static_cast<uint8_t>(fillRule), 0);
  }
  explicit FillPathCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FillPathCommandBuilder &operator=(const FillPathCommandBuilder &);
  flatbuffers::Offset<FillPathCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FillPathCommand>(end);
    fbb_.Required(o, FillPathCommand::VT_MATERIAL);
    return o;
  }
};

inline flatbuffers::Offset<FillPathCommand> CreateFillPathCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> material = 0,
    float opacity = 0.0f,
    FillRule fillRule = FillRule::EvenOdd) {
  FillPathCommandBuilder builder_(_fbb);
  builder_.add_opacity(opacity);
  builder_.add_material(material);
  builder_.add_fillRule(fillRule);
  return builder_.Finish();
}

inline flatbuffers::Offset<FillPathCommand> CreateFillPathCommandDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *material = nullptr,
    float opacity = 0.0f,
    FillRule fillRule = FillRule::EvenOdd) {
  return DeepSeaVectorDraw::CreateFillPathCommand(
      _fbb,
      material ? _fbb.CreateString(material) : 0,
      opacity,
      fillRule);
}

struct TextCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TEXT = 4,
    VT_FONT = 6,
    VT_ALIGNMENT = 8,
    VT_MAXLENGTH = 10,
    VT_LINEHEIGHT = 12,
    VT_TRANSFORM = 14,
    VT_RANGECOUNT = 16
  };
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  const flatbuffers::String *font() const {
    return GetPointer<const flatbuffers::String *>(VT_FONT);
  }
  TextAlign alignment() const {
    return static_cast<TextAlign>(GetField<uint8_t>(VT_ALIGNMENT, 0));
  }
  float maxLength() const {
    return GetField<float>(VT_MAXLENGTH, 0.0f);
  }
  float lineHeight() const {
    return GetField<float>(VT_LINEHEIGHT, 0.0f);
  }
  const Matrix33f *transform() const {
    return GetStruct<const Matrix33f *>(VT_TRANSFORM);
  }
  uint32_t rangeCount() const {
    return GetField<uint32_t>(VT_RANGECOUNT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyOffsetRequired(verifier, VT_FONT) &&
           verifier.VerifyString(font()) &&
           VerifyField<uint8_t>(verifier, VT_ALIGNMENT) &&
           VerifyField<float>(verifier, VT_MAXLENGTH) &&
           VerifyField<float>(verifier, VT_LINEHEIGHT) &&
           VerifyFieldRequired<Matrix33f>(verifier, VT_TRANSFORM) &&
           VerifyField<uint32_t>(verifier, VT_RANGECOUNT) &&
           verifier.EndTable();
  }
};

struct TextCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(TextCommand::VT_TEXT, text);
  }
  void add_font(flatbuffers::Offset<flatbuffers::String> font) {
    fbb_.AddOffset(TextCommand::VT_FONT, font);
  }
  void add_alignment(TextAlign alignment) {
    fbb_.AddElement<uint8_t>(TextCommand::VT_ALIGNMENT, static_cast<uint8_t>(alignment), 0);
  }
  void add_maxLength(float maxLength) {
    fbb_.AddElement<float>(TextCommand::VT_MAXLENGTH, maxLength, 0.0f);
  }
  void add_lineHeight(float lineHeight) {
    fbb_.AddElement<float>(TextCommand::VT_LINEHEIGHT, lineHeight, 0.0f);
  }
  void add_transform(const Matrix33f *transform) {
    fbb_.AddStruct(TextCommand::VT_TRANSFORM, transform);
  }
  void add_rangeCount(uint32_t rangeCount) {
    fbb_.AddElement<uint32_t>(TextCommand::VT_RANGECOUNT, rangeCount, 0);
  }
  explicit TextCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextCommandBuilder &operator=(const TextCommandBuilder &);
  flatbuffers::Offset<TextCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextCommand>(end);
    fbb_.Required(o, TextCommand::VT_TEXT);
    fbb_.Required(o, TextCommand::VT_FONT);
    fbb_.Required(o, TextCommand::VT_TRANSFORM);
    return o;
  }
};

inline flatbuffers::Offset<TextCommand> CreateTextCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    flatbuffers::Offset<flatbuffers::String> font = 0,
    TextAlign alignment = TextAlign::Start,
    float maxLength = 0.0f,
    float lineHeight = 0.0f,
    const Matrix33f *transform = 0,
    uint32_t rangeCount = 0) {
  TextCommandBuilder builder_(_fbb);
  builder_.add_rangeCount(rangeCount);
  builder_.add_transform(transform);
  builder_.add_lineHeight(lineHeight);
  builder_.add_maxLength(maxLength);
  builder_.add_font(font);
  builder_.add_text(text);
  builder_.add_alignment(alignment);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextCommand> CreateTextCommandDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    const char *font = nullptr,
    TextAlign alignment = TextAlign::Start,
    float maxLength = 0.0f,
    float lineHeight = 0.0f,
    const Matrix33f *transform = 0,
    uint32_t rangeCount = 0) {
  return DeepSeaVectorDraw::CreateTextCommand(
      _fbb,
      text ? _fbb.CreateString(text) : 0,
      font ? _fbb.CreateString(font) : 0,
      alignment,
      maxLength,
      lineHeight,
      transform,
      rangeCount);
}

struct TextRangeCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_START = 4,
    VT_COUNT = 6,
    VT_POSITIONTYPE = 8,
    VT_POSITION = 10,
    VT_FILLMATERIAL = 12,
    VT_OUTLINEMATERIAL = 14,
    VT_FILLOPACITY = 16,
    VT_OUTLINEOPACITY = 18,
    VT_SIZE = 20,
    VT_EMBOLDEN = 22,
    VT_SLANT = 24,
    VT_OUTLINEWIDTH = 26,
    VT_FUZINESS = 28
  };
  uint32_t start() const {
    return GetField<uint32_t>(VT_START, 0);
  }
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  TextPosition positionType() const {
    return static_cast<TextPosition>(GetField<uint8_t>(VT_POSITIONTYPE, 0));
  }
  const Vector2f *position() const {
    return GetStruct<const Vector2f *>(VT_POSITION);
  }
  const flatbuffers::String *fillMaterial() const {
    return GetPointer<const flatbuffers::String *>(VT_FILLMATERIAL);
  }
  const flatbuffers::String *outlineMaterial() const {
    return GetPointer<const flatbuffers::String *>(VT_OUTLINEMATERIAL);
  }
  float fillOpacity() const {
    return GetField<float>(VT_FILLOPACITY, 0.0f);
  }
  float outlineOpacity() const {
    return GetField<float>(VT_OUTLINEOPACITY, 0.0f);
  }
  float size() const {
    return GetField<float>(VT_SIZE, 0.0f);
  }
  float embolden() const {
    return GetField<float>(VT_EMBOLDEN, 0.0f);
  }
  float slant() const {
    return GetField<float>(VT_SLANT, 0.0f);
  }
  float outlineWidth() const {
    return GetField<float>(VT_OUTLINEWIDTH, 0.0f);
  }
  float fuziness() const {
    return GetField<float>(VT_FUZINESS, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_START) &&
           VerifyField<uint32_t>(verifier, VT_COUNT) &&
           VerifyField<uint8_t>(verifier, VT_POSITIONTYPE) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_POSITION) &&
           VerifyOffset(verifier, VT_FILLMATERIAL) &&
           verifier.VerifyString(fillMaterial()) &&
           VerifyOffset(verifier, VT_OUTLINEMATERIAL) &&
           verifier.VerifyString(outlineMaterial()) &&
           VerifyField<float>(verifier, VT_FILLOPACITY) &&
           VerifyField<float>(verifier, VT_OUTLINEOPACITY) &&
           VerifyField<float>(verifier, VT_SIZE) &&
           VerifyField<float>(verifier, VT_EMBOLDEN) &&
           VerifyField<float>(verifier, VT_SLANT) &&
           VerifyField<float>(verifier, VT_OUTLINEWIDTH) &&
           VerifyField<float>(verifier, VT_FUZINESS) &&
           verifier.EndTable();
  }
};

struct TextRangeCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_start(uint32_t start) {
    fbb_.AddElement<uint32_t>(TextRangeCommand::VT_START, start, 0);
  }
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(TextRangeCommand::VT_COUNT, count, 0);
  }
  void add_positionType(TextPosition positionType) {
    fbb_.AddElement<uint8_t>(TextRangeCommand::VT_POSITIONTYPE, static_cast<uint8_t>(positionType), 0);
  }
  void add_position(const Vector2f *position) {
    fbb_.AddStruct(TextRangeCommand::VT_POSITION, position);
  }
  void add_fillMaterial(flatbuffers::Offset<flatbuffers::String> fillMaterial) {
    fbb_.AddOffset(TextRangeCommand::VT_FILLMATERIAL, fillMaterial);
  }
  void add_outlineMaterial(flatbuffers::Offset<flatbuffers::String> outlineMaterial) {
    fbb_.AddOffset(TextRangeCommand::VT_OUTLINEMATERIAL, outlineMaterial);
  }
  void add_fillOpacity(float fillOpacity) {
    fbb_.AddElement<float>(TextRangeCommand::VT_FILLOPACITY, fillOpacity, 0.0f);
  }
  void add_outlineOpacity(float outlineOpacity) {
    fbb_.AddElement<float>(TextRangeCommand::VT_OUTLINEOPACITY, outlineOpacity, 0.0f);
  }
  void add_size(float size) {
    fbb_.AddElement<float>(TextRangeCommand::VT_SIZE, size, 0.0f);
  }
  void add_embolden(float embolden) {
    fbb_.AddElement<float>(TextRangeCommand::VT_EMBOLDEN, embolden, 0.0f);
  }
  void add_slant(float slant) {
    fbb_.AddElement<float>(TextRangeCommand::VT_SLANT, slant, 0.0f);
  }
  void add_outlineWidth(float outlineWidth) {
    fbb_.AddElement<float>(TextRangeCommand::VT_OUTLINEWIDTH, outlineWidth, 0.0f);
  }
  void add_fuziness(float fuziness) {
    fbb_.AddElement<float>(TextRangeCommand::VT_FUZINESS, fuziness, 0.0f);
  }
  explicit TextRangeCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TextRangeCommandBuilder &operator=(const TextRangeCommandBuilder &);
  flatbuffers::Offset<TextRangeCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TextRangeCommand>(end);
    fbb_.Required(o, TextRangeCommand::VT_POSITION);
    return o;
  }
};

inline flatbuffers::Offset<TextRangeCommand> CreateTextRangeCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t start = 0,
    uint32_t count = 0,
    TextPosition positionType = TextPosition::Offset,
    const Vector2f *position = 0,
    flatbuffers::Offset<flatbuffers::String> fillMaterial = 0,
    flatbuffers::Offset<flatbuffers::String> outlineMaterial = 0,
    float fillOpacity = 0.0f,
    float outlineOpacity = 0.0f,
    float size = 0.0f,
    float embolden = 0.0f,
    float slant = 0.0f,
    float outlineWidth = 0.0f,
    float fuziness = 0.0f) {
  TextRangeCommandBuilder builder_(_fbb);
  builder_.add_fuziness(fuziness);
  builder_.add_outlineWidth(outlineWidth);
  builder_.add_slant(slant);
  builder_.add_embolden(embolden);
  builder_.add_size(size);
  builder_.add_outlineOpacity(outlineOpacity);
  builder_.add_fillOpacity(fillOpacity);
  builder_.add_outlineMaterial(outlineMaterial);
  builder_.add_fillMaterial(fillMaterial);
  builder_.add_position(position);
  builder_.add_count(count);
  builder_.add_start(start);
  builder_.add_positionType(positionType);
  return builder_.Finish();
}

inline flatbuffers::Offset<TextRangeCommand> CreateTextRangeCommandDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t start = 0,
    uint32_t count = 0,
    TextPosition positionType = TextPosition::Offset,
    const Vector2f *position = 0,
    const char *fillMaterial = nullptr,
    const char *outlineMaterial = nullptr,
    float fillOpacity = 0.0f,
    float outlineOpacity = 0.0f,
    float size = 0.0f,
    float embolden = 0.0f,
    float slant = 0.0f,
    float outlineWidth = 0.0f,
    float fuziness = 0.0f) {
  return DeepSeaVectorDraw::CreateTextRangeCommand(
      _fbb,
      start,
      count,
      positionType,
      position,
      fillMaterial ? _fbb.CreateString(fillMaterial) : 0,
      outlineMaterial ? _fbb.CreateString(outlineMaterial) : 0,
      fillOpacity,
      outlineOpacity,
      size,
      embolden,
      slant,
      outlineWidth,
      fuziness);
}

struct ImageCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IMAGE = 4,
    VT_UPPERLEFT = 6,
    VT_LOWERRIGHT = 8,
    VT_OPACITY = 10,
    VT_TRANSFORM = 12
  };
  const flatbuffers::String *image() const {
    return GetPointer<const flatbuffers::String *>(VT_IMAGE);
  }
  const Vector2f *upperLeft() const {
    return GetStruct<const Vector2f *>(VT_UPPERLEFT);
  }
  const Vector2f *lowerRight() const {
    return GetStruct<const Vector2f *>(VT_LOWERRIGHT);
  }
  float opacity() const {
    return GetField<float>(VT_OPACITY, 0.0f);
  }
  const Matrix33f *transform() const {
    return GetStruct<const Matrix33f *>(VT_TRANSFORM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_IMAGE) &&
           verifier.VerifyString(image()) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_UPPERLEFT) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_LOWERRIGHT) &&
           VerifyField<float>(verifier, VT_OPACITY) &&
           VerifyFieldRequired<Matrix33f>(verifier, VT_TRANSFORM) &&
           verifier.EndTable();
  }
};

struct ImageCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_image(flatbuffers::Offset<flatbuffers::String> image) {
    fbb_.AddOffset(ImageCommand::VT_IMAGE, image);
  }
  void add_upperLeft(const Vector2f *upperLeft) {
    fbb_.AddStruct(ImageCommand::VT_UPPERLEFT, upperLeft);
  }
  void add_lowerRight(const Vector2f *lowerRight) {
    fbb_.AddStruct(ImageCommand::VT_LOWERRIGHT, lowerRight);
  }
  void add_opacity(float opacity) {
    fbb_.AddElement<float>(ImageCommand::VT_OPACITY, opacity, 0.0f);
  }
  void add_transform(const Matrix33f *transform) {
    fbb_.AddStruct(ImageCommand::VT_TRANSFORM, transform);
  }
  explicit ImageCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ImageCommandBuilder &operator=(const ImageCommandBuilder &);
  flatbuffers::Offset<ImageCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ImageCommand>(end);
    fbb_.Required(o, ImageCommand::VT_IMAGE);
    fbb_.Required(o, ImageCommand::VT_UPPERLEFT);
    fbb_.Required(o, ImageCommand::VT_LOWERRIGHT);
    fbb_.Required(o, ImageCommand::VT_TRANSFORM);
    return o;
  }
};

inline flatbuffers::Offset<ImageCommand> CreateImageCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> image = 0,
    const Vector2f *upperLeft = 0,
    const Vector2f *lowerRight = 0,
    float opacity = 0.0f,
    const Matrix33f *transform = 0) {
  ImageCommandBuilder builder_(_fbb);
  builder_.add_transform(transform);
  builder_.add_opacity(opacity);
  builder_.add_lowerRight(lowerRight);
  builder_.add_upperLeft(upperLeft);
  builder_.add_image(image);
  return builder_.Finish();
}

inline flatbuffers::Offset<ImageCommand> CreateImageCommandDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *image = nullptr,
    const Vector2f *upperLeft = 0,
    const Vector2f *lowerRight = 0,
    float opacity = 0.0f,
    const Matrix33f *transform = 0) {
  return DeepSeaVectorDraw::CreateImageCommand(
      _fbb,
      image ? _fbb.CreateString(image) : 0,
      upperLeft,
      lowerRight,
      opacity,
      transform);
}

struct VectorCommand FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COMMAND_TYPE = 4,
    VT_COMMAND = 6
  };
  VectorCommandUnion command_type() const {
    return static_cast<VectorCommandUnion>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const StartPathCommand *command_as_StartPathCommand() const {
    return command_type() == VectorCommandUnion::StartPathCommand ? static_cast<const StartPathCommand *>(command()) : nullptr;
  }
  const MoveCommand *command_as_MoveCommand() const {
    return command_type() == VectorCommandUnion::MoveCommand ? static_cast<const MoveCommand *>(command()) : nullptr;
  }
  const LineCommand *command_as_LineCommand() const {
    return command_type() == VectorCommandUnion::LineCommand ? static_cast<const LineCommand *>(command()) : nullptr;
  }
  const BezierCommand *command_as_BezierCommand() const {
    return command_type() == VectorCommandUnion::BezierCommand ? static_cast<const BezierCommand *>(command()) : nullptr;
  }
  const QuadraticCommand *command_as_QuadraticCommand() const {
    return command_type() == VectorCommandUnion::QuadraticCommand ? static_cast<const QuadraticCommand *>(command()) : nullptr;
  }
  const ArcCommand *command_as_ArcCommand() const {
    return command_type() == VectorCommandUnion::ArcCommand ? static_cast<const ArcCommand *>(command()) : nullptr;
  }
  const ClosePathCommand *command_as_ClosePathCommand() const {
    return command_type() == VectorCommandUnion::ClosePathCommand ? static_cast<const ClosePathCommand *>(command()) : nullptr;
  }
  const EllipseCommand *command_as_EllipseCommand() const {
    return command_type() == VectorCommandUnion::EllipseCommand ? static_cast<const EllipseCommand *>(command()) : nullptr;
  }
  const RectangleCommand *command_as_RectangleCommand() const {
    return command_type() == VectorCommandUnion::RectangleCommand ? static_cast<const RectangleCommand *>(command()) : nullptr;
  }
  const StrokePathCommand *command_as_StrokePathCommand() const {
    return command_type() == VectorCommandUnion::StrokePathCommand ? static_cast<const StrokePathCommand *>(command()) : nullptr;
  }
  const FillPathCommand *command_as_FillPathCommand() const {
    return command_type() == VectorCommandUnion::FillPathCommand ? static_cast<const FillPathCommand *>(command()) : nullptr;
  }
  const TextCommand *command_as_TextCommand() const {
    return command_type() == VectorCommandUnion::TextCommand ? static_cast<const TextCommand *>(command()) : nullptr;
  }
  const TextRangeCommand *command_as_TextRangeCommand() const {
    return command_type() == VectorCommandUnion::TextRangeCommand ? static_cast<const TextRangeCommand *>(command()) : nullptr;
  }
  const ImageCommand *command_as_ImageCommand() const {
    return command_type() == VectorCommandUnion::ImageCommand ? static_cast<const ImageCommand *>(command()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE) &&
           VerifyOffsetRequired(verifier, VT_COMMAND) &&
           VerifyVectorCommandUnion(verifier, command(), command_type()) &&
           verifier.EndTable();
  }
};

template<> inline const StartPathCommand *VectorCommand::command_as<StartPathCommand>() const {
  return command_as_StartPathCommand();
}

template<> inline const MoveCommand *VectorCommand::command_as<MoveCommand>() const {
  return command_as_MoveCommand();
}

template<> inline const LineCommand *VectorCommand::command_as<LineCommand>() const {
  return command_as_LineCommand();
}

template<> inline const BezierCommand *VectorCommand::command_as<BezierCommand>() const {
  return command_as_BezierCommand();
}

template<> inline const QuadraticCommand *VectorCommand::command_as<QuadraticCommand>() const {
  return command_as_QuadraticCommand();
}

template<> inline const ArcCommand *VectorCommand::command_as<ArcCommand>() const {
  return command_as_ArcCommand();
}

template<> inline const ClosePathCommand *VectorCommand::command_as<ClosePathCommand>() const {
  return command_as_ClosePathCommand();
}

template<> inline const EllipseCommand *VectorCommand::command_as<EllipseCommand>() const {
  return command_as_EllipseCommand();
}

template<> inline const RectangleCommand *VectorCommand::command_as<RectangleCommand>() const {
  return command_as_RectangleCommand();
}

template<> inline const StrokePathCommand *VectorCommand::command_as<StrokePathCommand>() const {
  return command_as_StrokePathCommand();
}

template<> inline const FillPathCommand *VectorCommand::command_as<FillPathCommand>() const {
  return command_as_FillPathCommand();
}

template<> inline const TextCommand *VectorCommand::command_as<TextCommand>() const {
  return command_as_TextCommand();
}

template<> inline const TextRangeCommand *VectorCommand::command_as<TextRangeCommand>() const {
  return command_as_TextRangeCommand();
}

template<> inline const ImageCommand *VectorCommand::command_as<ImageCommand>() const {
  return command_as_ImageCommand();
}

struct VectorCommandBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_command_type(VectorCommandUnion command_type) {
    fbb_.AddElement<uint8_t>(VectorCommand::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(flatbuffers::Offset<void> command) {
    fbb_.AddOffset(VectorCommand::VT_COMMAND, command);
  }
  explicit VectorCommandBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VectorCommandBuilder &operator=(const VectorCommandBuilder &);
  flatbuffers::Offset<VectorCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorCommand>(end);
    fbb_.Required(o, VectorCommand::VT_COMMAND);
    return o;
  }
};

inline flatbuffers::Offset<VectorCommand> CreateVectorCommand(
    flatbuffers::FlatBufferBuilder &_fbb,
    VectorCommandUnion command_type = VectorCommandUnion::NONE,
    flatbuffers::Offset<void> command = 0) {
  VectorCommandBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

struct VectorImage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COLORMATERIALS = 4,
    VT_LINEARGRADIENTS = 6,
    VT_RADIALGRADIENTS = 8,
    VT_COMMANDS = 10,
    VT_SIZE = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<ColorMaterial>> *colorMaterials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ColorMaterial>> *>(VT_COLORMATERIALS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<LinearGradient>> *linearGradients() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<LinearGradient>> *>(VT_LINEARGRADIENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<RadialGradient>> *radialGradients() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<RadialGradient>> *>(VT_RADIALGRADIENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<VectorCommand>> *commands() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<VectorCommand>> *>(VT_COMMANDS);
  }
  const Vector2f *size() const {
    return GetStruct<const Vector2f *>(VT_SIZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLORMATERIALS) &&
           verifier.VerifyVector(colorMaterials()) &&
           verifier.VerifyVectorOfTables(colorMaterials()) &&
           VerifyOffset(verifier, VT_LINEARGRADIENTS) &&
           verifier.VerifyVector(linearGradients()) &&
           verifier.VerifyVectorOfTables(linearGradients()) &&
           VerifyOffset(verifier, VT_RADIALGRADIENTS) &&
           verifier.VerifyVector(radialGradients()) &&
           verifier.VerifyVectorOfTables(radialGradients()) &&
           VerifyOffsetRequired(verifier, VT_COMMANDS) &&
           verifier.VerifyVector(commands()) &&
           verifier.VerifyVectorOfTables(commands()) &&
           VerifyFieldRequired<Vector2f>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct VectorImageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_colorMaterials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ColorMaterial>>> colorMaterials) {
    fbb_.AddOffset(VectorImage::VT_COLORMATERIALS, colorMaterials);
  }
  void add_linearGradients(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LinearGradient>>> linearGradients) {
    fbb_.AddOffset(VectorImage::VT_LINEARGRADIENTS, linearGradients);
  }
  void add_radialGradients(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RadialGradient>>> radialGradients) {
    fbb_.AddOffset(VectorImage::VT_RADIALGRADIENTS, radialGradients);
  }
  void add_commands(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VectorCommand>>> commands) {
    fbb_.AddOffset(VectorImage::VT_COMMANDS, commands);
  }
  void add_size(const Vector2f *size) {
    fbb_.AddStruct(VectorImage::VT_SIZE, size);
  }
  explicit VectorImageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VectorImageBuilder &operator=(const VectorImageBuilder &);
  flatbuffers::Offset<VectorImage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VectorImage>(end);
    fbb_.Required(o, VectorImage::VT_COMMANDS);
    fbb_.Required(o, VectorImage::VT_SIZE);
    return o;
  }
};

inline flatbuffers::Offset<VectorImage> CreateVectorImage(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ColorMaterial>>> colorMaterials = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<LinearGradient>>> linearGradients = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<RadialGradient>>> radialGradients = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<VectorCommand>>> commands = 0,
    const Vector2f *size = 0) {
  VectorImageBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_commands(commands);
  builder_.add_radialGradients(radialGradients);
  builder_.add_linearGradients(linearGradients);
  builder_.add_colorMaterials(colorMaterials);
  return builder_.Finish();
}

inline flatbuffers::Offset<VectorImage> CreateVectorImageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ColorMaterial>> *colorMaterials = nullptr,
    const std::vector<flatbuffers::Offset<LinearGradient>> *linearGradients = nullptr,
    const std::vector<flatbuffers::Offset<RadialGradient>> *radialGradients = nullptr,
    const std::vector<flatbuffers::Offset<VectorCommand>> *commands = nullptr,
    const Vector2f *size = 0) {
  return DeepSeaVectorDraw::CreateVectorImage(
      _fbb,
      colorMaterials ? _fbb.CreateVector<flatbuffers::Offset<ColorMaterial>>(*colorMaterials) : 0,
      linearGradients ? _fbb.CreateVector<flatbuffers::Offset<LinearGradient>>(*linearGradients) : 0,
      radialGradients ? _fbb.CreateVector<flatbuffers::Offset<RadialGradient>>(*radialGradients) : 0,
      commands ? _fbb.CreateVector<flatbuffers::Offset<VectorCommand>>(*commands) : 0,
      size);
}

inline bool VerifyVectorCommandUnion(flatbuffers::Verifier &verifier, const void *obj, VectorCommandUnion type) {
  switch (type) {
    case VectorCommandUnion::NONE: {
      return true;
    }
    case VectorCommandUnion::StartPathCommand: {
      auto ptr = reinterpret_cast<const StartPathCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::MoveCommand: {
      auto ptr = reinterpret_cast<const MoveCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::LineCommand: {
      auto ptr = reinterpret_cast<const LineCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::BezierCommand: {
      auto ptr = reinterpret_cast<const BezierCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::QuadraticCommand: {
      auto ptr = reinterpret_cast<const QuadraticCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::ArcCommand: {
      auto ptr = reinterpret_cast<const ArcCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::ClosePathCommand: {
      auto ptr = reinterpret_cast<const ClosePathCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::EllipseCommand: {
      auto ptr = reinterpret_cast<const EllipseCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::RectangleCommand: {
      auto ptr = reinterpret_cast<const RectangleCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::StrokePathCommand: {
      auto ptr = reinterpret_cast<const StrokePathCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::FillPathCommand: {
      auto ptr = reinterpret_cast<const FillPathCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::TextCommand: {
      auto ptr = reinterpret_cast<const TextCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::TextRangeCommand: {
      auto ptr = reinterpret_cast<const TextRangeCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::ImageCommand: {
      auto ptr = reinterpret_cast<const ImageCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyVectorCommandUnionVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyVectorCommandUnion(
        verifier,  values->Get(i), types->GetEnum<VectorCommandUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline const DeepSeaVectorDraw::VectorImage *GetVectorImage(const void *buf) {
  return flatbuffers::GetRoot<DeepSeaVectorDraw::VectorImage>(buf);
}

inline const DeepSeaVectorDraw::VectorImage *GetSizePrefixedVectorImage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<DeepSeaVectorDraw::VectorImage>(buf);
}

inline bool VerifyVectorImageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<DeepSeaVectorDraw::VectorImage>(nullptr);
}

inline bool VerifySizePrefixedVectorImageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<DeepSeaVectorDraw::VectorImage>(nullptr);
}

inline void FinishVectorImageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DeepSeaVectorDraw::VectorImage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedVectorImageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<DeepSeaVectorDraw::VectorImage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace DeepSeaVectorDraw

#endif  // FLATBUFFERS_GENERATED_VECTORIMAGE_DEEPSEAVECTORDRAW_H_
