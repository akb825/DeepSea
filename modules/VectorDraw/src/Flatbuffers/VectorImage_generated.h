// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_VECTORIMAGE_DEEPSEAVECTORDRAW_H_
#define FLATBUFFERS_GENERATED_VECTORIMAGE_DEEPSEAVECTORDRAW_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 12 &&
              FLATBUFFERS_VERSION_REVISION == 19,
             "Non-compatible flatbuffers version included");

namespace DeepSeaVectorDraw {

struct Color;

struct Vector2f;

struct Vector3f;

struct Matrix33f;

struct DashArray;

struct GradientStop;

struct ColorMaterial;
struct ColorMaterialBuilder;

struct LinearGradient;
struct LinearGradientBuilder;

struct RadialGradient;
struct RadialGradientBuilder;

struct StartPathCommand;
struct StartPathCommandBuilder;

struct MoveCommand;
struct MoveCommandBuilder;

struct LineCommand;
struct LineCommandBuilder;

struct BezierCommand;
struct BezierCommandBuilder;

struct QuadraticCommand;
struct QuadraticCommandBuilder;

struct ArcCommand;
struct ArcCommandBuilder;

struct ClosePathCommand;
struct ClosePathCommandBuilder;

struct EllipseCommand;
struct EllipseCommandBuilder;

struct RectangleCommand;
struct RectangleCommandBuilder;

struct StrokePathCommand;
struct StrokePathCommandBuilder;

struct FillPathCommand;
struct FillPathCommandBuilder;

struct TextCommand;
struct TextCommandBuilder;

struct TextRangeCommand;
struct TextRangeCommandBuilder;

struct ImageCommand;
struct ImageCommandBuilder;

struct VectorCommand;
struct VectorCommandBuilder;

struct VectorImage;
struct VectorImageBuilder;

enum class GradientEdge : uint8_t {
  Clamp = 0,
  Repeat = 1,
  Mirror = 2,
  MIN = Clamp,
  MAX = Mirror
};

inline const GradientEdge (&EnumValuesGradientEdge())[3] {
  static const GradientEdge values[] = {
    GradientEdge::Clamp,
    GradientEdge::Repeat,
    GradientEdge::Mirror
  };
  return values;
}

inline const char * const *EnumNamesGradientEdge() {
  static const char * const names[4] = {
    "Clamp",
    "Repeat",
    "Mirror",
    nullptr
  };
  return names;
}

inline const char *EnumNameGradientEdge(GradientEdge e) {
  if (::flatbuffers::IsOutRange(e, GradientEdge::Clamp, GradientEdge::Mirror)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGradientEdge()[index];
}

enum class MaterialSpace : uint8_t {
  Local = 0,
  Bounds = 1,
  MIN = Local,
  MAX = Bounds
};

inline const MaterialSpace (&EnumValuesMaterialSpace())[2] {
  static const MaterialSpace values[] = {
    MaterialSpace::Local,
    MaterialSpace::Bounds
  };
  return values;
}

inline const char * const *EnumNamesMaterialSpace() {
  static const char * const names[3] = {
    "Local",
    "Bounds",
    nullptr
  };
  return names;
}

inline const char *EnumNameMaterialSpace(MaterialSpace e) {
  if (::flatbuffers::IsOutRange(e, MaterialSpace::Local, MaterialSpace::Bounds)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMaterialSpace()[index];
}

enum class LineJoin : uint8_t {
  Miter = 0,
  Bevel = 1,
  Round = 2,
  MIN = Miter,
  MAX = Round
};

inline const LineJoin (&EnumValuesLineJoin())[3] {
  static const LineJoin values[] = {
    LineJoin::Miter,
    LineJoin::Bevel,
    LineJoin::Round
  };
  return values;
}

inline const char * const *EnumNamesLineJoin() {
  static const char * const names[4] = {
    "Miter",
    "Bevel",
    "Round",
    nullptr
  };
  return names;
}

inline const char *EnumNameLineJoin(LineJoin e) {
  if (::flatbuffers::IsOutRange(e, LineJoin::Miter, LineJoin::Round)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLineJoin()[index];
}

enum class LineCap : uint8_t {
  Butt = 0,
  Round = 1,
  Square = 2,
  MIN = Butt,
  MAX = Square
};

inline const LineCap (&EnumValuesLineCap())[3] {
  static const LineCap values[] = {
    LineCap::Butt,
    LineCap::Round,
    LineCap::Square
  };
  return values;
}

inline const char * const *EnumNamesLineCap() {
  static const char * const names[4] = {
    "Butt",
    "Round",
    "Square",
    nullptr
  };
  return names;
}

inline const char *EnumNameLineCap(LineCap e) {
  if (::flatbuffers::IsOutRange(e, LineCap::Butt, LineCap::Square)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLineCap()[index];
}

enum class FillRule : uint8_t {
  EvenOdd = 0,
  NonZero = 1,
  MIN = EvenOdd,
  MAX = NonZero
};

inline const FillRule (&EnumValuesFillRule())[2] {
  static const FillRule values[] = {
    FillRule::EvenOdd,
    FillRule::NonZero
  };
  return values;
}

inline const char * const *EnumNamesFillRule() {
  static const char * const names[3] = {
    "EvenOdd",
    "NonZero",
    nullptr
  };
  return names;
}

inline const char *EnumNameFillRule(FillRule e) {
  if (::flatbuffers::IsOutRange(e, FillRule::EvenOdd, FillRule::NonZero)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFillRule()[index];
}

enum class TextPosition : uint8_t {
  Offset = 0,
  Absolute = 1,
  MIN = Offset,
  MAX = Absolute
};

inline const TextPosition (&EnumValuesTextPosition())[2] {
  static const TextPosition values[] = {
    TextPosition::Offset,
    TextPosition::Absolute
  };
  return values;
}

inline const char * const *EnumNamesTextPosition() {
  static const char * const names[3] = {
    "Offset",
    "Absolute",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextPosition(TextPosition e) {
  if (::flatbuffers::IsOutRange(e, TextPosition::Offset, TextPosition::Absolute)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextPosition()[index];
}

enum class TextAlign : uint8_t {
  Start = 0,
  End = 1,
  Left = 2,
  Right = 3,
  Center = 4,
  MIN = Start,
  MAX = Center
};

inline const TextAlign (&EnumValuesTextAlign())[5] {
  static const TextAlign values[] = {
    TextAlign::Start,
    TextAlign::End,
    TextAlign::Left,
    TextAlign::Right,
    TextAlign::Center
  };
  return values;
}

inline const char * const *EnumNamesTextAlign() {
  static const char * const names[6] = {
    "Start",
    "End",
    "Left",
    "Right",
    "Center",
    nullptr
  };
  return names;
}

inline const char *EnumNameTextAlign(TextAlign e) {
  if (::flatbuffers::IsOutRange(e, TextAlign::Start, TextAlign::Center)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTextAlign()[index];
}

enum class VectorCommandUnion : uint8_t {
  NONE = 0,
  StartPathCommand = 1,
  MoveCommand = 2,
  LineCommand = 3,
  BezierCommand = 4,
  QuadraticCommand = 5,
  ArcCommand = 6,
  ClosePathCommand = 7,
  EllipseCommand = 8,
  RectangleCommand = 9,
  StrokePathCommand = 10,
  FillPathCommand = 11,
  TextCommand = 12,
  TextRangeCommand = 13,
  ImageCommand = 14,
  MIN = NONE,
  MAX = ImageCommand
};

inline const VectorCommandUnion (&EnumValuesVectorCommandUnion())[15] {
  static const VectorCommandUnion values[] = {
    VectorCommandUnion::NONE,
    VectorCommandUnion::StartPathCommand,
    VectorCommandUnion::MoveCommand,
    VectorCommandUnion::LineCommand,
    VectorCommandUnion::BezierCommand,
    VectorCommandUnion::QuadraticCommand,
    VectorCommandUnion::ArcCommand,
    VectorCommandUnion::ClosePathCommand,
    VectorCommandUnion::EllipseCommand,
    VectorCommandUnion::RectangleCommand,
    VectorCommandUnion::StrokePathCommand,
    VectorCommandUnion::FillPathCommand,
    VectorCommandUnion::TextCommand,
    VectorCommandUnion::TextRangeCommand,
    VectorCommandUnion::ImageCommand
  };
  return values;
}

inline const char * const *EnumNamesVectorCommandUnion() {
  static const char * const names[16] = {
    "NONE",
    "StartPathCommand",
    "MoveCommand",
    "LineCommand",
    "BezierCommand",
    "QuadraticCommand",
    "ArcCommand",
    "ClosePathCommand",
    "EllipseCommand",
    "RectangleCommand",
    "StrokePathCommand",
    "FillPathCommand",
    "TextCommand",
    "TextRangeCommand",
    "ImageCommand",
    nullptr
  };
  return names;
}

inline const char *EnumNameVectorCommandUnion(VectorCommandUnion e) {
  if (::flatbuffers::IsOutRange(e, VectorCommandUnion::NONE, VectorCommandUnion::ImageCommand)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesVectorCommandUnion()[index];
}

template<typename T> struct VectorCommandUnionTraits {
  static const VectorCommandUnion enum_value = VectorCommandUnion::NONE;
};

template<> struct VectorCommandUnionTraits<DeepSeaVectorDraw::StartPathCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::StartPathCommand;
};

template<> struct VectorCommandUnionTraits<DeepSeaVectorDraw::MoveCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::MoveCommand;
};

template<> struct VectorCommandUnionTraits<DeepSeaVectorDraw::LineCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::LineCommand;
};

template<> struct VectorCommandUnionTraits<DeepSeaVectorDraw::BezierCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::BezierCommand;
};

template<> struct VectorCommandUnionTraits<DeepSeaVectorDraw::QuadraticCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::QuadraticCommand;
};

template<> struct VectorCommandUnionTraits<DeepSeaVectorDraw::ArcCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::ArcCommand;
};

template<> struct VectorCommandUnionTraits<DeepSeaVectorDraw::ClosePathCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::ClosePathCommand;
};

template<> struct VectorCommandUnionTraits<DeepSeaVectorDraw::EllipseCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::EllipseCommand;
};

template<> struct VectorCommandUnionTraits<DeepSeaVectorDraw::RectangleCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::RectangleCommand;
};

template<> struct VectorCommandUnionTraits<DeepSeaVectorDraw::StrokePathCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::StrokePathCommand;
};

template<> struct VectorCommandUnionTraits<DeepSeaVectorDraw::FillPathCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::FillPathCommand;
};

template<> struct VectorCommandUnionTraits<DeepSeaVectorDraw::TextCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::TextCommand;
};

template<> struct VectorCommandUnionTraits<DeepSeaVectorDraw::TextRangeCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::TextRangeCommand;
};

template<> struct VectorCommandUnionTraits<DeepSeaVectorDraw::ImageCommand> {
  static const VectorCommandUnion enum_value = VectorCommandUnion::ImageCommand;
};

template <bool B = false>
bool VerifyVectorCommandUnion(::flatbuffers::VerifierTemplate<B> &verifier, const void *obj, VectorCommandUnion type);
template <bool B = false>
bool VerifyVectorCommandUnionVector(::flatbuffers::VerifierTemplate<B> &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<VectorCommandUnion> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Color FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;
  uint8_t a_;

 public:
  Color()
      : r_(0),
        g_(0),
        b_(0),
        a_(0) {
  }
  Color(uint8_t _r, uint8_t _g, uint8_t _b, uint8_t _a)
      : r_(::flatbuffers::EndianScalar(_r)),
        g_(::flatbuffers::EndianScalar(_g)),
        b_(::flatbuffers::EndianScalar(_b)),
        a_(::flatbuffers::EndianScalar(_a)) {
  }
  uint8_t r() const {
    return ::flatbuffers::EndianScalar(r_);
  }
  uint8_t g() const {
    return ::flatbuffers::EndianScalar(g_);
  }
  uint8_t b() const {
    return ::flatbuffers::EndianScalar(b_);
  }
  uint8_t a() const {
    return ::flatbuffers::EndianScalar(a_);
  }
};
FLATBUFFERS_STRUCT_END(Color, 4);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector2f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vector2f()
      : x_(0),
        y_(0) {
  }
  Vector2f(float _x, float _y)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vector2f, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vector3f FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector3f()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vector3f(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vector3f, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Matrix33f FLATBUFFERS_FINAL_CLASS {
 private:
  DeepSeaVectorDraw::Vector3f column0_;
  DeepSeaVectorDraw::Vector3f column1_;
  DeepSeaVectorDraw::Vector3f column2_;

 public:
  Matrix33f()
      : column0_(),
        column1_(),
        column2_() {
  }
  Matrix33f(const DeepSeaVectorDraw::Vector3f &_column0, const DeepSeaVectorDraw::Vector3f &_column1, const DeepSeaVectorDraw::Vector3f &_column2)
      : column0_(_column0),
        column1_(_column1),
        column2_(_column2) {
  }
  const DeepSeaVectorDraw::Vector3f &column0() const {
    return column0_;
  }
  const DeepSeaVectorDraw::Vector3f &column1() const {
    return column1_;
  }
  const DeepSeaVectorDraw::Vector3f &column2() const {
    return column2_;
  }
};
FLATBUFFERS_STRUCT_END(Matrix33f, 36);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) DashArray FLATBUFFERS_FINAL_CLASS {
 private:
  float solid0_;
  float gap0_;
  float solid1_;
  float gap1_;

 public:
  DashArray()
      : solid0_(0),
        gap0_(0),
        solid1_(0),
        gap1_(0) {
  }
  DashArray(float _solid0, float _gap0, float _solid1, float _gap1)
      : solid0_(::flatbuffers::EndianScalar(_solid0)),
        gap0_(::flatbuffers::EndianScalar(_gap0)),
        solid1_(::flatbuffers::EndianScalar(_solid1)),
        gap1_(::flatbuffers::EndianScalar(_gap1)) {
  }
  float solid0() const {
    return ::flatbuffers::EndianScalar(solid0_);
  }
  float gap0() const {
    return ::flatbuffers::EndianScalar(gap0_);
  }
  float solid1() const {
    return ::flatbuffers::EndianScalar(solid1_);
  }
  float gap1() const {
    return ::flatbuffers::EndianScalar(gap1_);
  }
};
FLATBUFFERS_STRUCT_END(DashArray, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) GradientStop FLATBUFFERS_FINAL_CLASS {
 private:
  float position_;
  DeepSeaVectorDraw::Color color_;

 public:
  GradientStop()
      : position_(0),
        color_() {
  }
  GradientStop(float _position, const DeepSeaVectorDraw::Color &_color)
      : position_(::flatbuffers::EndianScalar(_position)),
        color_(_color) {
  }
  float position() const {
    return ::flatbuffers::EndianScalar(position_);
  }
  const DeepSeaVectorDraw::Color &color() const {
    return color_;
  }
};
FLATBUFFERS_STRUCT_END(GradientStop, 8);

struct ColorMaterial FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ColorMaterialBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_COLOR = 6
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const DeepSeaVectorDraw::Color *color() const {
    return GetStruct<const DeepSeaVectorDraw::Color *>(VT_COLOR);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Color>(verifier, VT_COLOR, 1) &&
           verifier.EndTable();
  }
};

struct ColorMaterialBuilder {
  typedef ColorMaterial Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(ColorMaterial::VT_NAME, name);
  }
  void add_color(const DeepSeaVectorDraw::Color *color) {
    fbb_.AddStruct(ColorMaterial::VT_COLOR, color);
  }
  explicit ColorMaterialBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ColorMaterial> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ColorMaterial>(end);
    fbb_.Required(o, ColorMaterial::VT_NAME);
    fbb_.Required(o, ColorMaterial::VT_COLOR);
    return o;
  }
};

inline ::flatbuffers::Offset<ColorMaterial> CreateColorMaterial(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    const DeepSeaVectorDraw::Color *color = nullptr) {
  ColorMaterialBuilder builder_(_fbb);
  builder_.add_color(color);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ColorMaterial> CreateColorMaterialDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const DeepSeaVectorDraw::Color *color = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return DeepSeaVectorDraw::CreateColorMaterial(
      _fbb,
      name__,
      color);
}

struct LinearGradient FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LinearGradientBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_GRADIENT = 6,
    VT_START = 8,
    VT_END = 10,
    VT_EDGE = 12,
    VT_COORDINATESPACE = 14,
    VT_TRANSFORM = 16
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<const DeepSeaVectorDraw::GradientStop *> *gradient() const {
    return GetPointer<const ::flatbuffers::Vector<const DeepSeaVectorDraw::GradientStop *> *>(VT_GRADIENT);
  }
  const DeepSeaVectorDraw::Vector2f *start() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_START);
  }
  const DeepSeaVectorDraw::Vector2f *end() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_END);
  }
  DeepSeaVectorDraw::GradientEdge edge() const {
    return static_cast<DeepSeaVectorDraw::GradientEdge>(GetField<uint8_t>(VT_EDGE, 0));
  }
  DeepSeaVectorDraw::MaterialSpace coordinateSpace() const {
    return static_cast<DeepSeaVectorDraw::MaterialSpace>(GetField<uint8_t>(VT_COORDINATESPACE, 0));
  }
  const DeepSeaVectorDraw::Matrix33f *transform() const {
    return GetStruct<const DeepSeaVectorDraw::Matrix33f *>(VT_TRANSFORM);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_GRADIENT) &&
           verifier.VerifyVector(gradient()) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_START, 4) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_END, 4) &&
           VerifyField<uint8_t>(verifier, VT_EDGE, 1) &&
           VerifyField<uint8_t>(verifier, VT_COORDINATESPACE, 1) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Matrix33f>(verifier, VT_TRANSFORM, 4) &&
           verifier.EndTable();
  }
};

struct LinearGradientBuilder {
  typedef LinearGradient Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(LinearGradient::VT_NAME, name);
  }
  void add_gradient(::flatbuffers::Offset<::flatbuffers::Vector<const DeepSeaVectorDraw::GradientStop *>> gradient) {
    fbb_.AddOffset(LinearGradient::VT_GRADIENT, gradient);
  }
  void add_start(const DeepSeaVectorDraw::Vector2f *start) {
    fbb_.AddStruct(LinearGradient::VT_START, start);
  }
  void add_end(const DeepSeaVectorDraw::Vector2f *end) {
    fbb_.AddStruct(LinearGradient::VT_END, end);
  }
  void add_edge(DeepSeaVectorDraw::GradientEdge edge) {
    fbb_.AddElement<uint8_t>(LinearGradient::VT_EDGE, static_cast<uint8_t>(edge), 0);
  }
  void add_coordinateSpace(DeepSeaVectorDraw::MaterialSpace coordinateSpace) {
    fbb_.AddElement<uint8_t>(LinearGradient::VT_COORDINATESPACE, static_cast<uint8_t>(coordinateSpace), 0);
  }
  void add_transform(const DeepSeaVectorDraw::Matrix33f *transform) {
    fbb_.AddStruct(LinearGradient::VT_TRANSFORM, transform);
  }
  explicit LinearGradientBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LinearGradient> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LinearGradient>(end);
    fbb_.Required(o, LinearGradient::VT_NAME);
    fbb_.Required(o, LinearGradient::VT_GRADIENT);
    fbb_.Required(o, LinearGradient::VT_START);
    fbb_.Required(o, LinearGradient::VT_END);
    fbb_.Required(o, LinearGradient::VT_TRANSFORM);
    return o;
  }
};

inline ::flatbuffers::Offset<LinearGradient> CreateLinearGradient(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const DeepSeaVectorDraw::GradientStop *>> gradient = 0,
    const DeepSeaVectorDraw::Vector2f *start = nullptr,
    const DeepSeaVectorDraw::Vector2f *end = nullptr,
    DeepSeaVectorDraw::GradientEdge edge = DeepSeaVectorDraw::GradientEdge::Clamp,
    DeepSeaVectorDraw::MaterialSpace coordinateSpace = DeepSeaVectorDraw::MaterialSpace::Local,
    const DeepSeaVectorDraw::Matrix33f *transform = nullptr) {
  LinearGradientBuilder builder_(_fbb);
  builder_.add_transform(transform);
  builder_.add_end(end);
  builder_.add_start(start);
  builder_.add_gradient(gradient);
  builder_.add_name(name);
  builder_.add_coordinateSpace(coordinateSpace);
  builder_.add_edge(edge);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<LinearGradient> CreateLinearGradientDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<DeepSeaVectorDraw::GradientStop> *gradient = nullptr,
    const DeepSeaVectorDraw::Vector2f *start = nullptr,
    const DeepSeaVectorDraw::Vector2f *end = nullptr,
    DeepSeaVectorDraw::GradientEdge edge = DeepSeaVectorDraw::GradientEdge::Clamp,
    DeepSeaVectorDraw::MaterialSpace coordinateSpace = DeepSeaVectorDraw::MaterialSpace::Local,
    const DeepSeaVectorDraw::Matrix33f *transform = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto gradient__ = gradient ? _fbb.CreateVectorOfStructs<DeepSeaVectorDraw::GradientStop>(*gradient) : 0;
  return DeepSeaVectorDraw::CreateLinearGradient(
      _fbb,
      name__,
      gradient__,
      start,
      end,
      edge,
      coordinateSpace,
      transform);
}

struct RadialGradient FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RadialGradientBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_GRADIENT = 6,
    VT_CENTER = 8,
    VT_RADIUS = 10,
    VT_FOCUS = 12,
    VT_FOCUSRADIUS = 14,
    VT_EDGE = 16,
    VT_COORDINATESPACE = 18,
    VT_TRANSFORM = 20
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<const DeepSeaVectorDraw::GradientStop *> *gradient() const {
    return GetPointer<const ::flatbuffers::Vector<const DeepSeaVectorDraw::GradientStop *> *>(VT_GRADIENT);
  }
  const DeepSeaVectorDraw::Vector2f *center() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_CENTER);
  }
  float radius() const {
    return GetField<float>(VT_RADIUS, 0.0f);
  }
  const DeepSeaVectorDraw::Vector2f *focus() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_FOCUS);
  }
  float focusRadius() const {
    return GetField<float>(VT_FOCUSRADIUS, 0.0f);
  }
  DeepSeaVectorDraw::GradientEdge edge() const {
    return static_cast<DeepSeaVectorDraw::GradientEdge>(GetField<uint8_t>(VT_EDGE, 0));
  }
  DeepSeaVectorDraw::MaterialSpace coordinateSpace() const {
    return static_cast<DeepSeaVectorDraw::MaterialSpace>(GetField<uint8_t>(VT_COORDINATESPACE, 0));
  }
  const DeepSeaVectorDraw::Matrix33f *transform() const {
    return GetStruct<const DeepSeaVectorDraw::Matrix33f *>(VT_TRANSFORM);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffsetRequired(verifier, VT_GRADIENT) &&
           verifier.VerifyVector(gradient()) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_CENTER, 4) &&
           VerifyField<float>(verifier, VT_RADIUS, 4) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_FOCUS, 4) &&
           VerifyField<float>(verifier, VT_FOCUSRADIUS, 4) &&
           VerifyField<uint8_t>(verifier, VT_EDGE, 1) &&
           VerifyField<uint8_t>(verifier, VT_COORDINATESPACE, 1) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Matrix33f>(verifier, VT_TRANSFORM, 4) &&
           verifier.EndTable();
  }
};

struct RadialGradientBuilder {
  typedef RadialGradient Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(RadialGradient::VT_NAME, name);
  }
  void add_gradient(::flatbuffers::Offset<::flatbuffers::Vector<const DeepSeaVectorDraw::GradientStop *>> gradient) {
    fbb_.AddOffset(RadialGradient::VT_GRADIENT, gradient);
  }
  void add_center(const DeepSeaVectorDraw::Vector2f *center) {
    fbb_.AddStruct(RadialGradient::VT_CENTER, center);
  }
  void add_radius(float radius) {
    fbb_.AddElement<float>(RadialGradient::VT_RADIUS, radius, 0.0f);
  }
  void add_focus(const DeepSeaVectorDraw::Vector2f *focus) {
    fbb_.AddStruct(RadialGradient::VT_FOCUS, focus);
  }
  void add_focusRadius(float focusRadius) {
    fbb_.AddElement<float>(RadialGradient::VT_FOCUSRADIUS, focusRadius, 0.0f);
  }
  void add_edge(DeepSeaVectorDraw::GradientEdge edge) {
    fbb_.AddElement<uint8_t>(RadialGradient::VT_EDGE, static_cast<uint8_t>(edge), 0);
  }
  void add_coordinateSpace(DeepSeaVectorDraw::MaterialSpace coordinateSpace) {
    fbb_.AddElement<uint8_t>(RadialGradient::VT_COORDINATESPACE, static_cast<uint8_t>(coordinateSpace), 0);
  }
  void add_transform(const DeepSeaVectorDraw::Matrix33f *transform) {
    fbb_.AddStruct(RadialGradient::VT_TRANSFORM, transform);
  }
  explicit RadialGradientBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RadialGradient> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RadialGradient>(end);
    fbb_.Required(o, RadialGradient::VT_NAME);
    fbb_.Required(o, RadialGradient::VT_GRADIENT);
    fbb_.Required(o, RadialGradient::VT_CENTER);
    fbb_.Required(o, RadialGradient::VT_FOCUS);
    fbb_.Required(o, RadialGradient::VT_TRANSFORM);
    return o;
  }
};

inline ::flatbuffers::Offset<RadialGradient> CreateRadialGradient(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const DeepSeaVectorDraw::GradientStop *>> gradient = 0,
    const DeepSeaVectorDraw::Vector2f *center = nullptr,
    float radius = 0.0f,
    const DeepSeaVectorDraw::Vector2f *focus = nullptr,
    float focusRadius = 0.0f,
    DeepSeaVectorDraw::GradientEdge edge = DeepSeaVectorDraw::GradientEdge::Clamp,
    DeepSeaVectorDraw::MaterialSpace coordinateSpace = DeepSeaVectorDraw::MaterialSpace::Local,
    const DeepSeaVectorDraw::Matrix33f *transform = nullptr) {
  RadialGradientBuilder builder_(_fbb);
  builder_.add_transform(transform);
  builder_.add_focusRadius(focusRadius);
  builder_.add_focus(focus);
  builder_.add_radius(radius);
  builder_.add_center(center);
  builder_.add_gradient(gradient);
  builder_.add_name(name);
  builder_.add_coordinateSpace(coordinateSpace);
  builder_.add_edge(edge);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<RadialGradient> CreateRadialGradientDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<DeepSeaVectorDraw::GradientStop> *gradient = nullptr,
    const DeepSeaVectorDraw::Vector2f *center = nullptr,
    float radius = 0.0f,
    const DeepSeaVectorDraw::Vector2f *focus = nullptr,
    float focusRadius = 0.0f,
    DeepSeaVectorDraw::GradientEdge edge = DeepSeaVectorDraw::GradientEdge::Clamp,
    DeepSeaVectorDraw::MaterialSpace coordinateSpace = DeepSeaVectorDraw::MaterialSpace::Local,
    const DeepSeaVectorDraw::Matrix33f *transform = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto gradient__ = gradient ? _fbb.CreateVectorOfStructs<DeepSeaVectorDraw::GradientStop>(*gradient) : 0;
  return DeepSeaVectorDraw::CreateRadialGradient(
      _fbb,
      name__,
      gradient__,
      center,
      radius,
      focus,
      focusRadius,
      edge,
      coordinateSpace,
      transform);
}

struct StartPathCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartPathCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSFORM = 4,
    VT_SIMPLE = 6
  };
  const DeepSeaVectorDraw::Matrix33f *transform() const {
    return GetStruct<const DeepSeaVectorDraw::Matrix33f *>(VT_TRANSFORM);
  }
  bool simple() const {
    return GetField<uint8_t>(VT_SIMPLE, 0) != 0;
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Matrix33f>(verifier, VT_TRANSFORM, 4) &&
           VerifyField<uint8_t>(verifier, VT_SIMPLE, 1) &&
           verifier.EndTable();
  }
};

struct StartPathCommandBuilder {
  typedef StartPathCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_transform(const DeepSeaVectorDraw::Matrix33f *transform) {
    fbb_.AddStruct(StartPathCommand::VT_TRANSFORM, transform);
  }
  void add_simple(bool simple) {
    fbb_.AddElement<uint8_t>(StartPathCommand::VT_SIMPLE, static_cast<uint8_t>(simple), 0);
  }
  explicit StartPathCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StartPathCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StartPathCommand>(end);
    fbb_.Required(o, StartPathCommand::VT_TRANSFORM);
    return o;
  }
};

inline ::flatbuffers::Offset<StartPathCommand> CreateStartPathCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const DeepSeaVectorDraw::Matrix33f *transform = nullptr,
    bool simple = false) {
  StartPathCommandBuilder builder_(_fbb);
  builder_.add_transform(transform);
  builder_.add_simple(simple);
  return builder_.Finish();
}

struct MoveCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef MoveCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POSITION = 4
  };
  const DeepSeaVectorDraw::Vector2f *position() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_POSITION);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_POSITION, 4) &&
           verifier.EndTable();
  }
};

struct MoveCommandBuilder {
  typedef MoveCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_position(const DeepSeaVectorDraw::Vector2f *position) {
    fbb_.AddStruct(MoveCommand::VT_POSITION, position);
  }
  explicit MoveCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<MoveCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<MoveCommand>(end);
    fbb_.Required(o, MoveCommand::VT_POSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<MoveCommand> CreateMoveCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const DeepSeaVectorDraw::Vector2f *position = nullptr) {
  MoveCommandBuilder builder_(_fbb);
  builder_.add_position(position);
  return builder_.Finish();
}

struct LineCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef LineCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_END = 4
  };
  const DeepSeaVectorDraw::Vector2f *end() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_END);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_END, 4) &&
           verifier.EndTable();
  }
};

struct LineCommandBuilder {
  typedef LineCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_end(const DeepSeaVectorDraw::Vector2f *end) {
    fbb_.AddStruct(LineCommand::VT_END, end);
  }
  explicit LineCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<LineCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<LineCommand>(end);
    fbb_.Required(o, LineCommand::VT_END);
    return o;
  }
};

inline ::flatbuffers::Offset<LineCommand> CreateLineCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const DeepSeaVectorDraw::Vector2f *end = nullptr) {
  LineCommandBuilder builder_(_fbb);
  builder_.add_end(end);
  return builder_.Finish();
}

struct BezierCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef BezierCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTROL1 = 4,
    VT_CONTROL2 = 6,
    VT_END = 8
  };
  const DeepSeaVectorDraw::Vector2f *control1() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_CONTROL1);
  }
  const DeepSeaVectorDraw::Vector2f *control2() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_CONTROL2);
  }
  const DeepSeaVectorDraw::Vector2f *end() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_END);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_CONTROL1, 4) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_CONTROL2, 4) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_END, 4) &&
           verifier.EndTable();
  }
};

struct BezierCommandBuilder {
  typedef BezierCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_control1(const DeepSeaVectorDraw::Vector2f *control1) {
    fbb_.AddStruct(BezierCommand::VT_CONTROL1, control1);
  }
  void add_control2(const DeepSeaVectorDraw::Vector2f *control2) {
    fbb_.AddStruct(BezierCommand::VT_CONTROL2, control2);
  }
  void add_end(const DeepSeaVectorDraw::Vector2f *end) {
    fbb_.AddStruct(BezierCommand::VT_END, end);
  }
  explicit BezierCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<BezierCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<BezierCommand>(end);
    fbb_.Required(o, BezierCommand::VT_CONTROL1);
    fbb_.Required(o, BezierCommand::VT_CONTROL2);
    fbb_.Required(o, BezierCommand::VT_END);
    return o;
  }
};

inline ::flatbuffers::Offset<BezierCommand> CreateBezierCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const DeepSeaVectorDraw::Vector2f *control1 = nullptr,
    const DeepSeaVectorDraw::Vector2f *control2 = nullptr,
    const DeepSeaVectorDraw::Vector2f *end = nullptr) {
  BezierCommandBuilder builder_(_fbb);
  builder_.add_end(end);
  builder_.add_control2(control2);
  builder_.add_control1(control1);
  return builder_.Finish();
}

struct QuadraticCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuadraticCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTROL = 4,
    VT_END = 6
  };
  const DeepSeaVectorDraw::Vector2f *control() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_CONTROL);
  }
  const DeepSeaVectorDraw::Vector2f *end() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_END);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_CONTROL, 4) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_END, 4) &&
           verifier.EndTable();
  }
};

struct QuadraticCommandBuilder {
  typedef QuadraticCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_control(const DeepSeaVectorDraw::Vector2f *control) {
    fbb_.AddStruct(QuadraticCommand::VT_CONTROL, control);
  }
  void add_end(const DeepSeaVectorDraw::Vector2f *end) {
    fbb_.AddStruct(QuadraticCommand::VT_END, end);
  }
  explicit QuadraticCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QuadraticCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QuadraticCommand>(end);
    fbb_.Required(o, QuadraticCommand::VT_CONTROL);
    fbb_.Required(o, QuadraticCommand::VT_END);
    return o;
  }
};

inline ::flatbuffers::Offset<QuadraticCommand> CreateQuadraticCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const DeepSeaVectorDraw::Vector2f *control = nullptr,
    const DeepSeaVectorDraw::Vector2f *end = nullptr) {
  QuadraticCommandBuilder builder_(_fbb);
  builder_.add_end(end);
  builder_.add_control(control);
  return builder_.Finish();
}

struct ArcCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ArcCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RADIUS = 4,
    VT_ROTATION = 6,
    VT_LARGEARC = 8,
    VT_CLOCKWISE = 10,
    VT_END = 12
  };
  const DeepSeaVectorDraw::Vector2f *radius() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_RADIUS);
  }
  float rotation() const {
    return GetField<float>(VT_ROTATION, 0.0f);
  }
  bool largeArc() const {
    return GetField<uint8_t>(VT_LARGEARC, 0) != 0;
  }
  bool clockwise() const {
    return GetField<uint8_t>(VT_CLOCKWISE, 0) != 0;
  }
  const DeepSeaVectorDraw::Vector2f *end() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_END);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_RADIUS, 4) &&
           VerifyField<float>(verifier, VT_ROTATION, 4) &&
           VerifyField<uint8_t>(verifier, VT_LARGEARC, 1) &&
           VerifyField<uint8_t>(verifier, VT_CLOCKWISE, 1) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_END, 4) &&
           verifier.EndTable();
  }
};

struct ArcCommandBuilder {
  typedef ArcCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_radius(const DeepSeaVectorDraw::Vector2f *radius) {
    fbb_.AddStruct(ArcCommand::VT_RADIUS, radius);
  }
  void add_rotation(float rotation) {
    fbb_.AddElement<float>(ArcCommand::VT_ROTATION, rotation, 0.0f);
  }
  void add_largeArc(bool largeArc) {
    fbb_.AddElement<uint8_t>(ArcCommand::VT_LARGEARC, static_cast<uint8_t>(largeArc), 0);
  }
  void add_clockwise(bool clockwise) {
    fbb_.AddElement<uint8_t>(ArcCommand::VT_CLOCKWISE, static_cast<uint8_t>(clockwise), 0);
  }
  void add_end(const DeepSeaVectorDraw::Vector2f *end) {
    fbb_.AddStruct(ArcCommand::VT_END, end);
  }
  explicit ArcCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ArcCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ArcCommand>(end);
    fbb_.Required(o, ArcCommand::VT_RADIUS);
    fbb_.Required(o, ArcCommand::VT_END);
    return o;
  }
};

inline ::flatbuffers::Offset<ArcCommand> CreateArcCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const DeepSeaVectorDraw::Vector2f *radius = nullptr,
    float rotation = 0.0f,
    bool largeArc = false,
    bool clockwise = false,
    const DeepSeaVectorDraw::Vector2f *end = nullptr) {
  ArcCommandBuilder builder_(_fbb);
  builder_.add_end(end);
  builder_.add_rotation(rotation);
  builder_.add_radius(radius);
  builder_.add_clockwise(clockwise);
  builder_.add_largeArc(largeArc);
  return builder_.Finish();
}

struct ClosePathCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ClosePathCommandBuilder Builder;
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ClosePathCommandBuilder {
  typedef ClosePathCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit ClosePathCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ClosePathCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ClosePathCommand>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ClosePathCommand> CreateClosePathCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  ClosePathCommandBuilder builder_(_fbb);
  return builder_.Finish();
}

struct EllipseCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EllipseCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER = 4,
    VT_RADIUS = 6
  };
  const DeepSeaVectorDraw::Vector2f *center() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_CENTER);
  }
  const DeepSeaVectorDraw::Vector2f *radius() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_RADIUS);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_CENTER, 4) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_RADIUS, 4) &&
           verifier.EndTable();
  }
};

struct EllipseCommandBuilder {
  typedef EllipseCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_center(const DeepSeaVectorDraw::Vector2f *center) {
    fbb_.AddStruct(EllipseCommand::VT_CENTER, center);
  }
  void add_radius(const DeepSeaVectorDraw::Vector2f *radius) {
    fbb_.AddStruct(EllipseCommand::VT_RADIUS, radius);
  }
  explicit EllipseCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EllipseCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EllipseCommand>(end);
    fbb_.Required(o, EllipseCommand::VT_CENTER);
    fbb_.Required(o, EllipseCommand::VT_RADIUS);
    return o;
  }
};

inline ::flatbuffers::Offset<EllipseCommand> CreateEllipseCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const DeepSeaVectorDraw::Vector2f *center = nullptr,
    const DeepSeaVectorDraw::Vector2f *radius = nullptr) {
  EllipseCommandBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_center(center);
  return builder_.Finish();
}

struct RectangleCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RectangleCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UPPERLEFT = 4,
    VT_LOWERRIGHT = 6,
    VT_CORNERRADIUS = 8
  };
  const DeepSeaVectorDraw::Vector2f *upperLeft() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_UPPERLEFT);
  }
  const DeepSeaVectorDraw::Vector2f *lowerRight() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_LOWERRIGHT);
  }
  const DeepSeaVectorDraw::Vector2f *cornerRadius() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_CORNERRADIUS);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_UPPERLEFT, 4) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_LOWERRIGHT, 4) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_CORNERRADIUS, 4) &&
           verifier.EndTable();
  }
};

struct RectangleCommandBuilder {
  typedef RectangleCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_upperLeft(const DeepSeaVectorDraw::Vector2f *upperLeft) {
    fbb_.AddStruct(RectangleCommand::VT_UPPERLEFT, upperLeft);
  }
  void add_lowerRight(const DeepSeaVectorDraw::Vector2f *lowerRight) {
    fbb_.AddStruct(RectangleCommand::VT_LOWERRIGHT, lowerRight);
  }
  void add_cornerRadius(const DeepSeaVectorDraw::Vector2f *cornerRadius) {
    fbb_.AddStruct(RectangleCommand::VT_CORNERRADIUS, cornerRadius);
  }
  explicit RectangleCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RectangleCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RectangleCommand>(end);
    fbb_.Required(o, RectangleCommand::VT_UPPERLEFT);
    fbb_.Required(o, RectangleCommand::VT_LOWERRIGHT);
    fbb_.Required(o, RectangleCommand::VT_CORNERRADIUS);
    return o;
  }
};

inline ::flatbuffers::Offset<RectangleCommand> CreateRectangleCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const DeepSeaVectorDraw::Vector2f *upperLeft = nullptr,
    const DeepSeaVectorDraw::Vector2f *lowerRight = nullptr,
    const DeepSeaVectorDraw::Vector2f *cornerRadius = nullptr) {
  RectangleCommandBuilder builder_(_fbb);
  builder_.add_cornerRadius(cornerRadius);
  builder_.add_lowerRight(lowerRight);
  builder_.add_upperLeft(upperLeft);
  return builder_.Finish();
}

struct StrokePathCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StrokePathCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATERIAL = 4,
    VT_OPACITY = 6,
    VT_JOINTYPE = 8,
    VT_CAPTYPE = 10,
    VT_WIDTH = 12,
    VT_MITERLIMIT = 14,
    VT_DASHARRAY = 16
  };
  const ::flatbuffers::String *material() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MATERIAL);
  }
  float opacity() const {
    return GetField<float>(VT_OPACITY, 0.0f);
  }
  DeepSeaVectorDraw::LineJoin joinType() const {
    return static_cast<DeepSeaVectorDraw::LineJoin>(GetField<uint8_t>(VT_JOINTYPE, 0));
  }
  DeepSeaVectorDraw::LineCap capType() const {
    return static_cast<DeepSeaVectorDraw::LineCap>(GetField<uint8_t>(VT_CAPTYPE, 0));
  }
  float width() const {
    return GetField<float>(VT_WIDTH, 0.0f);
  }
  float miterLimit() const {
    return GetField<float>(VT_MITERLIMIT, 0.0f);
  }
  const DeepSeaVectorDraw::DashArray *dashArray() const {
    return GetStruct<const DeepSeaVectorDraw::DashArray *>(VT_DASHARRAY);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MATERIAL) &&
           verifier.VerifyString(material()) &&
           VerifyField<float>(verifier, VT_OPACITY, 4) &&
           VerifyField<uint8_t>(verifier, VT_JOINTYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_CAPTYPE, 1) &&
           VerifyField<float>(verifier, VT_WIDTH, 4) &&
           VerifyField<float>(verifier, VT_MITERLIMIT, 4) &&
           VerifyFieldRequired<DeepSeaVectorDraw::DashArray>(verifier, VT_DASHARRAY, 4) &&
           verifier.EndTable();
  }
};

struct StrokePathCommandBuilder {
  typedef StrokePathCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_material(::flatbuffers::Offset<::flatbuffers::String> material) {
    fbb_.AddOffset(StrokePathCommand::VT_MATERIAL, material);
  }
  void add_opacity(float opacity) {
    fbb_.AddElement<float>(StrokePathCommand::VT_OPACITY, opacity, 0.0f);
  }
  void add_joinType(DeepSeaVectorDraw::LineJoin joinType) {
    fbb_.AddElement<uint8_t>(StrokePathCommand::VT_JOINTYPE, static_cast<uint8_t>(joinType), 0);
  }
  void add_capType(DeepSeaVectorDraw::LineCap capType) {
    fbb_.AddElement<uint8_t>(StrokePathCommand::VT_CAPTYPE, static_cast<uint8_t>(capType), 0);
  }
  void add_width(float width) {
    fbb_.AddElement<float>(StrokePathCommand::VT_WIDTH, width, 0.0f);
  }
  void add_miterLimit(float miterLimit) {
    fbb_.AddElement<float>(StrokePathCommand::VT_MITERLIMIT, miterLimit, 0.0f);
  }
  void add_dashArray(const DeepSeaVectorDraw::DashArray *dashArray) {
    fbb_.AddStruct(StrokePathCommand::VT_DASHARRAY, dashArray);
  }
  explicit StrokePathCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StrokePathCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StrokePathCommand>(end);
    fbb_.Required(o, StrokePathCommand::VT_MATERIAL);
    fbb_.Required(o, StrokePathCommand::VT_DASHARRAY);
    return o;
  }
};

inline ::flatbuffers::Offset<StrokePathCommand> CreateStrokePathCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> material = 0,
    float opacity = 0.0f,
    DeepSeaVectorDraw::LineJoin joinType = DeepSeaVectorDraw::LineJoin::Miter,
    DeepSeaVectorDraw::LineCap capType = DeepSeaVectorDraw::LineCap::Butt,
    float width = 0.0f,
    float miterLimit = 0.0f,
    const DeepSeaVectorDraw::DashArray *dashArray = nullptr) {
  StrokePathCommandBuilder builder_(_fbb);
  builder_.add_dashArray(dashArray);
  builder_.add_miterLimit(miterLimit);
  builder_.add_width(width);
  builder_.add_opacity(opacity);
  builder_.add_material(material);
  builder_.add_capType(capType);
  builder_.add_joinType(joinType);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<StrokePathCommand> CreateStrokePathCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *material = nullptr,
    float opacity = 0.0f,
    DeepSeaVectorDraw::LineJoin joinType = DeepSeaVectorDraw::LineJoin::Miter,
    DeepSeaVectorDraw::LineCap capType = DeepSeaVectorDraw::LineCap::Butt,
    float width = 0.0f,
    float miterLimit = 0.0f,
    const DeepSeaVectorDraw::DashArray *dashArray = nullptr) {
  auto material__ = material ? _fbb.CreateString(material) : 0;
  return DeepSeaVectorDraw::CreateStrokePathCommand(
      _fbb,
      material__,
      opacity,
      joinType,
      capType,
      width,
      miterLimit,
      dashArray);
}

struct FillPathCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FillPathCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MATERIAL = 4,
    VT_OPACITY = 6,
    VT_FILLRULE = 8
  };
  const ::flatbuffers::String *material() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MATERIAL);
  }
  float opacity() const {
    return GetField<float>(VT_OPACITY, 0.0f);
  }
  DeepSeaVectorDraw::FillRule fillRule() const {
    return static_cast<DeepSeaVectorDraw::FillRule>(GetField<uint8_t>(VT_FILLRULE, 0));
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_MATERIAL) &&
           verifier.VerifyString(material()) &&
           VerifyField<float>(verifier, VT_OPACITY, 4) &&
           VerifyField<uint8_t>(verifier, VT_FILLRULE, 1) &&
           verifier.EndTable();
  }
};

struct FillPathCommandBuilder {
  typedef FillPathCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_material(::flatbuffers::Offset<::flatbuffers::String> material) {
    fbb_.AddOffset(FillPathCommand::VT_MATERIAL, material);
  }
  void add_opacity(float opacity) {
    fbb_.AddElement<float>(FillPathCommand::VT_OPACITY, opacity, 0.0f);
  }
  void add_fillRule(DeepSeaVectorDraw::FillRule fillRule) {
    fbb_.AddElement<uint8_t>(FillPathCommand::VT_FILLRULE, static_cast<uint8_t>(fillRule), 0);
  }
  explicit FillPathCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FillPathCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FillPathCommand>(end);
    fbb_.Required(o, FillPathCommand::VT_MATERIAL);
    return o;
  }
};

inline ::flatbuffers::Offset<FillPathCommand> CreateFillPathCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> material = 0,
    float opacity = 0.0f,
    DeepSeaVectorDraw::FillRule fillRule = DeepSeaVectorDraw::FillRule::EvenOdd) {
  FillPathCommandBuilder builder_(_fbb);
  builder_.add_opacity(opacity);
  builder_.add_material(material);
  builder_.add_fillRule(fillRule);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<FillPathCommand> CreateFillPathCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *material = nullptr,
    float opacity = 0.0f,
    DeepSeaVectorDraw::FillRule fillRule = DeepSeaVectorDraw::FillRule::EvenOdd) {
  auto material__ = material ? _fbb.CreateString(material) : 0;
  return DeepSeaVectorDraw::CreateFillPathCommand(
      _fbb,
      material__,
      opacity,
      fillRule);
}

struct TextCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TEXT = 4,
    VT_FONT = 6,
    VT_ALIGNMENT = 8,
    VT_MAXLENGTH = 10,
    VT_LINEHEIGHT = 12,
    VT_TRANSFORM = 14,
    VT_RANGECOUNT = 16
  };
  const ::flatbuffers::String *text() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TEXT);
  }
  const ::flatbuffers::String *font() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FONT);
  }
  DeepSeaVectorDraw::TextAlign alignment() const {
    return static_cast<DeepSeaVectorDraw::TextAlign>(GetField<uint8_t>(VT_ALIGNMENT, 0));
  }
  float maxLength() const {
    return GetField<float>(VT_MAXLENGTH, 0.0f);
  }
  float lineHeight() const {
    return GetField<float>(VT_LINEHEIGHT, 0.0f);
  }
  const DeepSeaVectorDraw::Matrix33f *transform() const {
    return GetStruct<const DeepSeaVectorDraw::Matrix33f *>(VT_TRANSFORM);
  }
  uint32_t rangeCount() const {
    return GetField<uint32_t>(VT_RANGECOUNT, 0);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           VerifyOffsetRequired(verifier, VT_FONT) &&
           verifier.VerifyString(font()) &&
           VerifyField<uint8_t>(verifier, VT_ALIGNMENT, 1) &&
           VerifyField<float>(verifier, VT_MAXLENGTH, 4) &&
           VerifyField<float>(verifier, VT_LINEHEIGHT, 4) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Matrix33f>(verifier, VT_TRANSFORM, 4) &&
           VerifyField<uint32_t>(verifier, VT_RANGECOUNT, 4) &&
           verifier.EndTable();
  }
};

struct TextCommandBuilder {
  typedef TextCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_text(::flatbuffers::Offset<::flatbuffers::String> text) {
    fbb_.AddOffset(TextCommand::VT_TEXT, text);
  }
  void add_font(::flatbuffers::Offset<::flatbuffers::String> font) {
    fbb_.AddOffset(TextCommand::VT_FONT, font);
  }
  void add_alignment(DeepSeaVectorDraw::TextAlign alignment) {
    fbb_.AddElement<uint8_t>(TextCommand::VT_ALIGNMENT, static_cast<uint8_t>(alignment), 0);
  }
  void add_maxLength(float maxLength) {
    fbb_.AddElement<float>(TextCommand::VT_MAXLENGTH, maxLength, 0.0f);
  }
  void add_lineHeight(float lineHeight) {
    fbb_.AddElement<float>(TextCommand::VT_LINEHEIGHT, lineHeight, 0.0f);
  }
  void add_transform(const DeepSeaVectorDraw::Matrix33f *transform) {
    fbb_.AddStruct(TextCommand::VT_TRANSFORM, transform);
  }
  void add_rangeCount(uint32_t rangeCount) {
    fbb_.AddElement<uint32_t>(TextCommand::VT_RANGECOUNT, rangeCount, 0);
  }
  explicit TextCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TextCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TextCommand>(end);
    fbb_.Required(o, TextCommand::VT_TEXT);
    fbb_.Required(o, TextCommand::VT_FONT);
    fbb_.Required(o, TextCommand::VT_TRANSFORM);
    return o;
  }
};

inline ::flatbuffers::Offset<TextCommand> CreateTextCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> text = 0,
    ::flatbuffers::Offset<::flatbuffers::String> font = 0,
    DeepSeaVectorDraw::TextAlign alignment = DeepSeaVectorDraw::TextAlign::Start,
    float maxLength = 0.0f,
    float lineHeight = 0.0f,
    const DeepSeaVectorDraw::Matrix33f *transform = nullptr,
    uint32_t rangeCount = 0) {
  TextCommandBuilder builder_(_fbb);
  builder_.add_rangeCount(rangeCount);
  builder_.add_transform(transform);
  builder_.add_lineHeight(lineHeight);
  builder_.add_maxLength(maxLength);
  builder_.add_font(font);
  builder_.add_text(text);
  builder_.add_alignment(alignment);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TextCommand> CreateTextCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *text = nullptr,
    const char *font = nullptr,
    DeepSeaVectorDraw::TextAlign alignment = DeepSeaVectorDraw::TextAlign::Start,
    float maxLength = 0.0f,
    float lineHeight = 0.0f,
    const DeepSeaVectorDraw::Matrix33f *transform = nullptr,
    uint32_t rangeCount = 0) {
  auto text__ = text ? _fbb.CreateString(text) : 0;
  auto font__ = font ? _fbb.CreateString(font) : 0;
  return DeepSeaVectorDraw::CreateTextCommand(
      _fbb,
      text__,
      font__,
      alignment,
      maxLength,
      lineHeight,
      transform,
      rangeCount);
}

struct TextRangeCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TextRangeCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_START = 4,
    VT_COUNT = 6,
    VT_POSITIONTYPE = 8,
    VT_POSITION = 10,
    VT_FILLMATERIAL = 12,
    VT_OUTLINEMATERIAL = 14,
    VT_FILLOPACITY = 16,
    VT_OUTLINEOPACITY = 18,
    VT_SIZE = 20,
    VT_EMBOLDEN = 22,
    VT_SLANT = 24,
    VT_OUTLINEWIDTH = 26,
    VT_FUZINESS = 28
  };
  uint32_t start() const {
    return GetField<uint32_t>(VT_START, 0);
  }
  uint32_t count() const {
    return GetField<uint32_t>(VT_COUNT, 0);
  }
  DeepSeaVectorDraw::TextPosition positionType() const {
    return static_cast<DeepSeaVectorDraw::TextPosition>(GetField<uint8_t>(VT_POSITIONTYPE, 0));
  }
  const DeepSeaVectorDraw::Vector2f *position() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_POSITION);
  }
  const ::flatbuffers::String *fillMaterial() const {
    return GetPointer<const ::flatbuffers::String *>(VT_FILLMATERIAL);
  }
  const ::flatbuffers::String *outlineMaterial() const {
    return GetPointer<const ::flatbuffers::String *>(VT_OUTLINEMATERIAL);
  }
  float fillOpacity() const {
    return GetField<float>(VT_FILLOPACITY, 0.0f);
  }
  float outlineOpacity() const {
    return GetField<float>(VT_OUTLINEOPACITY, 0.0f);
  }
  float size() const {
    return GetField<float>(VT_SIZE, 0.0f);
  }
  float embolden() const {
    return GetField<float>(VT_EMBOLDEN, 0.0f);
  }
  float slant() const {
    return GetField<float>(VT_SLANT, 0.0f);
  }
  float outlineWidth() const {
    return GetField<float>(VT_OUTLINEWIDTH, 0.0f);
  }
  float fuziness() const {
    return GetField<float>(VT_FUZINESS, 0.0f);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_START, 4) &&
           VerifyField<uint32_t>(verifier, VT_COUNT, 4) &&
           VerifyField<uint8_t>(verifier, VT_POSITIONTYPE, 1) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_POSITION, 4) &&
           VerifyOffset(verifier, VT_FILLMATERIAL) &&
           verifier.VerifyString(fillMaterial()) &&
           VerifyOffset(verifier, VT_OUTLINEMATERIAL) &&
           verifier.VerifyString(outlineMaterial()) &&
           VerifyField<float>(verifier, VT_FILLOPACITY, 4) &&
           VerifyField<float>(verifier, VT_OUTLINEOPACITY, 4) &&
           VerifyField<float>(verifier, VT_SIZE, 4) &&
           VerifyField<float>(verifier, VT_EMBOLDEN, 4) &&
           VerifyField<float>(verifier, VT_SLANT, 4) &&
           VerifyField<float>(verifier, VT_OUTLINEWIDTH, 4) &&
           VerifyField<float>(verifier, VT_FUZINESS, 4) &&
           verifier.EndTable();
  }
};

struct TextRangeCommandBuilder {
  typedef TextRangeCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_start(uint32_t start) {
    fbb_.AddElement<uint32_t>(TextRangeCommand::VT_START, start, 0);
  }
  void add_count(uint32_t count) {
    fbb_.AddElement<uint32_t>(TextRangeCommand::VT_COUNT, count, 0);
  }
  void add_positionType(DeepSeaVectorDraw::TextPosition positionType) {
    fbb_.AddElement<uint8_t>(TextRangeCommand::VT_POSITIONTYPE, static_cast<uint8_t>(positionType), 0);
  }
  void add_position(const DeepSeaVectorDraw::Vector2f *position) {
    fbb_.AddStruct(TextRangeCommand::VT_POSITION, position);
  }
  void add_fillMaterial(::flatbuffers::Offset<::flatbuffers::String> fillMaterial) {
    fbb_.AddOffset(TextRangeCommand::VT_FILLMATERIAL, fillMaterial);
  }
  void add_outlineMaterial(::flatbuffers::Offset<::flatbuffers::String> outlineMaterial) {
    fbb_.AddOffset(TextRangeCommand::VT_OUTLINEMATERIAL, outlineMaterial);
  }
  void add_fillOpacity(float fillOpacity) {
    fbb_.AddElement<float>(TextRangeCommand::VT_FILLOPACITY, fillOpacity, 0.0f);
  }
  void add_outlineOpacity(float outlineOpacity) {
    fbb_.AddElement<float>(TextRangeCommand::VT_OUTLINEOPACITY, outlineOpacity, 0.0f);
  }
  void add_size(float size) {
    fbb_.AddElement<float>(TextRangeCommand::VT_SIZE, size, 0.0f);
  }
  void add_embolden(float embolden) {
    fbb_.AddElement<float>(TextRangeCommand::VT_EMBOLDEN, embolden, 0.0f);
  }
  void add_slant(float slant) {
    fbb_.AddElement<float>(TextRangeCommand::VT_SLANT, slant, 0.0f);
  }
  void add_outlineWidth(float outlineWidth) {
    fbb_.AddElement<float>(TextRangeCommand::VT_OUTLINEWIDTH, outlineWidth, 0.0f);
  }
  void add_fuziness(float fuziness) {
    fbb_.AddElement<float>(TextRangeCommand::VT_FUZINESS, fuziness, 0.0f);
  }
  explicit TextRangeCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<TextRangeCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<TextRangeCommand>(end);
    fbb_.Required(o, TextRangeCommand::VT_POSITION);
    return o;
  }
};

inline ::flatbuffers::Offset<TextRangeCommand> CreateTextRangeCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t start = 0,
    uint32_t count = 0,
    DeepSeaVectorDraw::TextPosition positionType = DeepSeaVectorDraw::TextPosition::Offset,
    const DeepSeaVectorDraw::Vector2f *position = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> fillMaterial = 0,
    ::flatbuffers::Offset<::flatbuffers::String> outlineMaterial = 0,
    float fillOpacity = 0.0f,
    float outlineOpacity = 0.0f,
    float size = 0.0f,
    float embolden = 0.0f,
    float slant = 0.0f,
    float outlineWidth = 0.0f,
    float fuziness = 0.0f) {
  TextRangeCommandBuilder builder_(_fbb);
  builder_.add_fuziness(fuziness);
  builder_.add_outlineWidth(outlineWidth);
  builder_.add_slant(slant);
  builder_.add_embolden(embolden);
  builder_.add_size(size);
  builder_.add_outlineOpacity(outlineOpacity);
  builder_.add_fillOpacity(fillOpacity);
  builder_.add_outlineMaterial(outlineMaterial);
  builder_.add_fillMaterial(fillMaterial);
  builder_.add_position(position);
  builder_.add_count(count);
  builder_.add_start(start);
  builder_.add_positionType(positionType);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<TextRangeCommand> CreateTextRangeCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t start = 0,
    uint32_t count = 0,
    DeepSeaVectorDraw::TextPosition positionType = DeepSeaVectorDraw::TextPosition::Offset,
    const DeepSeaVectorDraw::Vector2f *position = nullptr,
    const char *fillMaterial = nullptr,
    const char *outlineMaterial = nullptr,
    float fillOpacity = 0.0f,
    float outlineOpacity = 0.0f,
    float size = 0.0f,
    float embolden = 0.0f,
    float slant = 0.0f,
    float outlineWidth = 0.0f,
    float fuziness = 0.0f) {
  auto fillMaterial__ = fillMaterial ? _fbb.CreateString(fillMaterial) : 0;
  auto outlineMaterial__ = outlineMaterial ? _fbb.CreateString(outlineMaterial) : 0;
  return DeepSeaVectorDraw::CreateTextRangeCommand(
      _fbb,
      start,
      count,
      positionType,
      position,
      fillMaterial__,
      outlineMaterial__,
      fillOpacity,
      outlineOpacity,
      size,
      embolden,
      slant,
      outlineWidth,
      fuziness);
}

struct ImageCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ImageCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IMAGE = 4,
    VT_UPPERLEFT = 6,
    VT_LOWERRIGHT = 8,
    VT_OPACITY = 10,
    VT_TRANSFORM = 12
  };
  const ::flatbuffers::String *image() const {
    return GetPointer<const ::flatbuffers::String *>(VT_IMAGE);
  }
  const DeepSeaVectorDraw::Vector2f *upperLeft() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_UPPERLEFT);
  }
  const DeepSeaVectorDraw::Vector2f *lowerRight() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_LOWERRIGHT);
  }
  float opacity() const {
    return GetField<float>(VT_OPACITY, 0.0f);
  }
  const DeepSeaVectorDraw::Matrix33f *transform() const {
    return GetStruct<const DeepSeaVectorDraw::Matrix33f *>(VT_TRANSFORM);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_IMAGE) &&
           verifier.VerifyString(image()) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_UPPERLEFT, 4) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_LOWERRIGHT, 4) &&
           VerifyField<float>(verifier, VT_OPACITY, 4) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Matrix33f>(verifier, VT_TRANSFORM, 4) &&
           verifier.EndTable();
  }
};

struct ImageCommandBuilder {
  typedef ImageCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_image(::flatbuffers::Offset<::flatbuffers::String> image) {
    fbb_.AddOffset(ImageCommand::VT_IMAGE, image);
  }
  void add_upperLeft(const DeepSeaVectorDraw::Vector2f *upperLeft) {
    fbb_.AddStruct(ImageCommand::VT_UPPERLEFT, upperLeft);
  }
  void add_lowerRight(const DeepSeaVectorDraw::Vector2f *lowerRight) {
    fbb_.AddStruct(ImageCommand::VT_LOWERRIGHT, lowerRight);
  }
  void add_opacity(float opacity) {
    fbb_.AddElement<float>(ImageCommand::VT_OPACITY, opacity, 0.0f);
  }
  void add_transform(const DeepSeaVectorDraw::Matrix33f *transform) {
    fbb_.AddStruct(ImageCommand::VT_TRANSFORM, transform);
  }
  explicit ImageCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ImageCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ImageCommand>(end);
    fbb_.Required(o, ImageCommand::VT_IMAGE);
    fbb_.Required(o, ImageCommand::VT_UPPERLEFT);
    fbb_.Required(o, ImageCommand::VT_LOWERRIGHT);
    fbb_.Required(o, ImageCommand::VT_TRANSFORM);
    return o;
  }
};

inline ::flatbuffers::Offset<ImageCommand> CreateImageCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> image = 0,
    const DeepSeaVectorDraw::Vector2f *upperLeft = nullptr,
    const DeepSeaVectorDraw::Vector2f *lowerRight = nullptr,
    float opacity = 0.0f,
    const DeepSeaVectorDraw::Matrix33f *transform = nullptr) {
  ImageCommandBuilder builder_(_fbb);
  builder_.add_transform(transform);
  builder_.add_opacity(opacity);
  builder_.add_lowerRight(lowerRight);
  builder_.add_upperLeft(upperLeft);
  builder_.add_image(image);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ImageCommand> CreateImageCommandDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *image = nullptr,
    const DeepSeaVectorDraw::Vector2f *upperLeft = nullptr,
    const DeepSeaVectorDraw::Vector2f *lowerRight = nullptr,
    float opacity = 0.0f,
    const DeepSeaVectorDraw::Matrix33f *transform = nullptr) {
  auto image__ = image ? _fbb.CreateString(image) : 0;
  return DeepSeaVectorDraw::CreateImageCommand(
      _fbb,
      image__,
      upperLeft,
      lowerRight,
      opacity,
      transform);
}

struct VectorCommand FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VectorCommandBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMMAND_TYPE = 4,
    VT_COMMAND = 6
  };
  DeepSeaVectorDraw::VectorCommandUnion command_type() const {
    return static_cast<DeepSeaVectorDraw::VectorCommandUnion>(GetField<uint8_t>(VT_COMMAND_TYPE, 0));
  }
  const void *command() const {
    return GetPointer<const void *>(VT_COMMAND);
  }
  template<typename T> const T *command_as() const;
  const DeepSeaVectorDraw::StartPathCommand *command_as_StartPathCommand() const {
    return command_type() == DeepSeaVectorDraw::VectorCommandUnion::StartPathCommand ? static_cast<const DeepSeaVectorDraw::StartPathCommand *>(command()) : nullptr;
  }
  const DeepSeaVectorDraw::MoveCommand *command_as_MoveCommand() const {
    return command_type() == DeepSeaVectorDraw::VectorCommandUnion::MoveCommand ? static_cast<const DeepSeaVectorDraw::MoveCommand *>(command()) : nullptr;
  }
  const DeepSeaVectorDraw::LineCommand *command_as_LineCommand() const {
    return command_type() == DeepSeaVectorDraw::VectorCommandUnion::LineCommand ? static_cast<const DeepSeaVectorDraw::LineCommand *>(command()) : nullptr;
  }
  const DeepSeaVectorDraw::BezierCommand *command_as_BezierCommand() const {
    return command_type() == DeepSeaVectorDraw::VectorCommandUnion::BezierCommand ? static_cast<const DeepSeaVectorDraw::BezierCommand *>(command()) : nullptr;
  }
  const DeepSeaVectorDraw::QuadraticCommand *command_as_QuadraticCommand() const {
    return command_type() == DeepSeaVectorDraw::VectorCommandUnion::QuadraticCommand ? static_cast<const DeepSeaVectorDraw::QuadraticCommand *>(command()) : nullptr;
  }
  const DeepSeaVectorDraw::ArcCommand *command_as_ArcCommand() const {
    return command_type() == DeepSeaVectorDraw::VectorCommandUnion::ArcCommand ? static_cast<const DeepSeaVectorDraw::ArcCommand *>(command()) : nullptr;
  }
  const DeepSeaVectorDraw::ClosePathCommand *command_as_ClosePathCommand() const {
    return command_type() == DeepSeaVectorDraw::VectorCommandUnion::ClosePathCommand ? static_cast<const DeepSeaVectorDraw::ClosePathCommand *>(command()) : nullptr;
  }
  const DeepSeaVectorDraw::EllipseCommand *command_as_EllipseCommand() const {
    return command_type() == DeepSeaVectorDraw::VectorCommandUnion::EllipseCommand ? static_cast<const DeepSeaVectorDraw::EllipseCommand *>(command()) : nullptr;
  }
  const DeepSeaVectorDraw::RectangleCommand *command_as_RectangleCommand() const {
    return command_type() == DeepSeaVectorDraw::VectorCommandUnion::RectangleCommand ? static_cast<const DeepSeaVectorDraw::RectangleCommand *>(command()) : nullptr;
  }
  const DeepSeaVectorDraw::StrokePathCommand *command_as_StrokePathCommand() const {
    return command_type() == DeepSeaVectorDraw::VectorCommandUnion::StrokePathCommand ? static_cast<const DeepSeaVectorDraw::StrokePathCommand *>(command()) : nullptr;
  }
  const DeepSeaVectorDraw::FillPathCommand *command_as_FillPathCommand() const {
    return command_type() == DeepSeaVectorDraw::VectorCommandUnion::FillPathCommand ? static_cast<const DeepSeaVectorDraw::FillPathCommand *>(command()) : nullptr;
  }
  const DeepSeaVectorDraw::TextCommand *command_as_TextCommand() const {
    return command_type() == DeepSeaVectorDraw::VectorCommandUnion::TextCommand ? static_cast<const DeepSeaVectorDraw::TextCommand *>(command()) : nullptr;
  }
  const DeepSeaVectorDraw::TextRangeCommand *command_as_TextRangeCommand() const {
    return command_type() == DeepSeaVectorDraw::VectorCommandUnion::TextRangeCommand ? static_cast<const DeepSeaVectorDraw::TextRangeCommand *>(command()) : nullptr;
  }
  const DeepSeaVectorDraw::ImageCommand *command_as_ImageCommand() const {
    return command_type() == DeepSeaVectorDraw::VectorCommandUnion::ImageCommand ? static_cast<const DeepSeaVectorDraw::ImageCommand *>(command()) : nullptr;
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_COMMAND_TYPE, 1) &&
           VerifyOffsetRequired(verifier, VT_COMMAND) &&
           VerifyVectorCommandUnion(verifier, command(), command_type()) &&
           verifier.EndTable();
  }
};

template<> inline const DeepSeaVectorDraw::StartPathCommand *VectorCommand::command_as<DeepSeaVectorDraw::StartPathCommand>() const {
  return command_as_StartPathCommand();
}

template<> inline const DeepSeaVectorDraw::MoveCommand *VectorCommand::command_as<DeepSeaVectorDraw::MoveCommand>() const {
  return command_as_MoveCommand();
}

template<> inline const DeepSeaVectorDraw::LineCommand *VectorCommand::command_as<DeepSeaVectorDraw::LineCommand>() const {
  return command_as_LineCommand();
}

template<> inline const DeepSeaVectorDraw::BezierCommand *VectorCommand::command_as<DeepSeaVectorDraw::BezierCommand>() const {
  return command_as_BezierCommand();
}

template<> inline const DeepSeaVectorDraw::QuadraticCommand *VectorCommand::command_as<DeepSeaVectorDraw::QuadraticCommand>() const {
  return command_as_QuadraticCommand();
}

template<> inline const DeepSeaVectorDraw::ArcCommand *VectorCommand::command_as<DeepSeaVectorDraw::ArcCommand>() const {
  return command_as_ArcCommand();
}

template<> inline const DeepSeaVectorDraw::ClosePathCommand *VectorCommand::command_as<DeepSeaVectorDraw::ClosePathCommand>() const {
  return command_as_ClosePathCommand();
}

template<> inline const DeepSeaVectorDraw::EllipseCommand *VectorCommand::command_as<DeepSeaVectorDraw::EllipseCommand>() const {
  return command_as_EllipseCommand();
}

template<> inline const DeepSeaVectorDraw::RectangleCommand *VectorCommand::command_as<DeepSeaVectorDraw::RectangleCommand>() const {
  return command_as_RectangleCommand();
}

template<> inline const DeepSeaVectorDraw::StrokePathCommand *VectorCommand::command_as<DeepSeaVectorDraw::StrokePathCommand>() const {
  return command_as_StrokePathCommand();
}

template<> inline const DeepSeaVectorDraw::FillPathCommand *VectorCommand::command_as<DeepSeaVectorDraw::FillPathCommand>() const {
  return command_as_FillPathCommand();
}

template<> inline const DeepSeaVectorDraw::TextCommand *VectorCommand::command_as<DeepSeaVectorDraw::TextCommand>() const {
  return command_as_TextCommand();
}

template<> inline const DeepSeaVectorDraw::TextRangeCommand *VectorCommand::command_as<DeepSeaVectorDraw::TextRangeCommand>() const {
  return command_as_TextRangeCommand();
}

template<> inline const DeepSeaVectorDraw::ImageCommand *VectorCommand::command_as<DeepSeaVectorDraw::ImageCommand>() const {
  return command_as_ImageCommand();
}

struct VectorCommandBuilder {
  typedef VectorCommand Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_command_type(DeepSeaVectorDraw::VectorCommandUnion command_type) {
    fbb_.AddElement<uint8_t>(VectorCommand::VT_COMMAND_TYPE, static_cast<uint8_t>(command_type), 0);
  }
  void add_command(::flatbuffers::Offset<void> command) {
    fbb_.AddOffset(VectorCommand::VT_COMMAND, command);
  }
  explicit VectorCommandBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VectorCommand> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VectorCommand>(end);
    fbb_.Required(o, VectorCommand::VT_COMMAND);
    return o;
  }
};

inline ::flatbuffers::Offset<VectorCommand> CreateVectorCommand(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    DeepSeaVectorDraw::VectorCommandUnion command_type = DeepSeaVectorDraw::VectorCommandUnion::NONE,
    ::flatbuffers::Offset<void> command = 0) {
  VectorCommandBuilder builder_(_fbb);
  builder_.add_command(command);
  builder_.add_command_type(command_type);
  return builder_.Finish();
}

struct VectorImage FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef VectorImageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COLORMATERIALS = 4,
    VT_LINEARGRADIENTS = 6,
    VT_RADIALGRADIENTS = 8,
    VT_COMMANDS = 10,
    VT_SIZE = 12
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::ColorMaterial>> *colorMaterials() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::ColorMaterial>> *>(VT_COLORMATERIALS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::LinearGradient>> *linearGradients() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::LinearGradient>> *>(VT_LINEARGRADIENTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::RadialGradient>> *radialGradients() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::RadialGradient>> *>(VT_RADIALGRADIENTS);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::VectorCommand>> *commands() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::VectorCommand>> *>(VT_COMMANDS);
  }
  const DeepSeaVectorDraw::Vector2f *size() const {
    return GetStruct<const DeepSeaVectorDraw::Vector2f *>(VT_SIZE);
  }
  template <bool B = false>
  bool Verify(::flatbuffers::VerifierTemplate<B> &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COLORMATERIALS) &&
           verifier.VerifyVector(colorMaterials()) &&
           verifier.VerifyVectorOfTables(colorMaterials()) &&
           VerifyOffset(verifier, VT_LINEARGRADIENTS) &&
           verifier.VerifyVector(linearGradients()) &&
           verifier.VerifyVectorOfTables(linearGradients()) &&
           VerifyOffset(verifier, VT_RADIALGRADIENTS) &&
           verifier.VerifyVector(radialGradients()) &&
           verifier.VerifyVectorOfTables(radialGradients()) &&
           VerifyOffsetRequired(verifier, VT_COMMANDS) &&
           verifier.VerifyVector(commands()) &&
           verifier.VerifyVectorOfTables(commands()) &&
           VerifyFieldRequired<DeepSeaVectorDraw::Vector2f>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
};

struct VectorImageBuilder {
  typedef VectorImage Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_colorMaterials(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::ColorMaterial>>> colorMaterials) {
    fbb_.AddOffset(VectorImage::VT_COLORMATERIALS, colorMaterials);
  }
  void add_linearGradients(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::LinearGradient>>> linearGradients) {
    fbb_.AddOffset(VectorImage::VT_LINEARGRADIENTS, linearGradients);
  }
  void add_radialGradients(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::RadialGradient>>> radialGradients) {
    fbb_.AddOffset(VectorImage::VT_RADIALGRADIENTS, radialGradients);
  }
  void add_commands(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::VectorCommand>>> commands) {
    fbb_.AddOffset(VectorImage::VT_COMMANDS, commands);
  }
  void add_size(const DeepSeaVectorDraw::Vector2f *size) {
    fbb_.AddStruct(VectorImage::VT_SIZE, size);
  }
  explicit VectorImageBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<VectorImage> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<VectorImage>(end);
    fbb_.Required(o, VectorImage::VT_COMMANDS);
    fbb_.Required(o, VectorImage::VT_SIZE);
    return o;
  }
};

inline ::flatbuffers::Offset<VectorImage> CreateVectorImage(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::ColorMaterial>>> colorMaterials = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::LinearGradient>>> linearGradients = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::RadialGradient>>> radialGradients = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<DeepSeaVectorDraw::VectorCommand>>> commands = 0,
    const DeepSeaVectorDraw::Vector2f *size = nullptr) {
  VectorImageBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_commands(commands);
  builder_.add_radialGradients(radialGradients);
  builder_.add_linearGradients(linearGradients);
  builder_.add_colorMaterials(colorMaterials);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<VectorImage> CreateVectorImageDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<DeepSeaVectorDraw::ColorMaterial>> *colorMaterials = nullptr,
    const std::vector<::flatbuffers::Offset<DeepSeaVectorDraw::LinearGradient>> *linearGradients = nullptr,
    const std::vector<::flatbuffers::Offset<DeepSeaVectorDraw::RadialGradient>> *radialGradients = nullptr,
    const std::vector<::flatbuffers::Offset<DeepSeaVectorDraw::VectorCommand>> *commands = nullptr,
    const DeepSeaVectorDraw::Vector2f *size = nullptr) {
  auto colorMaterials__ = colorMaterials ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaVectorDraw::ColorMaterial>>(*colorMaterials) : 0;
  auto linearGradients__ = linearGradients ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaVectorDraw::LinearGradient>>(*linearGradients) : 0;
  auto radialGradients__ = radialGradients ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaVectorDraw::RadialGradient>>(*radialGradients) : 0;
  auto commands__ = commands ? _fbb.CreateVector<::flatbuffers::Offset<DeepSeaVectorDraw::VectorCommand>>(*commands) : 0;
  return DeepSeaVectorDraw::CreateVectorImage(
      _fbb,
      colorMaterials__,
      linearGradients__,
      radialGradients__,
      commands__,
      size);
}

template <bool B>
inline bool VerifyVectorCommandUnion(::flatbuffers::VerifierTemplate<B> &verifier, const void *obj, VectorCommandUnion type) {
  switch (type) {
    case VectorCommandUnion::NONE: {
      return true;
    }
    case VectorCommandUnion::StartPathCommand: {
      auto ptr = reinterpret_cast<const DeepSeaVectorDraw::StartPathCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::MoveCommand: {
      auto ptr = reinterpret_cast<const DeepSeaVectorDraw::MoveCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::LineCommand: {
      auto ptr = reinterpret_cast<const DeepSeaVectorDraw::LineCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::BezierCommand: {
      auto ptr = reinterpret_cast<const DeepSeaVectorDraw::BezierCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::QuadraticCommand: {
      auto ptr = reinterpret_cast<const DeepSeaVectorDraw::QuadraticCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::ArcCommand: {
      auto ptr = reinterpret_cast<const DeepSeaVectorDraw::ArcCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::ClosePathCommand: {
      auto ptr = reinterpret_cast<const DeepSeaVectorDraw::ClosePathCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::EllipseCommand: {
      auto ptr = reinterpret_cast<const DeepSeaVectorDraw::EllipseCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::RectangleCommand: {
      auto ptr = reinterpret_cast<const DeepSeaVectorDraw::RectangleCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::StrokePathCommand: {
      auto ptr = reinterpret_cast<const DeepSeaVectorDraw::StrokePathCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::FillPathCommand: {
      auto ptr = reinterpret_cast<const DeepSeaVectorDraw::FillPathCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::TextCommand: {
      auto ptr = reinterpret_cast<const DeepSeaVectorDraw::TextCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::TextRangeCommand: {
      auto ptr = reinterpret_cast<const DeepSeaVectorDraw::TextRangeCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case VectorCommandUnion::ImageCommand: {
      auto ptr = reinterpret_cast<const DeepSeaVectorDraw::ImageCommand *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

template <bool B>
inline bool VerifyVectorCommandUnionVector(::flatbuffers::VerifierTemplate<B> &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<VectorCommandUnion> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyVectorCommandUnion(
        verifier,  values->Get(i), types->GetEnum<VectorCommandUnion>(i))) {
      return false;
    }
  }
  return true;
}

inline const DeepSeaVectorDraw::VectorImage *GetVectorImage(const void *buf) {
  return ::flatbuffers::GetRoot<DeepSeaVectorDraw::VectorImage>(buf);
}

inline const DeepSeaVectorDraw::VectorImage *GetSizePrefixedVectorImage(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<DeepSeaVectorDraw::VectorImage>(buf);
}

template <bool B = false>
inline bool VerifyVectorImageBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifyBuffer<DeepSeaVectorDraw::VectorImage>(nullptr);
}

template <bool B = false>
inline bool VerifySizePrefixedVectorImageBuffer(
    ::flatbuffers::VerifierTemplate<B> &verifier) {
  return verifier.template VerifySizePrefixedBuffer<DeepSeaVectorDraw::VectorImage>(nullptr);
}

inline void FinishVectorImageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DeepSeaVectorDraw::VectorImage> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedVectorImageBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<DeepSeaVectorDraw::VectorImage> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace DeepSeaVectorDraw

#endif  // FLATBUFFERS_GENERATED_VECTORIMAGE_DEEPSEAVECTORDRAW_H_
