/*
 * Copyright 2018-2019 Aaron Barany
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#pragma once

#include <DeepSea/Render/Shaders/Color.mslh>
#include <DeepSea/Render/Shaders/VertexAttributes.mslh>
#include <DeepSea/VectorDraw/Shaders/VectorTextShared.mslh>

/**
 * @file
 * @brief Shader implementation for vector text elements using a tessellation shader.
 *
 * This is mutually exclusive to the functions in VectorElementTessText.mslh, which may be used to
 * for tessellation shaders. The HAS_TESSELLATION_STAGES define may be used to dynamically choose
 * between the tessellation and non-tessellation variants.
 *
 * These provide the vertex elements, uniforms, and basic vertex and pixel inputs/outputs.
 * You may write your own functions to incorperate them plus additional functionality, or simply
 * use the defaults.
 *
 * Shaders must provide a pipeline of the name dsVectorText and dsVectorTextGradient. For example,
 * the following pipeline definition will provide the default implementation:
 *
 * ```
 * pipeline dsVectorTextColor
 * {
 *     vertex = dsVectorElementText_defaultVertexColor;
 *     tessellation_control = dsVectorElementText_defaultTessControlColor;
 *     tessellation_evaluation = dsVectorElementText_defaultTessEvalColor;
 *     fragment = dsVectorElementText_defaultFragmentColor;
 *     DS_DEFAULT_VECTOR_ELEMENT_SHAPE_RENDER_STATES;
 * }
 *
 * pipeline dsVectorTextColorOutline
 * {
 *     vertex = dsVectorElementText_defaultVertexColor;
 *     tessellation_control = dsVectorElementText_defaultTessControlColor;
 *     tessellation_evaluation = dsVectorElementText_defaultTessEvalColor;
 *     fragment = dsVectorElementText_defaultFragmentColorOutline;
 *     DS_DEFAULT_VECTOR_ELEMENT_SHAPE_RENDER_STATES;
 * }
 *
 * pipeline dsVectorTextGradient
 * {
 *     vertex = dsVectorElementText_defaultVertexGradient;
 *     tessellation_control = dsVectorElementText_defaultTessControlGradient;
 *     tessellation_evaluation = dsVectorElementText_defaultTessEvalGradient;
 *     fragment = dsVectorElementText_defaultFragmentGradient;
 *     DS_DEFAULT_VECTOR_ELEMENT_SHAPE_RENDER_STATES;
 * }
 *
 * pipeline dsVectorTextGradientOutline
 * {
 *     vertex = dsVectorElementText_defaultVertexGradient;
 *     tessellation_control = dsVectorElementText_defaultTessControlGradient;
 *     tessellation_evaluation = dsVectorElementText_defaultTessEvalGradient;
 *     fragment = dsVectorElementText_defaultFragmentGradientOutline;
 *     DS_DEFAULT_VECTOR_ELEMENT_SHAPE_RENDER_STATES;
 * }
 * ```
 *
 * dsVectorElementText_defaultFragmentSRGB is provided to convert the final color to sRGB space.
 * However, in some situations it's still preferable to leave the color in linear space when doing
 * sRGB-correct rendering:
 * - When writing to an sRGB framebuffer, where the hardware will do the conversion.
 * - When blending with linear framebuffers. It is recommended that high-precision (> 8 bits per
 *   channel) is used in this case to avoid precision loss.
 */

/**
 * @brief The position of the glyph.
 */
[[vertex]] layout(location = DS_POSITION0) in vec2 dsVectorPosition;

/**
 * @brief The geometry for the text glyph.
 */
[[vertex]] layout(location = DS_POSITION1) in vec4 dsVectorGeometry;

/**
 * @brief The texture coordinates for the text glyph.
 */
[[vertex]] layout(location = DS_TEXCOORD0) in vec4 dsVectorTexCoords;

/**
 * @brief Indices for the vector text.
 *
 * - x: mip level
 * - y: info index
 * - z: fill material index
 * - w: outline material index
 */
[[vertex]] layout(location = DS_TEXCOORD1) in vec4 dsVectorIndices;

/**
 * @brief Output from the vertex stage.
 */
struct dsVectorTessVertexOutput
{
	/**
	 * @brief Geometry of the glyph.
	 */
	vec4 geometry;

	/**
	 * @brief The texture coordinates of the glyph.
	 */
	vec4 texCoords;

	/**
	 * @brief Indices for the vector text.
	 */
	vec4 indices;
};

/**
 * @brief Output from the tessellation control stage.
 */
struct dsVectorTessControlOutput
{
	/**
	 * @brief Geometry of the glyph.
	 */
	vec4 geometry;

	/**
	 * @brief The texture coordinates of the glyph.
	 */
	vec4 texCoords;

	/**
	 * @brief Indices for the vector text.
	 */
	vec4 indices;
};

/**
 * @brief Struct containing the raw information for materials.
 *
 * This is used to work around the limitation that the same struct can't be used for both the input
 * and output of a stage.
 */
struct dsVectorVertexFillMaterialInfo
{
	vec4 fillInfo0;
	vec4 fillInfo1;
	vec4 fillInfo2;
	vec4 fillInfo3;
};

struct dsVectorVertexOutlineMaterialInfo
{
	vec4 outlineInfo0;
	vec4 outlineInfo1;
	vec4 outlineInfo2;
	vec4 outlineInfo3;
};

struct dsVectorTessControlFillMaterialInfo
{
	vec4 fillInfo0;
	vec4 fillInfo1;
	vec4 fillInfo2;
	vec4 fillInfo3;
};

struct dsVectorTessControlOutlineMaterialInfo
{
	vec4 outlineInfo0;
	vec4 outlineInfo1;
	vec4 outlineInfo2;
	vec4 outlineInfo3;
};

struct dsVectorTessEvalFillMaterialInfo
{
	vec4 fillInfo0;
	vec4 fillInfo1;
	vec4 fillInfo2;
	vec4 fillInfo3;
};

struct dsVectorTessEvalOutlineMaterialInfo
{
	vec4 outlineInfo0;
	vec4 outlineInfo1;
	vec4 outlineInfo2;
	vec4 outlineInfo3;
};

/**
 * @brief Tessellation parameters.
 */
[[tessellation_control]] layout(vertices = 4) out;
[[tessellation_evaluation]] layout(quads) in;

/**
 * @brief The vertex output.
 */
[[vertex]] out dsVectorTessVertexOutput dsVectorVertexOut;
[[vertex]] out dsVectorVertexFillMaterialInfo dsVectorVertexFillMaterialOut;
[[vertex]] out dsVectorVertexOutlineMaterialInfo dsVectorVertexOutlineMaterialOut;

[[tessellation_control]] in dsVectorTessVertexOutput[] dsVectorVertexOut;
[[tessellation_control]] in dsVectorVertexFillMaterialInfo[] dsVectorVertexFillMaterialOut;
[[tessellation_control]] in dsVectorVertexOutlineMaterialInfo[] dsVectorVertexOutlineMaterialOut;

/**
 * @brief The tessellation control output.
 */
[[tessellation_control]] patch out dsVectorTessControlOutput dsVectorTessControlOut;
[[tessellation_control]] patch out dsVectorTessControlFillMaterialInfo
	dsVectorTessControlFillMaterialOut;
[[tessellation_control]] patch out dsVectorTessControlOutlineMaterialInfo
	dsVectorTessControlOutlineMaterialOut;

[[tessellation_evaluation]] patch in dsVectorTessControlOutput dsVectorTessControlOut;
[[tessellation_evaluation]] patch in dsVectorTessControlFillMaterialInfo
	dsVectorTessControlFillMaterialOut;
[[tessellation_evaluation]] patch in dsVectorTessControlOutlineMaterialInfo
	dsVectorTessControlOutlineMaterialOut;

/**
 * @brief The tessellation evaluation output
 */
[[tessellation_evaluation]] out dsVectorVertexOutput dsVectorVertexOut;
[[tessellation_evaluation]] out dsVectorFillMaterialInfo dsVectorVertexFillMaterialOut;
[[tessellation_evaluation]] out dsVectorOutlineMaterialInfo dsVectorVertexOutlineMaterialOut;

/**
 * @brief The final output color of the shader.
 */
[[fragment]] out vec4 dsVectorFinalColor;

/**
 * @brief Default render states for vector text elements.
 */
#ifdef SPIRV_VERSION
#define DS_DEFAULT_VECTOR_ELEMENT_TEXT_RENDER_STATES \
	patch_control_points = 1; \
	cull_mode = back; \
	/* Pre-multiply alpha. */ \
	blend_enable = true; \
	src_blend_factor = one; \
	dst_blend_factor = one_minus_src_alpha; \
	alpha_blend_op = add
#else
// Need to flip winding due to flipping the Y coordinate.
#define DS_DEFAULT_VECTOR_ELEMENT_TEXT_RENDER_STATES \
	patch_control_points = 1; \
	cull_mode = front; \
	/* Pre-multiply alpha. */ \
	blend_enable = true; \
	src_blend_factor = one; \
	dst_blend_factor = one_minus_src_alpha; \
	alpha_blend_op = add
#endif

/**
 * @brief Creates the vertex output.
 * @param[out] outPosition The output position in clip space.
 * @return The vertex output.
 */
[[vertex]]
dsVectorTessVertexOutput dsVectorElementText_processVertex(out vec4 outPosition)
{
	outPosition = vec4(dsVectorPosition, 0.0, 1.0);

	dsVectorTessVertexOutput result;
	result.geometry = dsVectorGeometry;
	result.texCoords = dsVectorTexCoords;
	result.indices = dsVectorIndices;

	return result;
}

/**
 * @brief Creates the final vertex output.
 * @param[out] outPosition The output position in clip space.
 * @return The vertex output.
 */
[[tessellation_evaluation]]
dsVectorVertexOutput dsVectorElementText_processTessellatedVertex(out vec4 outPosition)
{
	vec4 elementInfo[4];
	dsVectorShared_getElementLineInfo(elementInfo, dsVectorTessControlOut.indices.y);
	mat3 transform = dsVectorShared_getElementTransform(elementInfo);

	vec2 offset = mix(dsVectorTessControlOut.geometry.xy, dsVectorTessControlOut.geometry.zw,
		gl_TessCoord.xy);
	vec2 texCoords = mix(dsVectorTessControlOut.texCoords.xy, dsVectorTessControlOut.texCoords.zw,
		gl_TessCoord.xy);

	dsVectorVertexOutput result;
	result.position.xy = dsVectorTextShared_finalPosition(gl_in[0].gl_Position.xy, offset,
		elementInfo[3].y);
	outPosition = dsVectorShared_transform(result.position.zw, result.position.xy, transform);
	result.texCoordEmbolden = vec4(texCoords, dsVectorTessControlOut.indices.x, elementInfo[3].x);
	result.outlineAntiAlias = elementInfo[3].zw;
	result.materialIndicesOpacities = vec4(dsVectorTessControlOut.indices.zw, elementInfo[2].zw);
	result.shapeBounds = dsVectorShared_getElementBounds(elementInfo);

	return result;
}

/**
 * @brief Default vertex shader entry point function for solid colors.
 */
[[vertex]]
void dsVectorElementText_defaultVertexColor()
{
	dsVectorVertexOut = dsVectorElementText_processVertex(gl_Position);
}

/**
 * @brief Default vertex shader entry point function for gradients.
 */
[[vertex]]
void dsVectorElementText_defaultVertexGradient()
{
	dsVectorVertexOut = dsVectorElementText_processVertex(gl_Position);

	dsVectorMaterialInfo fillMaterial = dsVectorText_getFillMaterialInfo(dsVectorIndices.z);
	dsVectorMaterialInfo outlineMaterial = dsVectorText_getOutlineMaterialInfo(dsVectorIndices.w);

	dsVectorVertexFillMaterialOut.fillInfo0 = fillMaterial.info0;
	dsVectorVertexFillMaterialOut.fillInfo1 = fillMaterial.info1;
	dsVectorVertexFillMaterialOut.fillInfo2 = fillMaterial.info2;
	dsVectorVertexFillMaterialOut.fillInfo3 = fillMaterial.info3;

	dsVectorVertexOutlineMaterialOut.outlineInfo0 = outlineMaterial.info0;
	dsVectorVertexOutlineMaterialOut.outlineInfo1 = outlineMaterial.info1;
	dsVectorVertexOutlineMaterialOut.outlineInfo2 = outlineMaterial.info2;
	dsVectorVertexOutlineMaterialOut.outlineInfo3 = outlineMaterial.info3;
}

/**
 * @brief Default tessellation control shader entry point function for solid colors.
 */
[[tessellation_control]]
void dsVectorElementText_defaultTessControlColor()
{
	gl_out[gl_InvocationID].gl_Position = gl_in[0].gl_Position;
	dsVectorTessControlOut.geometry = dsVectorVertexOut[0].geometry;
	dsVectorTessControlOut.texCoords = dsVectorVertexOut[0].texCoords;
	dsVectorTessControlOut.indices = dsVectorVertexOut[0].indices;

	gl_TessLevelOuter[0] = 1.0;
	gl_TessLevelOuter[1] = 1.0;
	gl_TessLevelOuter[2] = 1.0;
	gl_TessLevelOuter[3] = 1.0;
	gl_TessLevelInner[0] = 1.0;
	gl_TessLevelInner[1] = 1.0;
}

/**
 * @brief Default tessellation control shader entry point function for gradients.
 */
[[tessellation_control]]
void dsVectorElementText_defaultTessControlGradient()
{
	gl_out[gl_InvocationID].gl_Position = gl_in[0].gl_Position;
	dsVectorTessControlOut.geometry = dsVectorVertexOut[0].geometry;
	dsVectorTessControlOut.texCoords = dsVectorVertexOut[0].texCoords;
	dsVectorTessControlOut.indices = dsVectorVertexOut[0].indices;

	dsVectorTessControlFillMaterialOut.fillInfo0 = dsVectorVertexFillMaterialOut[0].fillInfo0;
	dsVectorTessControlFillMaterialOut.fillInfo1 = dsVectorVertexFillMaterialOut[0].fillInfo1;
	dsVectorTessControlFillMaterialOut.fillInfo2 = dsVectorVertexFillMaterialOut[0].fillInfo2;
	dsVectorTessControlFillMaterialOut.fillInfo3 = dsVectorVertexFillMaterialOut[0].fillInfo3;

	dsVectorTessControlOutlineMaterialOut.outlineInfo0 =
		dsVectorVertexOutlineMaterialOut[0].outlineInfo0;
	dsVectorTessControlOutlineMaterialOut.outlineInfo1 =
		dsVectorVertexOutlineMaterialOut[0].outlineInfo1;
	dsVectorTessControlOutlineMaterialOut.outlineInfo2 =
		dsVectorVertexOutlineMaterialOut[0].outlineInfo2;
	dsVectorTessControlOutlineMaterialOut.outlineInfo3 =
		dsVectorVertexOutlineMaterialOut[0].outlineInfo3;

	gl_TessLevelOuter[0] = 1.0;
	gl_TessLevelOuter[1] = 1.0;
	gl_TessLevelOuter[2] = 1.0;
	gl_TessLevelOuter[3] = 1.0;
	gl_TessLevelInner[0] = 1.0;
	gl_TessLevelInner[1] = 1.0;
}

/**
 * @brief Default tessellation evaluation shader entry point function for solid colors.
 */
[[tessellation_evaluation]]
void dsVectorElementText_defaultTessEvalColor()
{
	dsVectorVertexOut = dsVectorElementText_processTessellatedVertex(gl_Position);
}

/**
 * @brief Default tessellation evaluation shader entry point function for gradients.
 */
[[tessellation_evaluation]]
void dsVectorElementText_defaultTessEvalGradient()
{
	dsVectorVertexOut = dsVectorElementText_processTessellatedVertex(gl_Position);

	dsVectorVertexFillMaterialOut.fillInfo0 = dsVectorTessControlFillMaterialOut.fillInfo0;
	dsVectorVertexFillMaterialOut.fillInfo1 = dsVectorTessControlFillMaterialOut.fillInfo1;
	dsVectorVertexFillMaterialOut.fillInfo2 = dsVectorTessControlFillMaterialOut.fillInfo2;
	dsVectorVertexFillMaterialOut.fillInfo3 = dsVectorTessControlFillMaterialOut.fillInfo3;

	dsVectorVertexOutlineMaterialOut.outlineInfo0 =
		dsVectorTessControlOutlineMaterialOut.outlineInfo0;
	dsVectorVertexOutlineMaterialOut.outlineInfo1 =
		dsVectorTessControlOutlineMaterialOut.outlineInfo1;
	dsVectorVertexOutlineMaterialOut.outlineInfo2 =
		dsVectorTessControlOutlineMaterialOut.outlineInfo2;
	dsVectorVertexOutlineMaterialOut.outlineInfo3 =
		dsVectorTessControlOutlineMaterialOut.outlineInfo3;
}

/**
 * @brief Default fragment shader entry point function for solid colors.
 */
[[fragment]]
void dsVectorElementText_defaultFragmentColor()
{
	dsVectorFinalColor = dsVectorElementText_getSolidColor();
}

/**
 * @brief Default fragment shader entry point function for solid colors with outlines.
 */
[[fragment]]
void dsVectorElementText_defaultFragmentColorOutline()
{
	dsVectorFinalColor = dsVectorElementText_getSolidColorOutline();
}

/**
 * @brief Default fragment shader entry point function for gradients.
 */
[[fragment]]
void dsVectorElementText_defaultFragmentGradient()
{
	dsVectorFinalColor = dsVectorElementText_getMaterialColor();
}

/**
 * @brief Default fragment shader entry point function for gradients with outlines.
 */
[[fragment]]
void dsVectorElementText_defaultFragmentGradientOutline()
{
	dsVectorFinalColor = dsVectorElementText_getMaterialColorOutline();
}

/**
 * @brief Default fragment shader entry point function for solid colors that converts to sRGB.
 */
[[fragment]]
void dsVectorElementText_defaultFragmentColorSRGB()
{
	dsVectorFinalColor = dsVectorElementText_getSolidColor();
	dsVectorFinalColor.rgb = dsSRGBFromLinear(dsVectorFinalColor.rgb);
}

/**
 * @brief Default fragment shader entry point function for solid colors with outlines that converts
 * to sRGB.
 */
[[fragment]]
void dsVectorElementText_defaultFragmentColorOutlineSRGB()
{
	dsVectorFinalColor = dsVectorElementText_getSolidColorOutline();
	dsVectorFinalColor.rgb = dsSRGBFromLinear(dsVectorFinalColor.rgb);
}

/**
 * @brief Default fragment shader entry point function for gradients that converts to sRGB.
 */
[[fragment]]
void dsVectorElementText_defaultFragmentGradientSRGB()
{
	dsVectorFinalColor = dsVectorElementText_getMaterialColor();
	dsVectorFinalColor.rgb = dsSRGBFromLinear(dsVectorFinalColor.rgb);
}

/**
 * @brief Default fragment shader entry point function for gradients with outlines that converts to
 * sRGB.
 */
[[fragment]]
void dsVectorElementText_defaultFragmentGradientOutlineSRGB()
{
	dsVectorFinalColor = dsVectorElementText_getMaterialColorOutline();
	dsVectorFinalColor.rgb = dsSRGBFromLinear(dsVectorFinalColor.rgb);
}
